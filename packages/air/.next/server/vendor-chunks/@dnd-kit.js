"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@dnd-kit";
exports.ids = ["vendor-chunks/@dnd-kit"];
exports.modules = {

/***/ "(ssr)/../../node_modules/@dnd-kit/accessibility/dist/accessibility.esm.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/@dnd-kit/accessibility/dist/accessibility.esm.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HiddenText: () => (/* binding */ HiddenText),\n/* harmony export */   LiveRegion: () => (/* binding */ LiveRegion),\n/* harmony export */   useAnnouncement: () => (/* binding */ useAnnouncement)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nconst hiddenStyles = {\n    display: \"none\"\n};\nfunction HiddenText(_ref) {\n    let { id, value } = _ref;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        id: id,\n        style: hiddenStyles\n    }, value);\n}\nfunction LiveRegion(_ref) {\n    let { id, announcement, ariaLiveType = \"assertive\" } = _ref;\n    // Hide element visually but keep it readable by screen readers\n    const visuallyHidden = {\n        position: \"fixed\",\n        width: 1,\n        height: 1,\n        margin: -1,\n        border: 0,\n        padding: 0,\n        overflow: \"hidden\",\n        clip: \"rect(0 0 0 0)\",\n        clipPath: \"inset(100%)\",\n        whiteSpace: \"nowrap\"\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        id: id,\n        style: visuallyHidden,\n        role: \"status\",\n        \"aria-live\": ariaLiveType,\n        \"aria-atomic\": true\n    }, announcement);\n}\nfunction useAnnouncement() {\n    const [announcement, setAnnouncement] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const announce = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((value)=>{\n        if (value != null) {\n            setAnnouncement(value);\n        }\n    }, []);\n    return {\n        announce,\n        announcement\n    };\n}\n //# sourceMappingURL=accessibility.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BkbmQta2l0L2FjY2Vzc2liaWxpdHkvZGlzdC9hY2Nlc3NpYmlsaXR5LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFxRDtBQUVyRCxNQUFNRyxlQUFlO0lBQ25CQyxTQUFTO0FBQ1g7QUFDQSxTQUFTQyxXQUFXQyxJQUFJO0lBQ3RCLElBQUksRUFDRkMsRUFBRSxFQUNGQyxLQUFLLEVBQ04sR0FBR0Y7SUFDSixxQkFBT04sMERBQW1CLENBQUMsT0FBTztRQUNoQ08sSUFBSUE7UUFDSkcsT0FBT1A7SUFDVCxHQUFHSztBQUNMO0FBRUEsU0FBU0csV0FBV0wsSUFBSTtJQUN0QixJQUFJLEVBQ0ZDLEVBQUUsRUFDRkssWUFBWSxFQUNaQyxlQUFlLFdBQVcsRUFDM0IsR0FBR1A7SUFDSiwrREFBK0Q7SUFDL0QsTUFBTVEsaUJBQWlCO1FBQ3JCQyxVQUFVO1FBQ1ZDLE9BQU87UUFDUEMsUUFBUTtRQUNSQyxRQUFRLENBQUM7UUFDVEMsUUFBUTtRQUNSQyxTQUFTO1FBQ1RDLFVBQVU7UUFDVkMsTUFBTTtRQUNOQyxVQUFVO1FBQ1ZDLFlBQVk7SUFDZDtJQUNBLHFCQUFPeEIsMERBQW1CLENBQUMsT0FBTztRQUNoQ08sSUFBSUE7UUFDSkcsT0FBT0k7UUFDUFcsTUFBTTtRQUNOLGFBQWFaO1FBQ2IsZUFBZTtJQUNqQixHQUFHRDtBQUNMO0FBRUEsU0FBU2M7SUFDUCxNQUFNLENBQUNkLGNBQWNlLGdCQUFnQixHQUFHMUIsK0NBQVFBLENBQUM7SUFDakQsTUFBTTJCLFdBQVcxQixrREFBV0EsQ0FBQ00sQ0FBQUE7UUFDM0IsSUFBSUEsU0FBUyxNQUFNO1lBQ2pCbUIsZ0JBQWdCbkI7UUFDbEI7SUFDRixHQUFHLEVBQUU7SUFDTCxPQUFPO1FBQ0xvQjtRQUNBaEI7SUFDRjtBQUNGO0FBRW1ELENBQ25ELDZDQUE2QyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQGRuZC1raXQvYWNjZXNzaWJpbGl0eS9kaXN0L2FjY2Vzc2liaWxpdHkuZXNtLmpzPzQxYzkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcblxuY29uc3QgaGlkZGVuU3R5bGVzID0ge1xuICBkaXNwbGF5OiAnbm9uZSdcbn07XG5mdW5jdGlvbiBIaWRkZW5UZXh0KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBpZCxcbiAgICB2YWx1ZVxuICB9ID0gX3JlZjtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGlkOiBpZCxcbiAgICBzdHlsZTogaGlkZGVuU3R5bGVzXG4gIH0sIHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gTGl2ZVJlZ2lvbihfcmVmKSB7XG4gIGxldCB7XG4gICAgaWQsXG4gICAgYW5ub3VuY2VtZW50LFxuICAgIGFyaWFMaXZlVHlwZSA9IFwiYXNzZXJ0aXZlXCJcbiAgfSA9IF9yZWY7XG4gIC8vIEhpZGUgZWxlbWVudCB2aXN1YWxseSBidXQga2VlcCBpdCByZWFkYWJsZSBieSBzY3JlZW4gcmVhZGVyc1xuICBjb25zdCB2aXN1YWxseUhpZGRlbiA9IHtcbiAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICB3aWR0aDogMSxcbiAgICBoZWlnaHQ6IDEsXG4gICAgbWFyZ2luOiAtMSxcbiAgICBib3JkZXI6IDAsXG4gICAgcGFkZGluZzogMCxcbiAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgY2xpcDogJ3JlY3QoMCAwIDAgMCknLFxuICAgIGNsaXBQYXRoOiAnaW5zZXQoMTAwJSknLFxuICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnXG4gIH07XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBpZDogaWQsXG4gICAgc3R5bGU6IHZpc3VhbGx5SGlkZGVuLFxuICAgIHJvbGU6IFwic3RhdHVzXCIsXG4gICAgXCJhcmlhLWxpdmVcIjogYXJpYUxpdmVUeXBlLFxuICAgIFwiYXJpYS1hdG9taWNcIjogdHJ1ZVxuICB9LCBhbm5vdW5jZW1lbnQpO1xufVxuXG5mdW5jdGlvbiB1c2VBbm5vdW5jZW1lbnQoKSB7XG4gIGNvbnN0IFthbm5vdW5jZW1lbnQsIHNldEFubm91bmNlbWVudF0gPSB1c2VTdGF0ZSgnJyk7XG4gIGNvbnN0IGFubm91bmNlID0gdXNlQ2FsbGJhY2sodmFsdWUgPT4ge1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICBzZXRBbm5vdW5jZW1lbnQodmFsdWUpO1xuICAgIH1cbiAgfSwgW10pO1xuICByZXR1cm4ge1xuICAgIGFubm91bmNlLFxuICAgIGFubm91bmNlbWVudFxuICB9O1xufVxuXG5leHBvcnQgeyBIaWRkZW5UZXh0LCBMaXZlUmVnaW9uLCB1c2VBbm5vdW5jZW1lbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjY2Vzc2liaWxpdHkuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsImhpZGRlblN0eWxlcyIsImRpc3BsYXkiLCJIaWRkZW5UZXh0IiwiX3JlZiIsImlkIiwidmFsdWUiLCJjcmVhdGVFbGVtZW50Iiwic3R5bGUiLCJMaXZlUmVnaW9uIiwiYW5ub3VuY2VtZW50IiwiYXJpYUxpdmVUeXBlIiwidmlzdWFsbHlIaWRkZW4iLCJwb3NpdGlvbiIsIndpZHRoIiwiaGVpZ2h0IiwibWFyZ2luIiwiYm9yZGVyIiwicGFkZGluZyIsIm92ZXJmbG93IiwiY2xpcCIsImNsaXBQYXRoIiwid2hpdGVTcGFjZSIsInJvbGUiLCJ1c2VBbm5vdW5jZW1lbnQiLCJzZXRBbm5vdW5jZW1lbnQiLCJhbm5vdW5jZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@dnd-kit/accessibility/dist/accessibility.esm.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@dnd-kit/core/dist/core.esm.js":
/*!*********************************************************!*\
  !*** ../../node_modules/@dnd-kit/core/dist/core.esm.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AutoScrollActivator: () => (/* binding */ AutoScrollActivator),\n/* harmony export */   DndContext: () => (/* binding */ DndContext),\n/* harmony export */   DragOverlay: () => (/* binding */ DragOverlay),\n/* harmony export */   KeyboardCode: () => (/* binding */ KeyboardCode),\n/* harmony export */   KeyboardSensor: () => (/* binding */ KeyboardSensor),\n/* harmony export */   MeasuringFrequency: () => (/* binding */ MeasuringFrequency),\n/* harmony export */   MeasuringStrategy: () => (/* binding */ MeasuringStrategy),\n/* harmony export */   MouseSensor: () => (/* binding */ MouseSensor),\n/* harmony export */   PointerSensor: () => (/* binding */ PointerSensor),\n/* harmony export */   TouchSensor: () => (/* binding */ TouchSensor),\n/* harmony export */   TraversalOrder: () => (/* binding */ TraversalOrder),\n/* harmony export */   applyModifiers: () => (/* binding */ applyModifiers),\n/* harmony export */   closestCenter: () => (/* binding */ closestCenter),\n/* harmony export */   closestCorners: () => (/* binding */ closestCorners),\n/* harmony export */   defaultAnnouncements: () => (/* binding */ defaultAnnouncements),\n/* harmony export */   defaultCoordinates: () => (/* binding */ defaultCoordinates),\n/* harmony export */   defaultDropAnimation: () => (/* binding */ defaultDropAnimationConfiguration),\n/* harmony export */   defaultDropAnimationSideEffects: () => (/* binding */ defaultDropAnimationSideEffects),\n/* harmony export */   defaultScreenReaderInstructions: () => (/* binding */ defaultScreenReaderInstructions),\n/* harmony export */   getClientRect: () => (/* binding */ getClientRect),\n/* harmony export */   getFirstCollision: () => (/* binding */ getFirstCollision),\n/* harmony export */   getScrollableAncestors: () => (/* binding */ getScrollableAncestors),\n/* harmony export */   pointerWithin: () => (/* binding */ pointerWithin),\n/* harmony export */   rectIntersection: () => (/* binding */ rectIntersection),\n/* harmony export */   useDndContext: () => (/* binding */ useDndContext),\n/* harmony export */   useDndMonitor: () => (/* binding */ useDndMonitor),\n/* harmony export */   useDraggable: () => (/* binding */ useDraggable),\n/* harmony export */   useDroppable: () => (/* binding */ useDroppable),\n/* harmony export */   useSensor: () => (/* binding */ useSensor),\n/* harmony export */   useSensors: () => (/* binding */ useSensors)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/../../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @dnd-kit/utilities */ \"(ssr)/../../node_modules/@dnd-kit/utilities/dist/utilities.esm.js\");\n/* harmony import */ var _dnd_kit_accessibility__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @dnd-kit/accessibility */ \"(ssr)/../../node_modules/@dnd-kit/accessibility/dist/accessibility.esm.js\");\n\n\n\n\nconst DndMonitorContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nfunction useDndMonitor(listener) {\n    const registerListener = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(DndMonitorContext);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!registerListener) {\n            throw new Error(\"useDndMonitor must be used within a children of <DndContext>\");\n        }\n        const unsubscribe = registerListener(listener);\n        return unsubscribe;\n    }, [\n        listener,\n        registerListener\n    ]);\n}\nfunction useDndMonitorProvider() {\n    const [listeners] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>new Set());\n    const registerListener = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((listener)=>{\n        listeners.add(listener);\n        return ()=>listeners.delete(listener);\n    }, [\n        listeners\n    ]);\n    const dispatch = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((_ref)=>{\n        let { type, event } = _ref;\n        listeners.forEach((listener)=>{\n            var _listener$type;\n            return (_listener$type = listener[type]) == null ? void 0 : _listener$type.call(listener, event);\n        });\n    }, [\n        listeners\n    ]);\n    return [\n        dispatch,\n        registerListener\n    ];\n}\nconst defaultScreenReaderInstructions = {\n    draggable: \"\\n    To pick up a draggable item, press the space bar.\\n    While dragging, use the arrow keys to move the item.\\n    Press space again to drop the item in its new position, or press escape to cancel.\\n  \"\n};\nconst defaultAnnouncements = {\n    onDragStart (_ref) {\n        let { active } = _ref;\n        return \"Picked up draggable item \" + active.id + \".\";\n    },\n    onDragOver (_ref2) {\n        let { active, over } = _ref2;\n        if (over) {\n            return \"Draggable item \" + active.id + \" was moved over droppable area \" + over.id + \".\";\n        }\n        return \"Draggable item \" + active.id + \" is no longer over a droppable area.\";\n    },\n    onDragEnd (_ref3) {\n        let { active, over } = _ref3;\n        if (over) {\n            return \"Draggable item \" + active.id + \" was dropped over droppable area \" + over.id;\n        }\n        return \"Draggable item \" + active.id + \" was dropped.\";\n    },\n    onDragCancel (_ref4) {\n        let { active } = _ref4;\n        return \"Dragging was cancelled. Draggable item \" + active.id + \" was dropped.\";\n    }\n};\nfunction Accessibility(_ref) {\n    let { announcements = defaultAnnouncements, container, hiddenTextDescribedById, screenReaderInstructions = defaultScreenReaderInstructions } = _ref;\n    const { announce, announcement } = (0,_dnd_kit_accessibility__WEBPACK_IMPORTED_MODULE_3__.useAnnouncement)();\n    const liveRegionId = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useUniqueId)(\"DndLiveRegion\");\n    const [mounted, setMounted] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        setMounted(true);\n    }, []);\n    useDndMonitor((0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            onDragStart (_ref2) {\n                let { active } = _ref2;\n                announce(announcements.onDragStart({\n                    active\n                }));\n            },\n            onDragMove (_ref3) {\n                let { active, over } = _ref3;\n                if (announcements.onDragMove) {\n                    announce(announcements.onDragMove({\n                        active,\n                        over\n                    }));\n                }\n            },\n            onDragOver (_ref4) {\n                let { active, over } = _ref4;\n                announce(announcements.onDragOver({\n                    active,\n                    over\n                }));\n            },\n            onDragEnd (_ref5) {\n                let { active, over } = _ref5;\n                announce(announcements.onDragEnd({\n                    active,\n                    over\n                }));\n            },\n            onDragCancel (_ref6) {\n                let { active, over } = _ref6;\n                announce(announcements.onDragCancel({\n                    active,\n                    over\n                }));\n            }\n        }), [\n        announce,\n        announcements\n    ]));\n    if (!mounted) {\n        return null;\n    }\n    const markup = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_dnd_kit_accessibility__WEBPACK_IMPORTED_MODULE_3__.HiddenText, {\n        id: hiddenTextDescribedById,\n        value: screenReaderInstructions.draggable\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_dnd_kit_accessibility__WEBPACK_IMPORTED_MODULE_3__.LiveRegion, {\n        id: liveRegionId,\n        announcement: announcement\n    }));\n    return container ? /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(markup, container) : markup;\n}\nvar Action;\n(function(Action) {\n    Action[\"DragStart\"] = \"dragStart\";\n    Action[\"DragMove\"] = \"dragMove\";\n    Action[\"DragEnd\"] = \"dragEnd\";\n    Action[\"DragCancel\"] = \"dragCancel\";\n    Action[\"DragOver\"] = \"dragOver\";\n    Action[\"RegisterDroppable\"] = \"registerDroppable\";\n    Action[\"SetDroppableDisabled\"] = \"setDroppableDisabled\";\n    Action[\"UnregisterDroppable\"] = \"unregisterDroppable\";\n})(Action || (Action = {}));\nfunction noop() {}\nfunction useSensor(sensor, options) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            sensor,\n            options: options != null ? options : {}\n        }), [\n        sensor,\n        options\n    ]);\n}\nfunction useSensors() {\n    for(var _len = arguments.length, sensors = new Array(_len), _key = 0; _key < _len; _key++){\n        sensors[_key] = arguments[_key];\n    }\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>[\n            ...sensors\n        ].filter((sensor)=>sensor != null), [\n        ...sensors\n    ]);\n}\nconst defaultCoordinates = /*#__PURE__*/ Object.freeze({\n    x: 0,\n    y: 0\n});\n/**\r\n * Returns the distance between two points\r\n */ function distanceBetween(p1, p2) {\n    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n}\nfunction getRelativeTransformOrigin(event, rect) {\n    const eventCoordinates = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getEventCoordinates)(event);\n    if (!eventCoordinates) {\n        return \"0 0\";\n    }\n    const transformOrigin = {\n        x: (eventCoordinates.x - rect.left) / rect.width * 100,\n        y: (eventCoordinates.y - rect.top) / rect.height * 100\n    };\n    return transformOrigin.x + \"% \" + transformOrigin.y + \"%\";\n}\n/**\r\n * Sort collisions from smallest to greatest value\r\n */ function sortCollisionsAsc(_ref, _ref2) {\n    let { data: { value: a } } = _ref;\n    let { data: { value: b } } = _ref2;\n    return a - b;\n}\n/**\r\n * Sort collisions from greatest to smallest value\r\n */ function sortCollisionsDesc(_ref3, _ref4) {\n    let { data: { value: a } } = _ref3;\n    let { data: { value: b } } = _ref4;\n    return b - a;\n}\n/**\r\n * Returns the coordinates of the corners of a given rectangle:\r\n * [TopLeft {x, y}, TopRight {x, y}, BottomLeft {x, y}, BottomRight {x, y}]\r\n */ function cornersOfRectangle(_ref5) {\n    let { left, top, height, width } = _ref5;\n    return [\n        {\n            x: left,\n            y: top\n        },\n        {\n            x: left + width,\n            y: top\n        },\n        {\n            x: left,\n            y: top + height\n        },\n        {\n            x: left + width,\n            y: top + height\n        }\n    ];\n}\nfunction getFirstCollision(collisions, property) {\n    if (!collisions || collisions.length === 0) {\n        return null;\n    }\n    const [firstCollision] = collisions;\n    return property ? firstCollision[property] : firstCollision;\n}\n/**\r\n * Returns the coordinates of the center of a given ClientRect\r\n */ function centerOfRectangle(rect, left, top) {\n    if (left === void 0) {\n        left = rect.left;\n    }\n    if (top === void 0) {\n        top = rect.top;\n    }\n    return {\n        x: left + rect.width * 0.5,\n        y: top + rect.height * 0.5\n    };\n}\n/**\r\n * Returns the closest rectangles from an array of rectangles to the center of a given\r\n * rectangle.\r\n */ const closestCenter = (_ref)=>{\n    let { collisionRect, droppableRects, droppableContainers } = _ref;\n    const centerRect = centerOfRectangle(collisionRect, collisionRect.left, collisionRect.top);\n    const collisions = [];\n    for (const droppableContainer of droppableContainers){\n        const { id } = droppableContainer;\n        const rect = droppableRects.get(id);\n        if (rect) {\n            const distBetween = distanceBetween(centerOfRectangle(rect), centerRect);\n            collisions.push({\n                id,\n                data: {\n                    droppableContainer,\n                    value: distBetween\n                }\n            });\n        }\n    }\n    return collisions.sort(sortCollisionsAsc);\n};\n/**\r\n * Returns the closest rectangles from an array of rectangles to the corners of\r\n * another rectangle.\r\n */ const closestCorners = (_ref)=>{\n    let { collisionRect, droppableRects, droppableContainers } = _ref;\n    const corners = cornersOfRectangle(collisionRect);\n    const collisions = [];\n    for (const droppableContainer of droppableContainers){\n        const { id } = droppableContainer;\n        const rect = droppableRects.get(id);\n        if (rect) {\n            const rectCorners = cornersOfRectangle(rect);\n            const distances = corners.reduce((accumulator, corner, index)=>{\n                return accumulator + distanceBetween(rectCorners[index], corner);\n            }, 0);\n            const effectiveDistance = Number((distances / 4).toFixed(4));\n            collisions.push({\n                id,\n                data: {\n                    droppableContainer,\n                    value: effectiveDistance\n                }\n            });\n        }\n    }\n    return collisions.sort(sortCollisionsAsc);\n};\n/**\r\n * Returns the intersecting rectangle area between two rectangles\r\n */ function getIntersectionRatio(entry, target) {\n    const top = Math.max(target.top, entry.top);\n    const left = Math.max(target.left, entry.left);\n    const right = Math.min(target.left + target.width, entry.left + entry.width);\n    const bottom = Math.min(target.top + target.height, entry.top + entry.height);\n    const width = right - left;\n    const height = bottom - top;\n    if (left < right && top < bottom) {\n        const targetArea = target.width * target.height;\n        const entryArea = entry.width * entry.height;\n        const intersectionArea = width * height;\n        const intersectionRatio = intersectionArea / (targetArea + entryArea - intersectionArea);\n        return Number(intersectionRatio.toFixed(4));\n    } // Rectangles do not overlap, or overlap has an area of zero (edge/corner overlap)\n    return 0;\n}\n/**\r\n * Returns the rectangles that has the greatest intersection area with a given\r\n * rectangle in an array of rectangles.\r\n */ const rectIntersection = (_ref)=>{\n    let { collisionRect, droppableRects, droppableContainers } = _ref;\n    const collisions = [];\n    for (const droppableContainer of droppableContainers){\n        const { id } = droppableContainer;\n        const rect = droppableRects.get(id);\n        if (rect) {\n            const intersectionRatio = getIntersectionRatio(rect, collisionRect);\n            if (intersectionRatio > 0) {\n                collisions.push({\n                    id,\n                    data: {\n                        droppableContainer,\n                        value: intersectionRatio\n                    }\n                });\n            }\n        }\n    }\n    return collisions.sort(sortCollisionsDesc);\n};\n/**\r\n * Check if a given point is contained within a bounding rectangle\r\n */ function isPointWithinRect(point, rect) {\n    const { top, left, bottom, right } = rect;\n    return top <= point.y && point.y <= bottom && left <= point.x && point.x <= right;\n}\n/**\r\n * Returns the rectangles that the pointer is hovering over\r\n */ const pointerWithin = (_ref)=>{\n    let { droppableContainers, droppableRects, pointerCoordinates } = _ref;\n    if (!pointerCoordinates) {\n        return [];\n    }\n    const collisions = [];\n    for (const droppableContainer of droppableContainers){\n        const { id } = droppableContainer;\n        const rect = droppableRects.get(id);\n        if (rect && isPointWithinRect(pointerCoordinates, rect)) {\n            /* There may be more than a single rectangle intersecting\r\n       * with the pointer coordinates. In order to sort the\r\n       * colliding rectangles, we measure the distance between\r\n       * the pointer and the corners of the intersecting rectangle\r\n       */ const corners = cornersOfRectangle(rect);\n            const distances = corners.reduce((accumulator, corner)=>{\n                return accumulator + distanceBetween(pointerCoordinates, corner);\n            }, 0);\n            const effectiveDistance = Number((distances / 4).toFixed(4));\n            collisions.push({\n                id,\n                data: {\n                    droppableContainer,\n                    value: effectiveDistance\n                }\n            });\n        }\n    }\n    return collisions.sort(sortCollisionsAsc);\n};\nfunction adjustScale(transform, rect1, rect2) {\n    return {\n        ...transform,\n        scaleX: rect1 && rect2 ? rect1.width / rect2.width : 1,\n        scaleY: rect1 && rect2 ? rect1.height / rect2.height : 1\n    };\n}\nfunction getRectDelta(rect1, rect2) {\n    return rect1 && rect2 ? {\n        x: rect1.left - rect2.left,\n        y: rect1.top - rect2.top\n    } : defaultCoordinates;\n}\nfunction createRectAdjustmentFn(modifier) {\n    return function adjustClientRect(rect) {\n        for(var _len = arguments.length, adjustments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            adjustments[_key - 1] = arguments[_key];\n        }\n        return adjustments.reduce((acc, adjustment)=>({\n                ...acc,\n                top: acc.top + modifier * adjustment.y,\n                bottom: acc.bottom + modifier * adjustment.y,\n                left: acc.left + modifier * adjustment.x,\n                right: acc.right + modifier * adjustment.x\n            }), {\n            ...rect\n        });\n    };\n}\nconst getAdjustedRect = /*#__PURE__*/ createRectAdjustmentFn(1);\nfunction parseTransform(transform) {\n    if (transform.startsWith(\"matrix3d(\")) {\n        const transformArray = transform.slice(9, -1).split(/, /);\n        return {\n            x: +transformArray[12],\n            y: +transformArray[13],\n            scaleX: +transformArray[0],\n            scaleY: +transformArray[5]\n        };\n    } else if (transform.startsWith(\"matrix(\")) {\n        const transformArray = transform.slice(7, -1).split(/, /);\n        return {\n            x: +transformArray[4],\n            y: +transformArray[5],\n            scaleX: +transformArray[0],\n            scaleY: +transformArray[3]\n        };\n    }\n    return null;\n}\nfunction inverseTransform(rect, transform, transformOrigin) {\n    const parsedTransform = parseTransform(transform);\n    if (!parsedTransform) {\n        return rect;\n    }\n    const { scaleX, scaleY, x: translateX, y: translateY } = parsedTransform;\n    const x = rect.left - translateX - (1 - scaleX) * parseFloat(transformOrigin);\n    const y = rect.top - translateY - (1 - scaleY) * parseFloat(transformOrigin.slice(transformOrigin.indexOf(\" \") + 1));\n    const w = scaleX ? rect.width / scaleX : rect.width;\n    const h = scaleY ? rect.height / scaleY : rect.height;\n    return {\n        width: w,\n        height: h,\n        top: y,\n        right: x + w,\n        bottom: y + h,\n        left: x\n    };\n}\nconst defaultOptions = {\n    ignoreTransform: false\n};\n/**\r\n * Returns the bounding client rect of an element relative to the viewport.\r\n */ function getClientRect(element, options) {\n    if (options === void 0) {\n        options = defaultOptions;\n    }\n    let rect = element.getBoundingClientRect();\n    if (options.ignoreTransform) {\n        const { transform, transformOrigin } = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(element).getComputedStyle(element);\n        if (transform) {\n            rect = inverseTransform(rect, transform, transformOrigin);\n        }\n    }\n    const { top, left, width, height, bottom, right } = rect;\n    return {\n        top,\n        left,\n        width,\n        height,\n        bottom,\n        right\n    };\n}\n/**\r\n * Returns the bounding client rect of an element relative to the viewport.\r\n *\r\n * @remarks\r\n * The ClientRect returned by this method does not take into account transforms\r\n * applied to the element it measures.\r\n *\r\n */ function getTransformAgnosticClientRect(element) {\n    return getClientRect(element, {\n        ignoreTransform: true\n    });\n}\nfunction getWindowClientRect(element) {\n    const width = element.innerWidth;\n    const height = element.innerHeight;\n    return {\n        top: 0,\n        left: 0,\n        right: width,\n        bottom: height,\n        width,\n        height\n    };\n}\nfunction isFixed(node, computedStyle) {\n    if (computedStyle === void 0) {\n        computedStyle = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(node).getComputedStyle(node);\n    }\n    return computedStyle.position === \"fixed\";\n}\nfunction isScrollable(element, computedStyle) {\n    if (computedStyle === void 0) {\n        computedStyle = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(element).getComputedStyle(element);\n    }\n    const overflowRegex = /(auto|scroll|overlay)/;\n    const properties = [\n        \"overflow\",\n        \"overflowX\",\n        \"overflowY\"\n    ];\n    return properties.some((property)=>{\n        const value = computedStyle[property];\n        return typeof value === \"string\" ? overflowRegex.test(value) : false;\n    });\n}\nfunction getScrollableAncestors(element, limit) {\n    const scrollParents = [];\n    function findScrollableAncestors(node) {\n        if (limit != null && scrollParents.length >= limit) {\n            return scrollParents;\n        }\n        if (!node) {\n            return scrollParents;\n        }\n        if ((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isDocument)(node) && node.scrollingElement != null && !scrollParents.includes(node.scrollingElement)) {\n            scrollParents.push(node.scrollingElement);\n            return scrollParents;\n        }\n        if (!(0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isHTMLElement)(node) || (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isSVGElement)(node)) {\n            return scrollParents;\n        }\n        if (scrollParents.includes(node)) {\n            return scrollParents;\n        }\n        const computedStyle = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(element).getComputedStyle(node);\n        if (node !== element) {\n            if (isScrollable(node, computedStyle)) {\n                scrollParents.push(node);\n            }\n        }\n        if (isFixed(node, computedStyle)) {\n            return scrollParents;\n        }\n        return findScrollableAncestors(node.parentNode);\n    }\n    if (!element) {\n        return scrollParents;\n    }\n    return findScrollableAncestors(element);\n}\nfunction getFirstScrollableAncestor(node) {\n    const [firstScrollableAncestor] = getScrollableAncestors(node, 1);\n    return firstScrollableAncestor != null ? firstScrollableAncestor : null;\n}\nfunction getScrollableElement(element) {\n    if (!_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.canUseDOM || !element) {\n        return null;\n    }\n    if ((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isWindow)(element)) {\n        return element;\n    }\n    if (!(0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isNode)(element)) {\n        return null;\n    }\n    if ((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isDocument)(element) || element === (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(element).scrollingElement) {\n        return window;\n    }\n    if ((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isHTMLElement)(element)) {\n        return element;\n    }\n    return null;\n}\nfunction getScrollXCoordinate(element) {\n    if ((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isWindow)(element)) {\n        return element.scrollX;\n    }\n    return element.scrollLeft;\n}\nfunction getScrollYCoordinate(element) {\n    if ((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isWindow)(element)) {\n        return element.scrollY;\n    }\n    return element.scrollTop;\n}\nfunction getScrollCoordinates(element) {\n    return {\n        x: getScrollXCoordinate(element),\n        y: getScrollYCoordinate(element)\n    };\n}\nvar Direction;\n(function(Direction) {\n    Direction[Direction[\"Forward\"] = 1] = \"Forward\";\n    Direction[Direction[\"Backward\"] = -1] = \"Backward\";\n})(Direction || (Direction = {}));\nfunction isDocumentScrollingElement(element) {\n    if (!_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.canUseDOM || !element) {\n        return false;\n    }\n    return element === document.scrollingElement;\n}\nfunction getScrollPosition(scrollingContainer) {\n    const minScroll = {\n        x: 0,\n        y: 0\n    };\n    const dimensions = isDocumentScrollingElement(scrollingContainer) ? {\n        height: window.innerHeight,\n        width: window.innerWidth\n    } : {\n        height: scrollingContainer.clientHeight,\n        width: scrollingContainer.clientWidth\n    };\n    const maxScroll = {\n        x: scrollingContainer.scrollWidth - dimensions.width,\n        y: scrollingContainer.scrollHeight - dimensions.height\n    };\n    const isTop = scrollingContainer.scrollTop <= minScroll.y;\n    const isLeft = scrollingContainer.scrollLeft <= minScroll.x;\n    const isBottom = scrollingContainer.scrollTop >= maxScroll.y;\n    const isRight = scrollingContainer.scrollLeft >= maxScroll.x;\n    return {\n        isTop,\n        isLeft,\n        isBottom,\n        isRight,\n        maxScroll,\n        minScroll\n    };\n}\nconst defaultThreshold = {\n    x: 0.2,\n    y: 0.2\n};\nfunction getScrollDirectionAndSpeed(scrollContainer, scrollContainerRect, _ref, acceleration, thresholdPercentage) {\n    let { top, left, right, bottom } = _ref;\n    if (acceleration === void 0) {\n        acceleration = 10;\n    }\n    if (thresholdPercentage === void 0) {\n        thresholdPercentage = defaultThreshold;\n    }\n    const { isTop, isBottom, isLeft, isRight } = getScrollPosition(scrollContainer);\n    const direction = {\n        x: 0,\n        y: 0\n    };\n    const speed = {\n        x: 0,\n        y: 0\n    };\n    const threshold = {\n        height: scrollContainerRect.height * thresholdPercentage.y,\n        width: scrollContainerRect.width * thresholdPercentage.x\n    };\n    if (!isTop && top <= scrollContainerRect.top + threshold.height) {\n        // Scroll Up\n        direction.y = Direction.Backward;\n        speed.y = acceleration * Math.abs((scrollContainerRect.top + threshold.height - top) / threshold.height);\n    } else if (!isBottom && bottom >= scrollContainerRect.bottom - threshold.height) {\n        // Scroll Down\n        direction.y = Direction.Forward;\n        speed.y = acceleration * Math.abs((scrollContainerRect.bottom - threshold.height - bottom) / threshold.height);\n    }\n    if (!isRight && right >= scrollContainerRect.right - threshold.width) {\n        // Scroll Right\n        direction.x = Direction.Forward;\n        speed.x = acceleration * Math.abs((scrollContainerRect.right - threshold.width - right) / threshold.width);\n    } else if (!isLeft && left <= scrollContainerRect.left + threshold.width) {\n        // Scroll Left\n        direction.x = Direction.Backward;\n        speed.x = acceleration * Math.abs((scrollContainerRect.left + threshold.width - left) / threshold.width);\n    }\n    return {\n        direction,\n        speed\n    };\n}\nfunction getScrollElementRect(element) {\n    if (element === document.scrollingElement) {\n        const { innerWidth, innerHeight } = window;\n        return {\n            top: 0,\n            left: 0,\n            right: innerWidth,\n            bottom: innerHeight,\n            width: innerWidth,\n            height: innerHeight\n        };\n    }\n    const { top, left, right, bottom } = element.getBoundingClientRect();\n    return {\n        top,\n        left,\n        right,\n        bottom,\n        width: element.clientWidth,\n        height: element.clientHeight\n    };\n}\nfunction getScrollOffsets(scrollableAncestors) {\n    return scrollableAncestors.reduce((acc, node)=>{\n        return (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.add)(acc, getScrollCoordinates(node));\n    }, defaultCoordinates);\n}\nfunction getScrollXOffset(scrollableAncestors) {\n    return scrollableAncestors.reduce((acc, node)=>{\n        return acc + getScrollXCoordinate(node);\n    }, 0);\n}\nfunction getScrollYOffset(scrollableAncestors) {\n    return scrollableAncestors.reduce((acc, node)=>{\n        return acc + getScrollYCoordinate(node);\n    }, 0);\n}\nfunction scrollIntoViewIfNeeded(element, measure) {\n    if (measure === void 0) {\n        measure = getClientRect;\n    }\n    if (!element) {\n        return;\n    }\n    const { top, left, bottom, right } = measure(element);\n    const firstScrollableAncestor = getFirstScrollableAncestor(element);\n    if (!firstScrollableAncestor) {\n        return;\n    }\n    if (bottom <= 0 || right <= 0 || top >= window.innerHeight || left >= window.innerWidth) {\n        element.scrollIntoView({\n            block: \"center\",\n            inline: \"center\"\n        });\n    }\n}\nconst properties = [\n    [\n        \"x\",\n        [\n            \"left\",\n            \"right\"\n        ],\n        getScrollXOffset\n    ],\n    [\n        \"y\",\n        [\n            \"top\",\n            \"bottom\"\n        ],\n        getScrollYOffset\n    ]\n];\nclass Rect {\n    constructor(rect, element){\n        this.rect = void 0;\n        this.width = void 0;\n        this.height = void 0;\n        this.top = void 0;\n        this.bottom = void 0;\n        this.right = void 0;\n        this.left = void 0;\n        const scrollableAncestors = getScrollableAncestors(element);\n        const scrollOffsets = getScrollOffsets(scrollableAncestors);\n        this.rect = {\n            ...rect\n        };\n        this.width = rect.width;\n        this.height = rect.height;\n        for (const [axis, keys, getScrollOffset] of properties){\n            for (const key of keys){\n                Object.defineProperty(this, key, {\n                    get: ()=>{\n                        const currentOffsets = getScrollOffset(scrollableAncestors);\n                        const scrollOffsetsDeltla = scrollOffsets[axis] - currentOffsets;\n                        return this.rect[key] + scrollOffsetsDeltla;\n                    },\n                    enumerable: true\n                });\n            }\n        }\n        Object.defineProperty(this, \"rect\", {\n            enumerable: false\n        });\n    }\n}\nclass Listeners {\n    constructor(target){\n        this.target = void 0;\n        this.listeners = [];\n        this.removeAll = ()=>{\n            this.listeners.forEach((listener)=>{\n                var _this$target;\n                return (_this$target = this.target) == null ? void 0 : _this$target.removeEventListener(...listener);\n            });\n        };\n        this.target = target;\n    }\n    add(eventName, handler, options) {\n        var _this$target2;\n        (_this$target2 = this.target) == null ? void 0 : _this$target2.addEventListener(eventName, handler, options);\n        this.listeners.push([\n            eventName,\n            handler,\n            options\n        ]);\n    }\n}\nfunction getEventListenerTarget(target) {\n    // If the `event.target` element is removed from the document events will still be targeted\n    // at it, and hence won't always bubble up to the window or document anymore.\n    // If there is any risk of an element being removed while it is being dragged,\n    // the best practice is to attach the event listeners directly to the target.\n    // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget\n    const { EventTarget } = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(target);\n    return target instanceof EventTarget ? target : (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(target);\n}\nfunction hasExceededDistance(delta, measurement) {\n    const dx = Math.abs(delta.x);\n    const dy = Math.abs(delta.y);\n    if (typeof measurement === \"number\") {\n        return Math.sqrt(dx ** 2 + dy ** 2) > measurement;\n    }\n    if (\"x\" in measurement && \"y\" in measurement) {\n        return dx > measurement.x && dy > measurement.y;\n    }\n    if (\"x\" in measurement) {\n        return dx > measurement.x;\n    }\n    if (\"y\" in measurement) {\n        return dy > measurement.y;\n    }\n    return false;\n}\nvar EventName;\n(function(EventName) {\n    EventName[\"Click\"] = \"click\";\n    EventName[\"DragStart\"] = \"dragstart\";\n    EventName[\"Keydown\"] = \"keydown\";\n    EventName[\"ContextMenu\"] = \"contextmenu\";\n    EventName[\"Resize\"] = \"resize\";\n    EventName[\"SelectionChange\"] = \"selectionchange\";\n    EventName[\"VisibilityChange\"] = \"visibilitychange\";\n})(EventName || (EventName = {}));\nfunction preventDefault(event) {\n    event.preventDefault();\n}\nfunction stopPropagation(event) {\n    event.stopPropagation();\n}\nvar KeyboardCode;\n(function(KeyboardCode) {\n    KeyboardCode[\"Space\"] = \"Space\";\n    KeyboardCode[\"Down\"] = \"ArrowDown\";\n    KeyboardCode[\"Right\"] = \"ArrowRight\";\n    KeyboardCode[\"Left\"] = \"ArrowLeft\";\n    KeyboardCode[\"Up\"] = \"ArrowUp\";\n    KeyboardCode[\"Esc\"] = \"Escape\";\n    KeyboardCode[\"Enter\"] = \"Enter\";\n})(KeyboardCode || (KeyboardCode = {}));\nconst defaultKeyboardCodes = {\n    start: [\n        KeyboardCode.Space,\n        KeyboardCode.Enter\n    ],\n    cancel: [\n        KeyboardCode.Esc\n    ],\n    end: [\n        KeyboardCode.Space,\n        KeyboardCode.Enter\n    ]\n};\nconst defaultKeyboardCoordinateGetter = (event, _ref)=>{\n    let { currentCoordinates } = _ref;\n    switch(event.code){\n        case KeyboardCode.Right:\n            return {\n                ...currentCoordinates,\n                x: currentCoordinates.x + 25\n            };\n        case KeyboardCode.Left:\n            return {\n                ...currentCoordinates,\n                x: currentCoordinates.x - 25\n            };\n        case KeyboardCode.Down:\n            return {\n                ...currentCoordinates,\n                y: currentCoordinates.y + 25\n            };\n        case KeyboardCode.Up:\n            return {\n                ...currentCoordinates,\n                y: currentCoordinates.y - 25\n            };\n    }\n    return undefined;\n};\nclass KeyboardSensor {\n    constructor(props){\n        this.props = void 0;\n        this.autoScrollEnabled = false;\n        this.referenceCoordinates = void 0;\n        this.listeners = void 0;\n        this.windowListeners = void 0;\n        this.props = props;\n        const { event: { target } } = props;\n        this.props = props;\n        this.listeners = new Listeners((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(target));\n        this.windowListeners = new Listeners((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(target));\n        this.handleKeyDown = this.handleKeyDown.bind(this);\n        this.handleCancel = this.handleCancel.bind(this);\n        this.attach();\n    }\n    attach() {\n        this.handleStart();\n        this.windowListeners.add(EventName.Resize, this.handleCancel);\n        this.windowListeners.add(EventName.VisibilityChange, this.handleCancel);\n        setTimeout(()=>this.listeners.add(EventName.Keydown, this.handleKeyDown));\n    }\n    handleStart() {\n        const { activeNode, onStart } = this.props;\n        const node = activeNode.node.current;\n        if (node) {\n            scrollIntoViewIfNeeded(node);\n        }\n        onStart(defaultCoordinates);\n    }\n    handleKeyDown(event) {\n        if ((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isKeyboardEvent)(event)) {\n            const { active, context, options } = this.props;\n            const { keyboardCodes = defaultKeyboardCodes, coordinateGetter = defaultKeyboardCoordinateGetter, scrollBehavior = \"smooth\" } = options;\n            const { code } = event;\n            if (keyboardCodes.end.includes(code)) {\n                this.handleEnd(event);\n                return;\n            }\n            if (keyboardCodes.cancel.includes(code)) {\n                this.handleCancel(event);\n                return;\n            }\n            const { collisionRect } = context.current;\n            const currentCoordinates = collisionRect ? {\n                x: collisionRect.left,\n                y: collisionRect.top\n            } : defaultCoordinates;\n            if (!this.referenceCoordinates) {\n                this.referenceCoordinates = currentCoordinates;\n            }\n            const newCoordinates = coordinateGetter(event, {\n                active,\n                context: context.current,\n                currentCoordinates\n            });\n            if (newCoordinates) {\n                const coordinatesDelta = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.subtract)(newCoordinates, currentCoordinates);\n                const scrollDelta = {\n                    x: 0,\n                    y: 0\n                };\n                const { scrollableAncestors } = context.current;\n                for (const scrollContainer of scrollableAncestors){\n                    const direction = event.code;\n                    const { isTop, isRight, isLeft, isBottom, maxScroll, minScroll } = getScrollPosition(scrollContainer);\n                    const scrollElementRect = getScrollElementRect(scrollContainer);\n                    const clampedCoordinates = {\n                        x: Math.min(direction === KeyboardCode.Right ? scrollElementRect.right - scrollElementRect.width / 2 : scrollElementRect.right, Math.max(direction === KeyboardCode.Right ? scrollElementRect.left : scrollElementRect.left + scrollElementRect.width / 2, newCoordinates.x)),\n                        y: Math.min(direction === KeyboardCode.Down ? scrollElementRect.bottom - scrollElementRect.height / 2 : scrollElementRect.bottom, Math.max(direction === KeyboardCode.Down ? scrollElementRect.top : scrollElementRect.top + scrollElementRect.height / 2, newCoordinates.y))\n                    };\n                    const canScrollX = direction === KeyboardCode.Right && !isRight || direction === KeyboardCode.Left && !isLeft;\n                    const canScrollY = direction === KeyboardCode.Down && !isBottom || direction === KeyboardCode.Up && !isTop;\n                    if (canScrollX && clampedCoordinates.x !== newCoordinates.x) {\n                        const newScrollCoordinates = scrollContainer.scrollLeft + coordinatesDelta.x;\n                        const canScrollToNewCoordinates = direction === KeyboardCode.Right && newScrollCoordinates <= maxScroll.x || direction === KeyboardCode.Left && newScrollCoordinates >= minScroll.x;\n                        if (canScrollToNewCoordinates && !coordinatesDelta.y) {\n                            // We don't need to update coordinates, the scroll adjustment alone will trigger\n                            // logic to auto-detect the new container we are over\n                            scrollContainer.scrollTo({\n                                left: newScrollCoordinates,\n                                behavior: scrollBehavior\n                            });\n                            return;\n                        }\n                        if (canScrollToNewCoordinates) {\n                            scrollDelta.x = scrollContainer.scrollLeft - newScrollCoordinates;\n                        } else {\n                            scrollDelta.x = direction === KeyboardCode.Right ? scrollContainer.scrollLeft - maxScroll.x : scrollContainer.scrollLeft - minScroll.x;\n                        }\n                        if (scrollDelta.x) {\n                            scrollContainer.scrollBy({\n                                left: -scrollDelta.x,\n                                behavior: scrollBehavior\n                            });\n                        }\n                        break;\n                    } else if (canScrollY && clampedCoordinates.y !== newCoordinates.y) {\n                        const newScrollCoordinates = scrollContainer.scrollTop + coordinatesDelta.y;\n                        const canScrollToNewCoordinates = direction === KeyboardCode.Down && newScrollCoordinates <= maxScroll.y || direction === KeyboardCode.Up && newScrollCoordinates >= minScroll.y;\n                        if (canScrollToNewCoordinates && !coordinatesDelta.x) {\n                            // We don't need to update coordinates, the scroll adjustment alone will trigger\n                            // logic to auto-detect the new container we are over\n                            scrollContainer.scrollTo({\n                                top: newScrollCoordinates,\n                                behavior: scrollBehavior\n                            });\n                            return;\n                        }\n                        if (canScrollToNewCoordinates) {\n                            scrollDelta.y = scrollContainer.scrollTop - newScrollCoordinates;\n                        } else {\n                            scrollDelta.y = direction === KeyboardCode.Down ? scrollContainer.scrollTop - maxScroll.y : scrollContainer.scrollTop - minScroll.y;\n                        }\n                        if (scrollDelta.y) {\n                            scrollContainer.scrollBy({\n                                top: -scrollDelta.y,\n                                behavior: scrollBehavior\n                            });\n                        }\n                        break;\n                    }\n                }\n                this.handleMove(event, (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.add)((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.subtract)(newCoordinates, this.referenceCoordinates), scrollDelta));\n            }\n        }\n    }\n    handleMove(event, coordinates) {\n        const { onMove } = this.props;\n        event.preventDefault();\n        onMove(coordinates);\n    }\n    handleEnd(event) {\n        const { onEnd } = this.props;\n        event.preventDefault();\n        this.detach();\n        onEnd();\n    }\n    handleCancel(event) {\n        const { onCancel } = this.props;\n        event.preventDefault();\n        this.detach();\n        onCancel();\n    }\n    detach() {\n        this.listeners.removeAll();\n        this.windowListeners.removeAll();\n    }\n}\nKeyboardSensor.activators = [\n    {\n        eventName: \"onKeyDown\",\n        handler: (event, _ref, _ref2)=>{\n            let { keyboardCodes = defaultKeyboardCodes, onActivation } = _ref;\n            let { active } = _ref2;\n            const { code } = event.nativeEvent;\n            if (keyboardCodes.start.includes(code)) {\n                const activator = active.activatorNode.current;\n                if (activator && event.target !== activator) {\n                    return false;\n                }\n                event.preventDefault();\n                onActivation == null ? void 0 : onActivation({\n                    event: event.nativeEvent\n                });\n                return true;\n            }\n            return false;\n        }\n    }\n];\nfunction isDistanceConstraint(constraint) {\n    return Boolean(constraint && \"distance\" in constraint);\n}\nfunction isDelayConstraint(constraint) {\n    return Boolean(constraint && \"delay\" in constraint);\n}\nclass AbstractPointerSensor {\n    constructor(props, events, listenerTarget){\n        var _getEventCoordinates;\n        if (listenerTarget === void 0) {\n            listenerTarget = getEventListenerTarget(props.event.target);\n        }\n        this.props = void 0;\n        this.events = void 0;\n        this.autoScrollEnabled = true;\n        this.document = void 0;\n        this.activated = false;\n        this.initialCoordinates = void 0;\n        this.timeoutId = null;\n        this.listeners = void 0;\n        this.documentListeners = void 0;\n        this.windowListeners = void 0;\n        this.props = props;\n        this.events = events;\n        const { event } = props;\n        const { target } = event;\n        this.props = props;\n        this.events = events;\n        this.document = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(target);\n        this.documentListeners = new Listeners(this.document);\n        this.listeners = new Listeners(listenerTarget);\n        this.windowListeners = new Listeners((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(target));\n        this.initialCoordinates = (_getEventCoordinates = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getEventCoordinates)(event)) != null ? _getEventCoordinates : defaultCoordinates;\n        this.handleStart = this.handleStart.bind(this);\n        this.handleMove = this.handleMove.bind(this);\n        this.handleEnd = this.handleEnd.bind(this);\n        this.handleCancel = this.handleCancel.bind(this);\n        this.handleKeydown = this.handleKeydown.bind(this);\n        this.removeTextSelection = this.removeTextSelection.bind(this);\n        this.attach();\n    }\n    attach() {\n        const { events, props: { options: { activationConstraint, bypassActivationConstraint } } } = this;\n        this.listeners.add(events.move.name, this.handleMove, {\n            passive: false\n        });\n        this.listeners.add(events.end.name, this.handleEnd);\n        this.windowListeners.add(EventName.Resize, this.handleCancel);\n        this.windowListeners.add(EventName.DragStart, preventDefault);\n        this.windowListeners.add(EventName.VisibilityChange, this.handleCancel);\n        this.windowListeners.add(EventName.ContextMenu, preventDefault);\n        this.documentListeners.add(EventName.Keydown, this.handleKeydown);\n        if (activationConstraint) {\n            if (bypassActivationConstraint != null && bypassActivationConstraint({\n                event: this.props.event,\n                activeNode: this.props.activeNode,\n                options: this.props.options\n            })) {\n                return this.handleStart();\n            }\n            if (isDelayConstraint(activationConstraint)) {\n                this.timeoutId = setTimeout(this.handleStart, activationConstraint.delay);\n                return;\n            }\n            if (isDistanceConstraint(activationConstraint)) {\n                return;\n            }\n        }\n        this.handleStart();\n    }\n    detach() {\n        this.listeners.removeAll();\n        this.windowListeners.removeAll(); // Wait until the next event loop before removing document listeners\n        // This is necessary because we listen for `click` and `selection` events on the document\n        setTimeout(this.documentListeners.removeAll, 50);\n        if (this.timeoutId !== null) {\n            clearTimeout(this.timeoutId);\n            this.timeoutId = null;\n        }\n    }\n    handleStart() {\n        const { initialCoordinates } = this;\n        const { onStart } = this.props;\n        if (initialCoordinates) {\n            this.activated = true; // Stop propagation of click events once activation constraints are met\n            this.documentListeners.add(EventName.Click, stopPropagation, {\n                capture: true\n            }); // Remove any text selection from the document\n            this.removeTextSelection(); // Prevent further text selection while dragging\n            this.documentListeners.add(EventName.SelectionChange, this.removeTextSelection);\n            onStart(initialCoordinates);\n        }\n    }\n    handleMove(event) {\n        var _getEventCoordinates2;\n        const { activated, initialCoordinates, props } = this;\n        const { onMove, options: { activationConstraint } } = props;\n        if (!initialCoordinates) {\n            return;\n        }\n        const coordinates = (_getEventCoordinates2 = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getEventCoordinates)(event)) != null ? _getEventCoordinates2 : defaultCoordinates;\n        const delta = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.subtract)(initialCoordinates, coordinates); // Constraint validation\n        if (!activated && activationConstraint) {\n            if (isDistanceConstraint(activationConstraint)) {\n                if (activationConstraint.tolerance != null && hasExceededDistance(delta, activationConstraint.tolerance)) {\n                    return this.handleCancel();\n                }\n                if (hasExceededDistance(delta, activationConstraint.distance)) {\n                    return this.handleStart();\n                }\n            }\n            if (isDelayConstraint(activationConstraint)) {\n                if (hasExceededDistance(delta, activationConstraint.tolerance)) {\n                    return this.handleCancel();\n                }\n            }\n            return;\n        }\n        if (event.cancelable) {\n            event.preventDefault();\n        }\n        onMove(coordinates);\n    }\n    handleEnd() {\n        const { onEnd } = this.props;\n        this.detach();\n        onEnd();\n    }\n    handleCancel() {\n        const { onCancel } = this.props;\n        this.detach();\n        onCancel();\n    }\n    handleKeydown(event) {\n        if (event.code === KeyboardCode.Esc) {\n            this.handleCancel();\n        }\n    }\n    removeTextSelection() {\n        var _this$document$getSel;\n        (_this$document$getSel = this.document.getSelection()) == null ? void 0 : _this$document$getSel.removeAllRanges();\n    }\n}\nconst events = {\n    move: {\n        name: \"pointermove\"\n    },\n    end: {\n        name: \"pointerup\"\n    }\n};\nclass PointerSensor extends AbstractPointerSensor {\n    constructor(props){\n        const { event } = props; // Pointer events stop firing if the target is unmounted while dragging\n        // Therefore we attach listeners to the owner document instead\n        const listenerTarget = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(event.target);\n        super(props, events, listenerTarget);\n    }\n}\nPointerSensor.activators = [\n    {\n        eventName: \"onPointerDown\",\n        handler: (_ref, _ref2)=>{\n            let { nativeEvent: event } = _ref;\n            let { onActivation } = _ref2;\n            if (!event.isPrimary || event.button !== 0) {\n                return false;\n            }\n            onActivation == null ? void 0 : onActivation({\n                event\n            });\n            return true;\n        }\n    }\n];\nconst events$1 = {\n    move: {\n        name: \"mousemove\"\n    },\n    end: {\n        name: \"mouseup\"\n    }\n};\nvar MouseButton;\n(function(MouseButton) {\n    MouseButton[MouseButton[\"RightClick\"] = 2] = \"RightClick\";\n})(MouseButton || (MouseButton = {}));\nclass MouseSensor extends AbstractPointerSensor {\n    constructor(props){\n        super(props, events$1, (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(props.event.target));\n    }\n}\nMouseSensor.activators = [\n    {\n        eventName: \"onMouseDown\",\n        handler: (_ref, _ref2)=>{\n            let { nativeEvent: event } = _ref;\n            let { onActivation } = _ref2;\n            if (event.button === MouseButton.RightClick) {\n                return false;\n            }\n            onActivation == null ? void 0 : onActivation({\n                event\n            });\n            return true;\n        }\n    }\n];\nconst events$2 = {\n    move: {\n        name: \"touchmove\"\n    },\n    end: {\n        name: \"touchend\"\n    }\n};\nclass TouchSensor extends AbstractPointerSensor {\n    constructor(props){\n        super(props, events$2);\n    }\n    static setup() {\n        // Adding a non-capture and non-passive `touchmove` listener in order\n        // to force `event.preventDefault()` calls to work in dynamically added\n        // touchmove event handlers. This is required for iOS Safari.\n        window.addEventListener(events$2.move.name, noop, {\n            capture: false,\n            passive: false\n        });\n        return function teardown() {\n            window.removeEventListener(events$2.move.name, noop);\n        }; // We create a new handler because the teardown function of another sensor\n        // could remove our event listener if we use a referentially equal listener.\n        function noop() {}\n    }\n}\nTouchSensor.activators = [\n    {\n        eventName: \"onTouchStart\",\n        handler: (_ref, _ref2)=>{\n            let { nativeEvent: event } = _ref;\n            let { onActivation } = _ref2;\n            const { touches } = event;\n            if (touches.length > 1) {\n                return false;\n            }\n            onActivation == null ? void 0 : onActivation({\n                event\n            });\n            return true;\n        }\n    }\n];\nvar AutoScrollActivator;\n(function(AutoScrollActivator) {\n    AutoScrollActivator[AutoScrollActivator[\"Pointer\"] = 0] = \"Pointer\";\n    AutoScrollActivator[AutoScrollActivator[\"DraggableRect\"] = 1] = \"DraggableRect\";\n})(AutoScrollActivator || (AutoScrollActivator = {}));\nvar TraversalOrder;\n(function(TraversalOrder) {\n    TraversalOrder[TraversalOrder[\"TreeOrder\"] = 0] = \"TreeOrder\";\n    TraversalOrder[TraversalOrder[\"ReversedTreeOrder\"] = 1] = \"ReversedTreeOrder\";\n})(TraversalOrder || (TraversalOrder = {}));\nfunction useAutoScroller(_ref) {\n    let { acceleration, activator = AutoScrollActivator.Pointer, canScroll, draggingRect, enabled, interval = 5, order = TraversalOrder.TreeOrder, pointerCoordinates, scrollableAncestors, scrollableAncestorRects, delta, threshold } = _ref;\n    const scrollIntent = useScrollIntent({\n        delta,\n        disabled: !enabled\n    });\n    const [setAutoScrollInterval, clearAutoScrollInterval] = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useInterval)();\n    const scrollSpeed = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        x: 0,\n        y: 0\n    });\n    const scrollDirection = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        x: 0,\n        y: 0\n    });\n    const rect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        switch(activator){\n            case AutoScrollActivator.Pointer:\n                return pointerCoordinates ? {\n                    top: pointerCoordinates.y,\n                    bottom: pointerCoordinates.y,\n                    left: pointerCoordinates.x,\n                    right: pointerCoordinates.x\n                } : null;\n            case AutoScrollActivator.DraggableRect:\n                return draggingRect;\n        }\n    }, [\n        activator,\n        draggingRect,\n        pointerCoordinates\n    ]);\n    const scrollContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const autoScroll = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        const scrollContainer = scrollContainerRef.current;\n        if (!scrollContainer) {\n            return;\n        }\n        const scrollLeft = scrollSpeed.current.x * scrollDirection.current.x;\n        const scrollTop = scrollSpeed.current.y * scrollDirection.current.y;\n        scrollContainer.scrollBy(scrollLeft, scrollTop);\n    }, []);\n    const sortedScrollableAncestors = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>order === TraversalOrder.TreeOrder ? [\n            ...scrollableAncestors\n        ].reverse() : scrollableAncestors, [\n        order,\n        scrollableAncestors\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!enabled || !scrollableAncestors.length || !rect) {\n            clearAutoScrollInterval();\n            return;\n        }\n        for (const scrollContainer of sortedScrollableAncestors){\n            if ((canScroll == null ? void 0 : canScroll(scrollContainer)) === false) {\n                continue;\n            }\n            const index = scrollableAncestors.indexOf(scrollContainer);\n            const scrollContainerRect = scrollableAncestorRects[index];\n            if (!scrollContainerRect) {\n                continue;\n            }\n            const { direction, speed } = getScrollDirectionAndSpeed(scrollContainer, scrollContainerRect, rect, acceleration, threshold);\n            for (const axis of [\n                \"x\",\n                \"y\"\n            ]){\n                if (!scrollIntent[axis][direction[axis]]) {\n                    speed[axis] = 0;\n                    direction[axis] = 0;\n                }\n            }\n            if (speed.x > 0 || speed.y > 0) {\n                clearAutoScrollInterval();\n                scrollContainerRef.current = scrollContainer;\n                setAutoScrollInterval(autoScroll, interval);\n                scrollSpeed.current = speed;\n                scrollDirection.current = direction;\n                return;\n            }\n        }\n        scrollSpeed.current = {\n            x: 0,\n            y: 0\n        };\n        scrollDirection.current = {\n            x: 0,\n            y: 0\n        };\n        clearAutoScrollInterval();\n    }, [\n        acceleration,\n        autoScroll,\n        canScroll,\n        clearAutoScrollInterval,\n        enabled,\n        interval,\n        JSON.stringify(rect),\n        JSON.stringify(scrollIntent),\n        setAutoScrollInterval,\n        scrollableAncestors,\n        sortedScrollableAncestors,\n        scrollableAncestorRects,\n        JSON.stringify(threshold)\n    ]);\n}\nconst defaultScrollIntent = {\n    x: {\n        [Direction.Backward]: false,\n        [Direction.Forward]: false\n    },\n    y: {\n        [Direction.Backward]: false,\n        [Direction.Forward]: false\n    }\n};\nfunction useScrollIntent(_ref2) {\n    let { delta, disabled } = _ref2;\n    const previousDelta = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.usePrevious)(delta);\n    return (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLazyMemo)((previousIntent)=>{\n        if (disabled || !previousDelta || !previousIntent) {\n            // Reset scroll intent tracking when auto-scrolling is disabled\n            return defaultScrollIntent;\n        }\n        const direction = {\n            x: Math.sign(delta.x - previousDelta.x),\n            y: Math.sign(delta.y - previousDelta.y)\n        }; // Keep track of the user intent to scroll in each direction for both axis\n        return {\n            x: {\n                [Direction.Backward]: previousIntent.x[Direction.Backward] || direction.x === -1,\n                [Direction.Forward]: previousIntent.x[Direction.Forward] || direction.x === 1\n            },\n            y: {\n                [Direction.Backward]: previousIntent.y[Direction.Backward] || direction.y === -1,\n                [Direction.Forward]: previousIntent.y[Direction.Forward] || direction.y === 1\n            }\n        };\n    }, [\n        disabled,\n        delta,\n        previousDelta\n    ]);\n}\nfunction useCachedNode(draggableNodes, id) {\n    const draggableNode = id !== null ? draggableNodes.get(id) : undefined;\n    const node = draggableNode ? draggableNode.node.current : null;\n    return (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLazyMemo)((cachedNode)=>{\n        var _ref;\n        if (id === null) {\n            return null;\n        } // In some cases, the draggable node can unmount while dragging\n        // This is the case for virtualized lists. In those situations,\n        // we fall back to the last known value for that node.\n        return (_ref = node != null ? node : cachedNode) != null ? _ref : null;\n    }, [\n        node,\n        id\n    ]);\n}\nfunction useCombineActivators(sensors, getSyntheticHandler) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>sensors.reduce((accumulator, sensor)=>{\n            const { sensor: Sensor } = sensor;\n            const sensorActivators = Sensor.activators.map((activator)=>({\n                    eventName: activator.eventName,\n                    handler: getSyntheticHandler(activator.handler, sensor)\n                }));\n            return [\n                ...accumulator,\n                ...sensorActivators\n            ];\n        }, []), [\n        sensors,\n        getSyntheticHandler\n    ]);\n}\nvar MeasuringStrategy;\n(function(MeasuringStrategy) {\n    MeasuringStrategy[MeasuringStrategy[\"Always\"] = 0] = \"Always\";\n    MeasuringStrategy[MeasuringStrategy[\"BeforeDragging\"] = 1] = \"BeforeDragging\";\n    MeasuringStrategy[MeasuringStrategy[\"WhileDragging\"] = 2] = \"WhileDragging\";\n})(MeasuringStrategy || (MeasuringStrategy = {}));\nvar MeasuringFrequency;\n(function(MeasuringFrequency) {\n    MeasuringFrequency[\"Optimized\"] = \"optimized\";\n})(MeasuringFrequency || (MeasuringFrequency = {}));\nconst defaultValue = /*#__PURE__*/ new Map();\nfunction useDroppableMeasuring(containers, _ref) {\n    let { dragging, dependencies, config } = _ref;\n    const [queue, setQueue] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const { frequency, measure, strategy } = config;\n    const containersRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(containers);\n    const disabled = isDisabled();\n    const disabledRef = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLatestValue)(disabled);\n    const measureDroppableContainers = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(ids) {\n        if (ids === void 0) {\n            ids = [];\n        }\n        if (disabledRef.current) {\n            return;\n        }\n        setQueue((value)=>{\n            if (value === null) {\n                return ids;\n            }\n            return value.concat(ids.filter((id)=>!value.includes(id)));\n        });\n    }, [\n        disabledRef\n    ]);\n    const timeoutId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const droppableRects = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLazyMemo)((previousValue)=>{\n        if (disabled && !dragging) {\n            return defaultValue;\n        }\n        if (!previousValue || previousValue === defaultValue || containersRef.current !== containers || queue != null) {\n            const map = new Map();\n            for (let container of containers){\n                if (!container) {\n                    continue;\n                }\n                if (queue && queue.length > 0 && !queue.includes(container.id) && container.rect.current) {\n                    // This container does not need to be re-measured\n                    map.set(container.id, container.rect.current);\n                    continue;\n                }\n                const node = container.node.current;\n                const rect = node ? new Rect(measure(node), node) : null;\n                container.rect.current = rect;\n                if (rect) {\n                    map.set(container.id, rect);\n                }\n            }\n            return map;\n        }\n        return previousValue;\n    }, [\n        containers,\n        queue,\n        dragging,\n        disabled,\n        measure\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        containersRef.current = containers;\n    }, [\n        containers\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (disabled) {\n            return;\n        }\n        measureDroppableContainers();\n    }, [\n        dragging,\n        disabled\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (queue && queue.length > 0) {\n            setQueue(null);\n        }\n    }, [\n        JSON.stringify(queue)\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (disabled || typeof frequency !== \"number\" || timeoutId.current !== null) {\n            return;\n        }\n        timeoutId.current = setTimeout(()=>{\n            measureDroppableContainers();\n            timeoutId.current = null;\n        }, frequency);\n    }, [\n        frequency,\n        disabled,\n        measureDroppableContainers,\n        ...dependencies\n    ]);\n    return {\n        droppableRects,\n        measureDroppableContainers,\n        measuringScheduled: queue != null\n    };\n    function isDisabled() {\n        switch(strategy){\n            case MeasuringStrategy.Always:\n                return false;\n            case MeasuringStrategy.BeforeDragging:\n                return dragging;\n            default:\n                return !dragging;\n        }\n    }\n}\nfunction useInitialValue(value, computeFn) {\n    return (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLazyMemo)((previousValue)=>{\n        if (!value) {\n            return null;\n        }\n        if (previousValue) {\n            return previousValue;\n        }\n        return typeof computeFn === \"function\" ? computeFn(value) : value;\n    }, [\n        computeFn,\n        value\n    ]);\n}\nfunction useInitialRect(node, measure) {\n    return useInitialValue(node, measure);\n}\n/**\r\n * Returns a new MutationObserver instance.\r\n * If `MutationObserver` is undefined in the execution environment, returns `undefined`.\r\n */ function useMutationObserver(_ref) {\n    let { callback, disabled } = _ref;\n    const handleMutations = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useEvent)(callback);\n    const mutationObserver = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (disabled || \"undefined\" === \"undefined\" || 0) {\n            return undefined;\n        }\n        const { MutationObserver } = window;\n        return new MutationObserver(handleMutations);\n    }, [\n        handleMutations,\n        disabled\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>mutationObserver == null ? void 0 : mutationObserver.disconnect();\n    }, [\n        mutationObserver\n    ]);\n    return mutationObserver;\n}\n/**\r\n * Returns a new ResizeObserver instance bound to the `onResize` callback.\r\n * If `ResizeObserver` is undefined in the execution environment, returns `undefined`.\r\n */ function useResizeObserver(_ref) {\n    let { callback, disabled } = _ref;\n    const handleResize = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useEvent)(callback);\n    const resizeObserver = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (disabled || \"undefined\" === \"undefined\" || 0) {\n            return undefined;\n        }\n        const { ResizeObserver } = window;\n        return new ResizeObserver(handleResize);\n    }, [\n        disabled\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>resizeObserver == null ? void 0 : resizeObserver.disconnect();\n    }, [\n        resizeObserver\n    ]);\n    return resizeObserver;\n}\nfunction defaultMeasure(element) {\n    return new Rect(getClientRect(element), element);\n}\nfunction useRect(element, measure, fallbackRect) {\n    if (measure === void 0) {\n        measure = defaultMeasure;\n    }\n    const [rect, measureRect] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(reducer, null);\n    const mutationObserver = useMutationObserver({\n        callback (records) {\n            if (!element) {\n                return;\n            }\n            for (const record of records){\n                const { type, target } = record;\n                if (type === \"childList\" && target instanceof HTMLElement && target.contains(element)) {\n                    measureRect();\n                    break;\n                }\n            }\n        }\n    });\n    const resizeObserver = useResizeObserver({\n        callback: measureRect\n    });\n    (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        measureRect();\n        if (element) {\n            resizeObserver == null ? void 0 : resizeObserver.observe(element);\n            mutationObserver == null ? void 0 : mutationObserver.observe(document.body, {\n                childList: true,\n                subtree: true\n            });\n        } else {\n            resizeObserver == null ? void 0 : resizeObserver.disconnect();\n            mutationObserver == null ? void 0 : mutationObserver.disconnect();\n        }\n    }, [\n        element\n    ]);\n    return rect;\n    function reducer(currentRect) {\n        if (!element) {\n            return null;\n        }\n        if (element.isConnected === false) {\n            var _ref;\n            // Fall back to last rect we measured if the element is\n            // no longer connected to the DOM.\n            return (_ref = currentRect != null ? currentRect : fallbackRect) != null ? _ref : null;\n        }\n        const newRect = measure(element);\n        if (JSON.stringify(currentRect) === JSON.stringify(newRect)) {\n            return currentRect;\n        }\n        return newRect;\n    }\n}\nfunction useRectDelta(rect) {\n    const initialRect = useInitialValue(rect);\n    return getRectDelta(rect, initialRect);\n}\nconst defaultValue$1 = [];\nfunction useScrollableAncestors(node) {\n    const previousNode = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(node);\n    const ancestors = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLazyMemo)((previousValue)=>{\n        if (!node) {\n            return defaultValue$1;\n        }\n        if (previousValue && previousValue !== defaultValue$1 && node && previousNode.current && node.parentNode === previousNode.current.parentNode) {\n            return previousValue;\n        }\n        return getScrollableAncestors(node);\n    }, [\n        node\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        previousNode.current = node;\n    }, [\n        node\n    ]);\n    return ancestors;\n}\nfunction useScrollOffsets(elements) {\n    const [scrollCoordinates, setScrollCoordinates] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const prevElements = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(elements); // To-do: Throttle the handleScroll callback\n    const handleScroll = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        const scrollingElement = getScrollableElement(event.target);\n        if (!scrollingElement) {\n            return;\n        }\n        setScrollCoordinates((scrollCoordinates)=>{\n            if (!scrollCoordinates) {\n                return null;\n            }\n            scrollCoordinates.set(scrollingElement, getScrollCoordinates(scrollingElement));\n            return new Map(scrollCoordinates);\n        });\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const previousElements = prevElements.current;\n        if (elements !== previousElements) {\n            cleanup(previousElements);\n            const entries = elements.map((element)=>{\n                const scrollableElement = getScrollableElement(element);\n                if (scrollableElement) {\n                    scrollableElement.addEventListener(\"scroll\", handleScroll, {\n                        passive: true\n                    });\n                    return [\n                        scrollableElement,\n                        getScrollCoordinates(scrollableElement)\n                    ];\n                }\n                return null;\n            }).filter((entry)=>entry != null);\n            setScrollCoordinates(entries.length ? new Map(entries) : null);\n            prevElements.current = elements;\n        }\n        return ()=>{\n            cleanup(elements);\n            cleanup(previousElements);\n        };\n        function cleanup(elements) {\n            elements.forEach((element)=>{\n                const scrollableElement = getScrollableElement(element);\n                scrollableElement == null ? void 0 : scrollableElement.removeEventListener(\"scroll\", handleScroll);\n            });\n        }\n    }, [\n        handleScroll,\n        elements\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (elements.length) {\n            return scrollCoordinates ? Array.from(scrollCoordinates.values()).reduce((acc, coordinates)=>(0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.add)(acc, coordinates), defaultCoordinates) : getScrollOffsets(elements);\n        }\n        return defaultCoordinates;\n    }, [\n        elements,\n        scrollCoordinates\n    ]);\n}\nfunction useScrollOffsetsDelta(scrollOffsets, dependencies) {\n    if (dependencies === void 0) {\n        dependencies = [];\n    }\n    const initialScrollOffsets = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        initialScrollOffsets.current = null;\n    }, dependencies);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const hasScrollOffsets = scrollOffsets !== defaultCoordinates;\n        if (hasScrollOffsets && !initialScrollOffsets.current) {\n            initialScrollOffsets.current = scrollOffsets;\n        }\n        if (!hasScrollOffsets && initialScrollOffsets.current) {\n            initialScrollOffsets.current = null;\n        }\n    }, [\n        scrollOffsets\n    ]);\n    return initialScrollOffsets.current ? (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.subtract)(scrollOffsets, initialScrollOffsets.current) : defaultCoordinates;\n}\nfunction useSensorSetup(sensors) {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.canUseDOM) {\n            return;\n        }\n        const teardownFns = sensors.map((_ref)=>{\n            let { sensor } = _ref;\n            return sensor.setup == null ? void 0 : sensor.setup();\n        });\n        return ()=>{\n            for (const teardown of teardownFns){\n                teardown == null ? void 0 : teardown();\n            }\n        };\n    }, // eslint-disable-next-line react-hooks/exhaustive-deps\n    sensors.map((_ref2)=>{\n        let { sensor } = _ref2;\n        return sensor;\n    }));\n}\nfunction useSyntheticListeners(listeners, id) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return listeners.reduce((acc, _ref)=>{\n            let { eventName, handler } = _ref;\n            acc[eventName] = (event)=>{\n                handler(event, id);\n            };\n            return acc;\n        }, {});\n    }, [\n        listeners,\n        id\n    ]);\n}\nfunction useWindowRect(element) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>element ? getWindowClientRect(element) : null, [\n        element\n    ]);\n}\nconst defaultValue$2 = [];\nfunction useRects(elements, measure) {\n    if (measure === void 0) {\n        measure = getClientRect;\n    }\n    const [firstElement] = elements;\n    const windowRect = useWindowRect(firstElement ? (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(firstElement) : null);\n    const [rects, measureRects] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(reducer, defaultValue$2);\n    const resizeObserver = useResizeObserver({\n        callback: measureRects\n    });\n    if (elements.length > 0 && rects === defaultValue$2) {\n        measureRects();\n    }\n    (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        if (elements.length) {\n            elements.forEach((element)=>resizeObserver == null ? void 0 : resizeObserver.observe(element));\n        } else {\n            resizeObserver == null ? void 0 : resizeObserver.disconnect();\n            measureRects();\n        }\n    }, [\n        elements\n    ]);\n    return rects;\n    function reducer() {\n        if (!elements.length) {\n            return defaultValue$2;\n        }\n        return elements.map((element)=>isDocumentScrollingElement(element) ? windowRect : new Rect(measure(element), element));\n    }\n}\nfunction getMeasurableNode(node) {\n    if (!node) {\n        return null;\n    }\n    if (node.children.length > 1) {\n        return node;\n    }\n    const firstChild = node.children[0];\n    return (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isHTMLElement)(firstChild) ? firstChild : node;\n}\nfunction useDragOverlayMeasuring(_ref) {\n    let { measure } = _ref;\n    const [rect, setRect] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const handleResize = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((entries)=>{\n        for (const { target } of entries){\n            if ((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isHTMLElement)(target)) {\n                setRect((rect)=>{\n                    const newRect = measure(target);\n                    return rect ? {\n                        ...rect,\n                        width: newRect.width,\n                        height: newRect.height\n                    } : newRect;\n                });\n                break;\n            }\n        }\n    }, [\n        measure\n    ]);\n    const resizeObserver = useResizeObserver({\n        callback: handleResize\n    });\n    const handleNodeChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((element)=>{\n        const node = getMeasurableNode(element);\n        resizeObserver == null ? void 0 : resizeObserver.disconnect();\n        if (node) {\n            resizeObserver == null ? void 0 : resizeObserver.observe(node);\n        }\n        setRect(node ? measure(node) : null);\n    }, [\n        measure,\n        resizeObserver\n    ]);\n    const [nodeRef, setRef] = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useNodeRef)(handleNodeChange);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            nodeRef,\n            rect,\n            setRef\n        }), [\n        rect,\n        nodeRef,\n        setRef\n    ]);\n}\nconst defaultSensors = [\n    {\n        sensor: PointerSensor,\n        options: {}\n    },\n    {\n        sensor: KeyboardSensor,\n        options: {}\n    }\n];\nconst defaultData = {\n    current: {}\n};\nconst defaultMeasuringConfiguration = {\n    draggable: {\n        measure: getTransformAgnosticClientRect\n    },\n    droppable: {\n        measure: getTransformAgnosticClientRect,\n        strategy: MeasuringStrategy.WhileDragging,\n        frequency: MeasuringFrequency.Optimized\n    },\n    dragOverlay: {\n        measure: getClientRect\n    }\n};\nclass DroppableContainersMap extends Map {\n    get(id) {\n        var _super$get;\n        return id != null ? (_super$get = super.get(id)) != null ? _super$get : undefined : undefined;\n    }\n    toArray() {\n        return Array.from(this.values());\n    }\n    getEnabled() {\n        return this.toArray().filter((_ref)=>{\n            let { disabled } = _ref;\n            return !disabled;\n        });\n    }\n    getNodeFor(id) {\n        var _this$get$node$curren, _this$get;\n        return (_this$get$node$curren = (_this$get = this.get(id)) == null ? void 0 : _this$get.node.current) != null ? _this$get$node$curren : undefined;\n    }\n}\nconst defaultPublicContext = {\n    activatorEvent: null,\n    active: null,\n    activeNode: null,\n    activeNodeRect: null,\n    collisions: null,\n    containerNodeRect: null,\n    draggableNodes: /*#__PURE__*/ new Map(),\n    droppableRects: /*#__PURE__*/ new Map(),\n    droppableContainers: /*#__PURE__*/ new DroppableContainersMap(),\n    over: null,\n    dragOverlay: {\n        nodeRef: {\n            current: null\n        },\n        rect: null,\n        setRef: noop\n    },\n    scrollableAncestors: [],\n    scrollableAncestorRects: [],\n    measuringConfiguration: defaultMeasuringConfiguration,\n    measureDroppableContainers: noop,\n    windowRect: null,\n    measuringScheduled: false\n};\nconst defaultInternalContext = {\n    activatorEvent: null,\n    activators: [],\n    active: null,\n    activeNodeRect: null,\n    ariaDescribedById: {\n        draggable: \"\"\n    },\n    dispatch: noop,\n    draggableNodes: /*#__PURE__*/ new Map(),\n    over: null,\n    measureDroppableContainers: noop\n};\nconst InternalContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(defaultInternalContext);\nconst PublicContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(defaultPublicContext);\nfunction getInitialState() {\n    return {\n        draggable: {\n            active: null,\n            initialCoordinates: {\n                x: 0,\n                y: 0\n            },\n            nodes: new Map(),\n            translate: {\n                x: 0,\n                y: 0\n            }\n        },\n        droppable: {\n            containers: new DroppableContainersMap()\n        }\n    };\n}\nfunction reducer(state, action) {\n    switch(action.type){\n        case Action.DragStart:\n            return {\n                ...state,\n                draggable: {\n                    ...state.draggable,\n                    initialCoordinates: action.initialCoordinates,\n                    active: action.active\n                }\n            };\n        case Action.DragMove:\n            if (!state.draggable.active) {\n                return state;\n            }\n            return {\n                ...state,\n                draggable: {\n                    ...state.draggable,\n                    translate: {\n                        x: action.coordinates.x - state.draggable.initialCoordinates.x,\n                        y: action.coordinates.y - state.draggable.initialCoordinates.y\n                    }\n                }\n            };\n        case Action.DragEnd:\n        case Action.DragCancel:\n            return {\n                ...state,\n                draggable: {\n                    ...state.draggable,\n                    active: null,\n                    initialCoordinates: {\n                        x: 0,\n                        y: 0\n                    },\n                    translate: {\n                        x: 0,\n                        y: 0\n                    }\n                }\n            };\n        case Action.RegisterDroppable:\n            {\n                const { element } = action;\n                const { id } = element;\n                const containers = new DroppableContainersMap(state.droppable.containers);\n                containers.set(id, element);\n                return {\n                    ...state,\n                    droppable: {\n                        ...state.droppable,\n                        containers\n                    }\n                };\n            }\n        case Action.SetDroppableDisabled:\n            {\n                const { id, key, disabled } = action;\n                const element = state.droppable.containers.get(id);\n                if (!element || key !== element.key) {\n                    return state;\n                }\n                const containers = new DroppableContainersMap(state.droppable.containers);\n                containers.set(id, {\n                    ...element,\n                    disabled\n                });\n                return {\n                    ...state,\n                    droppable: {\n                        ...state.droppable,\n                        containers\n                    }\n                };\n            }\n        case Action.UnregisterDroppable:\n            {\n                const { id, key } = action;\n                const element = state.droppable.containers.get(id);\n                if (!element || key !== element.key) {\n                    return state;\n                }\n                const containers = new DroppableContainersMap(state.droppable.containers);\n                containers.delete(id);\n                return {\n                    ...state,\n                    droppable: {\n                        ...state.droppable,\n                        containers\n                    }\n                };\n            }\n        default:\n            {\n                return state;\n            }\n    }\n}\nfunction RestoreFocus(_ref) {\n    let { disabled } = _ref;\n    const { active, activatorEvent, draggableNodes } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(InternalContext);\n    const previousActivatorEvent = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.usePrevious)(activatorEvent);\n    const previousActiveId = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.usePrevious)(active == null ? void 0 : active.id); // Restore keyboard focus on the activator node\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (disabled) {\n            return;\n        }\n        if (!activatorEvent && previousActivatorEvent && previousActiveId != null) {\n            if (!(0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isKeyboardEvent)(previousActivatorEvent)) {\n                return;\n            }\n            if (document.activeElement === previousActivatorEvent.target) {\n                // No need to restore focus\n                return;\n            }\n            const draggableNode = draggableNodes.get(previousActiveId);\n            if (!draggableNode) {\n                return;\n            }\n            const { activatorNode, node } = draggableNode;\n            if (!activatorNode.current && !node.current) {\n                return;\n            }\n            requestAnimationFrame(()=>{\n                for (const element of [\n                    activatorNode.current,\n                    node.current\n                ]){\n                    if (!element) {\n                        continue;\n                    }\n                    const focusableNode = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.findFirstFocusableNode)(element);\n                    if (focusableNode) {\n                        focusableNode.focus();\n                        break;\n                    }\n                }\n            });\n        }\n    }, [\n        activatorEvent,\n        disabled,\n        draggableNodes,\n        previousActiveId,\n        previousActivatorEvent\n    ]);\n    return null;\n}\nfunction applyModifiers(modifiers, _ref) {\n    let { transform, ...args } = _ref;\n    return modifiers != null && modifiers.length ? modifiers.reduce((accumulator, modifier)=>{\n        return modifier({\n            transform: accumulator,\n            ...args\n        });\n    }, transform) : transform;\n}\nfunction useMeasuringConfiguration(config) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            draggable: {\n                ...defaultMeasuringConfiguration.draggable,\n                ...config == null ? void 0 : config.draggable\n            },\n            droppable: {\n                ...defaultMeasuringConfiguration.droppable,\n                ...config == null ? void 0 : config.droppable\n            },\n            dragOverlay: {\n                ...defaultMeasuringConfiguration.dragOverlay,\n                ...config == null ? void 0 : config.dragOverlay\n            }\n        }), [\n        config == null ? void 0 : config.draggable,\n        config == null ? void 0 : config.droppable,\n        config == null ? void 0 : config.dragOverlay\n    ]);\n}\nfunction useLayoutShiftScrollCompensation(_ref) {\n    let { activeNode, measure, initialRect, config = true } = _ref;\n    const initialized = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const { x, y } = typeof config === \"boolean\" ? {\n        x: config,\n        y: config\n    } : config;\n    (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        const disabled = !x && !y;\n        if (disabled || !activeNode) {\n            initialized.current = false;\n            return;\n        }\n        if (initialized.current || !initialRect) {\n            // Return early if layout shift scroll compensation was already attempted\n            // or if there is no initialRect to compare to.\n            return;\n        } // Get the most up to date node ref for the active draggable\n        const node = activeNode == null ? void 0 : activeNode.node.current;\n        if (!node || node.isConnected === false) {\n            // Return early if there is no attached node ref or if the node is\n            // disconnected from the document.\n            return;\n        }\n        const rect = measure(node);\n        const rectDelta = getRectDelta(rect, initialRect);\n        if (!x) {\n            rectDelta.x = 0;\n        }\n        if (!y) {\n            rectDelta.y = 0;\n        } // Only perform layout shift scroll compensation once\n        initialized.current = true;\n        if (Math.abs(rectDelta.x) > 0 || Math.abs(rectDelta.y) > 0) {\n            const firstScrollableAncestor = getFirstScrollableAncestor(node);\n            if (firstScrollableAncestor) {\n                firstScrollableAncestor.scrollBy({\n                    top: rectDelta.y,\n                    left: rectDelta.x\n                });\n            }\n        }\n    }, [\n        activeNode,\n        x,\n        y,\n        initialRect,\n        measure\n    ]);\n}\nconst ActiveDraggableContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    ...defaultCoordinates,\n    scaleX: 1,\n    scaleY: 1\n});\nvar Status;\n(function(Status) {\n    Status[Status[\"Uninitialized\"] = 0] = \"Uninitialized\";\n    Status[Status[\"Initializing\"] = 1] = \"Initializing\";\n    Status[Status[\"Initialized\"] = 2] = \"Initialized\";\n})(Status || (Status = {}));\nconst DndContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(function DndContext(_ref) {\n    var _sensorContext$curren, _dragOverlay$nodeRef$, _dragOverlay$rect, _over$rect;\n    let { id, accessibility, autoScroll = true, children, sensors = defaultSensors, collisionDetection = rectIntersection, measuring, modifiers, ...props } = _ref;\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(reducer, undefined, getInitialState);\n    const [state, dispatch] = store;\n    const [dispatchMonitorEvent, registerMonitorListener] = useDndMonitorProvider();\n    const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(Status.Uninitialized);\n    const isInitialized = status === Status.Initialized;\n    const { draggable: { active: activeId, nodes: draggableNodes, translate }, droppable: { containers: droppableContainers } } = state;\n    const node = activeId ? draggableNodes.get(activeId) : null;\n    const activeRects = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        initial: null,\n        translated: null\n    });\n    const active = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        var _node$data;\n        return activeId != null ? {\n            id: activeId,\n            // It's possible for the active node to unmount while dragging\n            data: (_node$data = node == null ? void 0 : node.data) != null ? _node$data : defaultData,\n            rect: activeRects\n        } : null;\n    }, [\n        activeId,\n        node\n    ]);\n    const activeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [activeSensor, setActiveSensor] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [activatorEvent, setActivatorEvent] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const latestProps = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLatestValue)(props, Object.values(props));\n    const draggableDescribedById = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useUniqueId)(\"DndDescribedBy\", id);\n    const enabledDroppableContainers = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>droppableContainers.getEnabled(), [\n        droppableContainers\n    ]);\n    const measuringConfiguration = useMeasuringConfiguration(measuring);\n    const { droppableRects, measureDroppableContainers, measuringScheduled } = useDroppableMeasuring(enabledDroppableContainers, {\n        dragging: isInitialized,\n        dependencies: [\n            translate.x,\n            translate.y\n        ],\n        config: measuringConfiguration.droppable\n    });\n    const activeNode = useCachedNode(draggableNodes, activeId);\n    const activationCoordinates = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>activatorEvent ? (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getEventCoordinates)(activatorEvent) : null, [\n        activatorEvent\n    ]);\n    const autoScrollOptions = getAutoScrollerOptions();\n    const initialActiveNodeRect = useInitialRect(activeNode, measuringConfiguration.draggable.measure);\n    useLayoutShiftScrollCompensation({\n        activeNode: activeId ? draggableNodes.get(activeId) : null,\n        config: autoScrollOptions.layoutShiftCompensation,\n        initialRect: initialActiveNodeRect,\n        measure: measuringConfiguration.draggable.measure\n    });\n    const activeNodeRect = useRect(activeNode, measuringConfiguration.draggable.measure, initialActiveNodeRect);\n    const containerNodeRect = useRect(activeNode ? activeNode.parentElement : null);\n    const sensorContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        activatorEvent: null,\n        active: null,\n        activeNode,\n        collisionRect: null,\n        collisions: null,\n        droppableRects,\n        draggableNodes,\n        draggingNode: null,\n        draggingNodeRect: null,\n        droppableContainers,\n        over: null,\n        scrollableAncestors: [],\n        scrollAdjustedTranslate: null\n    });\n    const overNode = droppableContainers.getNodeFor((_sensorContext$curren = sensorContext.current.over) == null ? void 0 : _sensorContext$curren.id);\n    const dragOverlay = useDragOverlayMeasuring({\n        measure: measuringConfiguration.dragOverlay.measure\n    }); // Use the rect of the drag overlay if it is mounted\n    const draggingNode = (_dragOverlay$nodeRef$ = dragOverlay.nodeRef.current) != null ? _dragOverlay$nodeRef$ : activeNode;\n    const draggingNodeRect = isInitialized ? (_dragOverlay$rect = dragOverlay.rect) != null ? _dragOverlay$rect : activeNodeRect : null;\n    const usesDragOverlay = Boolean(dragOverlay.nodeRef.current && dragOverlay.rect); // The delta between the previous and new position of the draggable node\n    // is only relevant when there is no drag overlay\n    const nodeRectDelta = useRectDelta(usesDragOverlay ? null : activeNodeRect); // Get the window rect of the dragging node\n    const windowRect = useWindowRect(draggingNode ? (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(draggingNode) : null); // Get scrollable ancestors of the dragging node\n    const scrollableAncestors = useScrollableAncestors(isInitialized ? overNode != null ? overNode : activeNode : null);\n    const scrollableAncestorRects = useRects(scrollableAncestors); // Apply modifiers\n    const modifiedTranslate = applyModifiers(modifiers, {\n        transform: {\n            x: translate.x - nodeRectDelta.x,\n            y: translate.y - nodeRectDelta.y,\n            scaleX: 1,\n            scaleY: 1\n        },\n        activatorEvent,\n        active,\n        activeNodeRect,\n        containerNodeRect,\n        draggingNodeRect,\n        over: sensorContext.current.over,\n        overlayNodeRect: dragOverlay.rect,\n        scrollableAncestors,\n        scrollableAncestorRects,\n        windowRect\n    });\n    const pointerCoordinates = activationCoordinates ? (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.add)(activationCoordinates, translate) : null;\n    const scrollOffsets = useScrollOffsets(scrollableAncestors); // Represents the scroll delta since dragging was initiated\n    const scrollAdjustment = useScrollOffsetsDelta(scrollOffsets); // Represents the scroll delta since the last time the active node rect was measured\n    const activeNodeScrollDelta = useScrollOffsetsDelta(scrollOffsets, [\n        activeNodeRect\n    ]);\n    const scrollAdjustedTranslate = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.add)(modifiedTranslate, scrollAdjustment);\n    const collisionRect = draggingNodeRect ? getAdjustedRect(draggingNodeRect, modifiedTranslate) : null;\n    const collisions = active && collisionRect ? collisionDetection({\n        active,\n        collisionRect,\n        droppableRects,\n        droppableContainers: enabledDroppableContainers,\n        pointerCoordinates\n    }) : null;\n    const overId = getFirstCollision(collisions, \"id\");\n    const [over, setOver] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null); // When there is no drag overlay used, we need to account for the\n    // window scroll delta\n    const appliedTranslate = usesDragOverlay ? modifiedTranslate : (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.add)(modifiedTranslate, activeNodeScrollDelta);\n    const transform = adjustScale(appliedTranslate, (_over$rect = over == null ? void 0 : over.rect) != null ? _over$rect : null, activeNodeRect);\n    const instantiateSensor = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event, _ref2)=>{\n        let { sensor: Sensor, options } = _ref2;\n        if (activeRef.current == null) {\n            return;\n        }\n        const activeNode = draggableNodes.get(activeRef.current);\n        if (!activeNode) {\n            return;\n        }\n        const activatorEvent = event.nativeEvent;\n        const sensorInstance = new Sensor({\n            active: activeRef.current,\n            activeNode,\n            event: activatorEvent,\n            options,\n            // Sensors need to be instantiated with refs for arguments that change over time\n            // otherwise they are frozen in time with the stale arguments\n            context: sensorContext,\n            onStart (initialCoordinates) {\n                const id = activeRef.current;\n                if (id == null) {\n                    return;\n                }\n                const draggableNode = draggableNodes.get(id);\n                if (!draggableNode) {\n                    return;\n                }\n                const { onDragStart } = latestProps.current;\n                const event = {\n                    active: {\n                        id,\n                        data: draggableNode.data,\n                        rect: activeRects\n                    }\n                };\n                (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.unstable_batchedUpdates)(()=>{\n                    onDragStart == null ? void 0 : onDragStart(event);\n                    setStatus(Status.Initializing);\n                    dispatch({\n                        type: Action.DragStart,\n                        initialCoordinates,\n                        active: id\n                    });\n                    dispatchMonitorEvent({\n                        type: \"onDragStart\",\n                        event\n                    });\n                });\n            },\n            onMove (coordinates) {\n                dispatch({\n                    type: Action.DragMove,\n                    coordinates\n                });\n            },\n            onEnd: createHandler(Action.DragEnd),\n            onCancel: createHandler(Action.DragCancel)\n        });\n        (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.unstable_batchedUpdates)(()=>{\n            setActiveSensor(sensorInstance);\n            setActivatorEvent(event.nativeEvent);\n        });\n        function createHandler(type) {\n            return async function handler() {\n                const { active, collisions, over, scrollAdjustedTranslate } = sensorContext.current;\n                let event = null;\n                if (active && scrollAdjustedTranslate) {\n                    const { cancelDrop } = latestProps.current;\n                    event = {\n                        activatorEvent,\n                        active: active,\n                        collisions,\n                        delta: scrollAdjustedTranslate,\n                        over\n                    };\n                    if (type === Action.DragEnd && typeof cancelDrop === \"function\") {\n                        const shouldCancel = await Promise.resolve(cancelDrop(event));\n                        if (shouldCancel) {\n                            type = Action.DragCancel;\n                        }\n                    }\n                }\n                activeRef.current = null;\n                (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.unstable_batchedUpdates)(()=>{\n                    dispatch({\n                        type\n                    });\n                    setStatus(Status.Uninitialized);\n                    setOver(null);\n                    setActiveSensor(null);\n                    setActivatorEvent(null);\n                    const eventName = type === Action.DragEnd ? \"onDragEnd\" : \"onDragCancel\";\n                    if (event) {\n                        const handler = latestProps.current[eventName];\n                        handler == null ? void 0 : handler(event);\n                        dispatchMonitorEvent({\n                            type: eventName,\n                            event\n                        });\n                    }\n                });\n            };\n        }\n    }, [\n        draggableNodes\n    ]);\n    const bindActivatorToSensorInstantiator = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((handler, sensor)=>{\n        return (event, active)=>{\n            const nativeEvent = event.nativeEvent;\n            const activeDraggableNode = draggableNodes.get(active);\n            if (activeRef.current !== null || // No active draggable\n            !activeDraggableNode || // Event has already been captured\n            nativeEvent.dndKit || nativeEvent.defaultPrevented) {\n                return;\n            }\n            const activationContext = {\n                active: activeDraggableNode\n            };\n            const shouldActivate = handler(event, sensor.options, activationContext);\n            if (shouldActivate === true) {\n                nativeEvent.dndKit = {\n                    capturedBy: sensor.sensor\n                };\n                activeRef.current = active;\n                instantiateSensor(event, sensor);\n            }\n        };\n    }, [\n        draggableNodes,\n        instantiateSensor\n    ]);\n    const activators = useCombineActivators(sensors, bindActivatorToSensorInstantiator);\n    useSensorSetup(sensors);\n    (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        if (activeNodeRect && status === Status.Initializing) {\n            setStatus(Status.Initialized);\n        }\n    }, [\n        activeNodeRect,\n        status\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const { onDragMove } = latestProps.current;\n        const { active, activatorEvent, collisions, over } = sensorContext.current;\n        if (!active || !activatorEvent) {\n            return;\n        }\n        const event = {\n            active,\n            activatorEvent,\n            collisions,\n            delta: {\n                x: scrollAdjustedTranslate.x,\n                y: scrollAdjustedTranslate.y\n            },\n            over\n        };\n        (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.unstable_batchedUpdates)(()=>{\n            onDragMove == null ? void 0 : onDragMove(event);\n            dispatchMonitorEvent({\n                type: \"onDragMove\",\n                event\n            });\n        });\n    }, [\n        scrollAdjustedTranslate.x,\n        scrollAdjustedTranslate.y\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const { active, activatorEvent, collisions, droppableContainers, scrollAdjustedTranslate } = sensorContext.current;\n        if (!active || activeRef.current == null || !activatorEvent || !scrollAdjustedTranslate) {\n            return;\n        }\n        const { onDragOver } = latestProps.current;\n        const overContainer = droppableContainers.get(overId);\n        const over = overContainer && overContainer.rect.current ? {\n            id: overContainer.id,\n            rect: overContainer.rect.current,\n            data: overContainer.data,\n            disabled: overContainer.disabled\n        } : null;\n        const event = {\n            active,\n            activatorEvent,\n            collisions,\n            delta: {\n                x: scrollAdjustedTranslate.x,\n                y: scrollAdjustedTranslate.y\n            },\n            over\n        };\n        (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.unstable_batchedUpdates)(()=>{\n            setOver(over);\n            onDragOver == null ? void 0 : onDragOver(event);\n            dispatchMonitorEvent({\n                type: \"onDragOver\",\n                event\n            });\n        });\n    }, [\n        overId\n    ]);\n    (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        sensorContext.current = {\n            activatorEvent,\n            active,\n            activeNode,\n            collisionRect,\n            collisions,\n            droppableRects,\n            draggableNodes,\n            draggingNode,\n            draggingNodeRect,\n            droppableContainers,\n            over,\n            scrollableAncestors,\n            scrollAdjustedTranslate\n        };\n        activeRects.current = {\n            initial: draggingNodeRect,\n            translated: collisionRect\n        };\n    }, [\n        active,\n        activeNode,\n        collisions,\n        collisionRect,\n        draggableNodes,\n        draggingNode,\n        draggingNodeRect,\n        droppableRects,\n        droppableContainers,\n        over,\n        scrollableAncestors,\n        scrollAdjustedTranslate\n    ]);\n    useAutoScroller({\n        ...autoScrollOptions,\n        delta: translate,\n        draggingRect: collisionRect,\n        pointerCoordinates,\n        scrollableAncestors,\n        scrollableAncestorRects\n    });\n    const publicContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const context = {\n            active,\n            activeNode,\n            activeNodeRect,\n            activatorEvent,\n            collisions,\n            containerNodeRect,\n            dragOverlay,\n            draggableNodes,\n            droppableContainers,\n            droppableRects,\n            over,\n            measureDroppableContainers,\n            scrollableAncestors,\n            scrollableAncestorRects,\n            measuringConfiguration,\n            measuringScheduled,\n            windowRect\n        };\n        return context;\n    }, [\n        active,\n        activeNode,\n        activeNodeRect,\n        activatorEvent,\n        collisions,\n        containerNodeRect,\n        dragOverlay,\n        draggableNodes,\n        droppableContainers,\n        droppableRects,\n        over,\n        measureDroppableContainers,\n        scrollableAncestors,\n        scrollableAncestorRects,\n        measuringConfiguration,\n        measuringScheduled,\n        windowRect\n    ]);\n    const internalContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const context = {\n            activatorEvent,\n            activators,\n            active,\n            activeNodeRect,\n            ariaDescribedById: {\n                draggable: draggableDescribedById\n            },\n            dispatch,\n            draggableNodes,\n            over,\n            measureDroppableContainers\n        };\n        return context;\n    }, [\n        activatorEvent,\n        activators,\n        active,\n        activeNodeRect,\n        dispatch,\n        draggableDescribedById,\n        draggableNodes,\n        over,\n        measureDroppableContainers\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(DndMonitorContext.Provider, {\n        value: registerMonitorListener\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(InternalContext.Provider, {\n        value: internalContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(PublicContext.Provider, {\n        value: publicContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ActiveDraggableContext.Provider, {\n        value: transform\n    }, children)), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(RestoreFocus, {\n        disabled: (accessibility == null ? void 0 : accessibility.restoreFocus) === false\n    })), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Accessibility, {\n        ...accessibility,\n        hiddenTextDescribedById: draggableDescribedById\n    }));\n    function getAutoScrollerOptions() {\n        const activeSensorDisablesAutoscroll = (activeSensor == null ? void 0 : activeSensor.autoScrollEnabled) === false;\n        const autoScrollGloballyDisabled = typeof autoScroll === \"object\" ? autoScroll.enabled === false : autoScroll === false;\n        const enabled = isInitialized && !activeSensorDisablesAutoscroll && !autoScrollGloballyDisabled;\n        if (typeof autoScroll === \"object\") {\n            return {\n                ...autoScroll,\n                enabled\n            };\n        }\n        return {\n            enabled\n        };\n    }\n});\nconst NullContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nconst defaultRole = \"button\";\nconst ID_PREFIX = \"Droppable\";\nfunction useDraggable(_ref) {\n    let { id, data, disabled = false, attributes } = _ref;\n    const key = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useUniqueId)(ID_PREFIX);\n    const { activators, activatorEvent, active, activeNodeRect, ariaDescribedById, draggableNodes, over } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(InternalContext);\n    const { role = defaultRole, roleDescription = \"draggable\", tabIndex = 0 } = attributes != null ? attributes : {};\n    const isDragging = (active == null ? void 0 : active.id) === id;\n    const transform = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(isDragging ? ActiveDraggableContext : NullContext);\n    const [node, setNodeRef] = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useNodeRef)();\n    const [activatorNode, setActivatorNodeRef] = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useNodeRef)();\n    const listeners = useSyntheticListeners(activators, id);\n    const dataRef = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLatestValue)(data);\n    (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        draggableNodes.set(id, {\n            id,\n            key,\n            node,\n            activatorNode,\n            data: dataRef\n        });\n        return ()=>{\n            const node = draggableNodes.get(id);\n            if (node && node.key === key) {\n                draggableNodes.delete(id);\n            }\n        };\n    }, [\n        draggableNodes,\n        id\n    ]);\n    const memoizedAttributes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            role,\n            tabIndex,\n            \"aria-disabled\": disabled,\n            \"aria-pressed\": isDragging && role === defaultRole ? true : undefined,\n            \"aria-roledescription\": roleDescription,\n            \"aria-describedby\": ariaDescribedById.draggable\n        }), [\n        disabled,\n        role,\n        tabIndex,\n        isDragging,\n        roleDescription,\n        ariaDescribedById.draggable\n    ]);\n    return {\n        active,\n        activatorEvent,\n        activeNodeRect,\n        attributes: memoizedAttributes,\n        isDragging,\n        listeners: disabled ? undefined : listeners,\n        node,\n        over,\n        setNodeRef,\n        setActivatorNodeRef,\n        transform\n    };\n}\nfunction useDndContext() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(PublicContext);\n}\nconst ID_PREFIX$1 = \"Droppable\";\nconst defaultResizeObserverConfig = {\n    timeout: 25\n};\nfunction useDroppable(_ref) {\n    let { data, disabled = false, id, resizeObserverConfig } = _ref;\n    const key = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useUniqueId)(ID_PREFIX$1);\n    const { active, dispatch, over, measureDroppableContainers } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(InternalContext);\n    const previous = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        disabled\n    });\n    const resizeObserverConnected = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const rect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const callbackId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const { disabled: resizeObserverDisabled, updateMeasurementsFor, timeout: resizeObserverTimeout } = {\n        ...defaultResizeObserverConfig,\n        ...resizeObserverConfig\n    };\n    const ids = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLatestValue)(updateMeasurementsFor != null ? updateMeasurementsFor : id);\n    const handleResize = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (!resizeObserverConnected.current) {\n            // ResizeObserver invokes the `handleResize` callback as soon as `observe` is called,\n            // assuming the element is rendered and displayed.\n            resizeObserverConnected.current = true;\n            return;\n        }\n        if (callbackId.current != null) {\n            clearTimeout(callbackId.current);\n        }\n        callbackId.current = setTimeout(()=>{\n            measureDroppableContainers(Array.isArray(ids.current) ? ids.current : [\n                ids.current\n            ]);\n            callbackId.current = null;\n        }, resizeObserverTimeout);\n    }, [\n        resizeObserverTimeout\n    ]);\n    const resizeObserver = useResizeObserver({\n        callback: handleResize,\n        disabled: resizeObserverDisabled || !active\n    });\n    const handleNodeChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((newElement, previousElement)=>{\n        if (!resizeObserver) {\n            return;\n        }\n        if (previousElement) {\n            resizeObserver.unobserve(previousElement);\n            resizeObserverConnected.current = false;\n        }\n        if (newElement) {\n            resizeObserver.observe(newElement);\n        }\n    }, [\n        resizeObserver\n    ]);\n    const [nodeRef, setNodeRef] = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useNodeRef)(handleNodeChange);\n    const dataRef = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLatestValue)(data);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!resizeObserver || !nodeRef.current) {\n            return;\n        }\n        resizeObserver.disconnect();\n        resizeObserverConnected.current = false;\n        resizeObserver.observe(nodeRef.current);\n    }, [\n        nodeRef,\n        resizeObserver\n    ]);\n    (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        dispatch({\n            type: Action.RegisterDroppable,\n            element: {\n                id,\n                key,\n                disabled,\n                node: nodeRef,\n                rect,\n                data: dataRef\n            }\n        });\n        return ()=>dispatch({\n                type: Action.UnregisterDroppable,\n                key,\n                id\n            });\n    }, [\n        id\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (disabled !== previous.current.disabled) {\n            dispatch({\n                type: Action.SetDroppableDisabled,\n                id,\n                key,\n                disabled\n            });\n            previous.current.disabled = disabled;\n        }\n    }, [\n        id,\n        key,\n        disabled,\n        dispatch\n    ]);\n    return {\n        active,\n        rect,\n        isOver: (over == null ? void 0 : over.id) === id,\n        node: nodeRef,\n        over,\n        setNodeRef\n    };\n}\nfunction AnimationManager(_ref) {\n    let { animation, children } = _ref;\n    const [clonedChildren, setClonedChildren] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [element, setElement] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const previousChildren = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.usePrevious)(children);\n    if (!children && !clonedChildren && previousChildren) {\n        setClonedChildren(previousChildren);\n    }\n    (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        if (!element) {\n            return;\n        }\n        const key = clonedChildren == null ? void 0 : clonedChildren.key;\n        const id = clonedChildren == null ? void 0 : clonedChildren.props.id;\n        if (key == null || id == null) {\n            setClonedChildren(null);\n            return;\n        }\n        Promise.resolve(animation(id, element)).then(()=>{\n            setClonedChildren(null);\n        });\n    }, [\n        animation,\n        clonedChildren,\n        element\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, children, clonedChildren ? /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(clonedChildren, {\n        ref: setElement\n    }) : null);\n}\nconst defaultTransform = {\n    x: 0,\n    y: 0,\n    scaleX: 1,\n    scaleY: 1\n};\nfunction NullifiedContextProvider(_ref) {\n    let { children } = _ref;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(InternalContext.Provider, {\n        value: defaultInternalContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ActiveDraggableContext.Provider, {\n        value: defaultTransform\n    }, children));\n}\nconst baseStyles = {\n    position: \"fixed\",\n    touchAction: \"none\"\n};\nconst defaultTransition = (activatorEvent)=>{\n    const isKeyboardActivator = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isKeyboardEvent)(activatorEvent);\n    return isKeyboardActivator ? \"transform 250ms ease\" : undefined;\n};\nconst PositionedOverlay = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((_ref, ref)=>{\n    let { as, activatorEvent, adjustScale, children, className, rect, style, transform, transition = defaultTransition } = _ref;\n    if (!rect) {\n        return null;\n    }\n    const scaleAdjustedTransform = adjustScale ? transform : {\n        ...transform,\n        scaleX: 1,\n        scaleY: 1\n    };\n    const styles = {\n        ...baseStyles,\n        width: rect.width,\n        height: rect.height,\n        top: rect.top,\n        left: rect.left,\n        transform: _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.CSS.Transform.toString(scaleAdjustedTransform),\n        transformOrigin: adjustScale && activatorEvent ? getRelativeTransformOrigin(activatorEvent, rect) : undefined,\n        transition: typeof transition === \"function\" ? transition(activatorEvent) : transition,\n        ...style\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(as, {\n        className,\n        style: styles,\n        ref\n    }, children);\n});\nconst defaultDropAnimationSideEffects = (options)=>(_ref)=>{\n        let { active, dragOverlay } = _ref;\n        const originalStyles = {};\n        const { styles, className } = options;\n        if (styles != null && styles.active) {\n            for (const [key, value] of Object.entries(styles.active)){\n                if (value === undefined) {\n                    continue;\n                }\n                originalStyles[key] = active.node.style.getPropertyValue(key);\n                active.node.style.setProperty(key, value);\n            }\n        }\n        if (styles != null && styles.dragOverlay) {\n            for (const [key, value] of Object.entries(styles.dragOverlay)){\n                if (value === undefined) {\n                    continue;\n                }\n                dragOverlay.node.style.setProperty(key, value);\n            }\n        }\n        if (className != null && className.active) {\n            active.node.classList.add(className.active);\n        }\n        if (className != null && className.dragOverlay) {\n            dragOverlay.node.classList.add(className.dragOverlay);\n        }\n        return function cleanup() {\n            for (const [key, value] of Object.entries(originalStyles)){\n                active.node.style.setProperty(key, value);\n            }\n            if (className != null && className.active) {\n                active.node.classList.remove(className.active);\n            }\n        };\n    };\nconst defaultKeyframeResolver = (_ref2)=>{\n    let { transform: { initial, final } } = _ref2;\n    return [\n        {\n            transform: _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.CSS.Transform.toString(initial)\n        },\n        {\n            transform: _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.CSS.Transform.toString(final)\n        }\n    ];\n};\nconst defaultDropAnimationConfiguration = {\n    duration: 250,\n    easing: \"ease\",\n    keyframes: defaultKeyframeResolver,\n    sideEffects: /*#__PURE__*/ defaultDropAnimationSideEffects({\n        styles: {\n            active: {\n                opacity: \"0\"\n            }\n        }\n    })\n};\nfunction useDropAnimation(_ref3) {\n    let { config, draggableNodes, droppableContainers, measuringConfiguration } = _ref3;\n    return (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useEvent)((id, node)=>{\n        if (config === null) {\n            return;\n        }\n        const activeDraggable = draggableNodes.get(id);\n        if (!activeDraggable) {\n            return;\n        }\n        const activeNode = activeDraggable.node.current;\n        if (!activeNode) {\n            return;\n        }\n        const measurableNode = getMeasurableNode(node);\n        if (!measurableNode) {\n            return;\n        }\n        const { transform } = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(node).getComputedStyle(node);\n        const parsedTransform = parseTransform(transform);\n        if (!parsedTransform) {\n            return;\n        }\n        const animation = typeof config === \"function\" ? config : createDefaultDropAnimation(config);\n        scrollIntoViewIfNeeded(activeNode, measuringConfiguration.draggable.measure);\n        return animation({\n            active: {\n                id,\n                data: activeDraggable.data,\n                node: activeNode,\n                rect: measuringConfiguration.draggable.measure(activeNode)\n            },\n            draggableNodes,\n            dragOverlay: {\n                node,\n                rect: measuringConfiguration.dragOverlay.measure(measurableNode)\n            },\n            droppableContainers,\n            measuringConfiguration,\n            transform: parsedTransform\n        });\n    });\n}\nfunction createDefaultDropAnimation(options) {\n    const { duration, easing, sideEffects, keyframes } = {\n        ...defaultDropAnimationConfiguration,\n        ...options\n    };\n    return (_ref4)=>{\n        let { active, dragOverlay, transform, ...rest } = _ref4;\n        if (!duration) {\n            // Do not animate if animation duration is zero.\n            return;\n        }\n        const delta = {\n            x: dragOverlay.rect.left - active.rect.left,\n            y: dragOverlay.rect.top - active.rect.top\n        };\n        const scale = {\n            scaleX: transform.scaleX !== 1 ? active.rect.width * transform.scaleX / dragOverlay.rect.width : 1,\n            scaleY: transform.scaleY !== 1 ? active.rect.height * transform.scaleY / dragOverlay.rect.height : 1\n        };\n        const finalTransform = {\n            x: transform.x - delta.x,\n            y: transform.y - delta.y,\n            ...scale\n        };\n        const animationKeyframes = keyframes({\n            ...rest,\n            active,\n            dragOverlay,\n            transform: {\n                initial: transform,\n                final: finalTransform\n            }\n        });\n        const [firstKeyframe] = animationKeyframes;\n        const lastKeyframe = animationKeyframes[animationKeyframes.length - 1];\n        if (JSON.stringify(firstKeyframe) === JSON.stringify(lastKeyframe)) {\n            // The start and end keyframes are the same, infer that there is no animation needed.\n            return;\n        }\n        const cleanup = sideEffects == null ? void 0 : sideEffects({\n            active,\n            dragOverlay,\n            ...rest\n        });\n        const animation = dragOverlay.node.animate(animationKeyframes, {\n            duration,\n            easing,\n            fill: \"forwards\"\n        });\n        return new Promise((resolve)=>{\n            animation.onfinish = ()=>{\n                cleanup == null ? void 0 : cleanup();\n                resolve();\n            };\n        });\n    };\n}\nlet key = 0;\nfunction useKey(id) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (id == null) {\n            return;\n        }\n        key++;\n        return key;\n    }, [\n        id\n    ]);\n}\nconst DragOverlay = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().memo((_ref)=>{\n    let { adjustScale = false, children, dropAnimation: dropAnimationConfig, style, transition, modifiers, wrapperElement = \"div\", className, zIndex = 999 } = _ref;\n    const { activatorEvent, active, activeNodeRect, containerNodeRect, draggableNodes, droppableContainers, dragOverlay, over, measuringConfiguration, scrollableAncestors, scrollableAncestorRects, windowRect } = useDndContext();\n    const transform = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ActiveDraggableContext);\n    const key = useKey(active == null ? void 0 : active.id);\n    const modifiedTransform = applyModifiers(modifiers, {\n        activatorEvent,\n        active,\n        activeNodeRect,\n        containerNodeRect,\n        draggingNodeRect: dragOverlay.rect,\n        over,\n        overlayNodeRect: dragOverlay.rect,\n        scrollableAncestors,\n        scrollableAncestorRects,\n        transform,\n        windowRect\n    });\n    const initialRect = useInitialValue(activeNodeRect);\n    const dropAnimation = useDropAnimation({\n        config: dropAnimationConfig,\n        draggableNodes,\n        droppableContainers,\n        measuringConfiguration\n    }); // We need to wait for the active node to be measured before connecting the drag overlay ref\n    // otherwise collisions can be computed against a mispositioned drag overlay\n    const ref = initialRect ? dragOverlay.setRef : undefined;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(NullifiedContextProvider, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(AnimationManager, {\n        animation: dropAnimation\n    }, active && key ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(PositionedOverlay, {\n        key: key,\n        id: active.id,\n        ref: ref,\n        as: wrapperElement,\n        activatorEvent: activatorEvent,\n        adjustScale: adjustScale,\n        className: className,\n        transition: transition,\n        rect: initialRect,\n        style: {\n            zIndex,\n            ...style\n        },\n        transform: modifiedTransform\n    }, children) : null));\n});\n //# sourceMappingURL=core.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BkbmQta2l0L2NvcmUvZGlzdC9jb3JlLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0o7QUFDdEY7QUFDNFE7QUFDN1A7QUFFakYsTUFBTXVDLG9CQUFvQixXQUFXLEdBQUV0QyxvREFBYUEsQ0FBQztBQUVyRCxTQUFTdUMsY0FBY0MsUUFBUTtJQUM3QixNQUFNQyxtQkFBbUJ4QyxpREFBVUEsQ0FBQ3FDO0lBQ3BDcEMsZ0RBQVNBLENBQUM7UUFDUixJQUFJLENBQUN1QyxrQkFBa0I7WUFDckIsTUFBTSxJQUFJQyxNQUFNO1FBQ2xCO1FBRUEsTUFBTUMsY0FBY0YsaUJBQWlCRDtRQUNyQyxPQUFPRztJQUNULEdBQUc7UUFBQ0g7UUFBVUM7S0FBaUI7QUFDakM7QUFFQSxTQUFTRztJQUNQLE1BQU0sQ0FBQ0MsVUFBVSxHQUFHMUMsK0NBQVFBLENBQUMsSUFBTSxJQUFJMkM7SUFDdkMsTUFBTUwsbUJBQW1CckMsa0RBQVdBLENBQUNvQyxDQUFBQTtRQUNuQ0ssVUFBVXRCLEdBQUcsQ0FBQ2lCO1FBQ2QsT0FBTyxJQUFNSyxVQUFVRSxNQUFNLENBQUNQO0lBQ2hDLEdBQUc7UUFBQ0s7S0FBVTtJQUNkLE1BQU1HLFdBQVc1QyxrREFBV0EsQ0FBQzZDLENBQUFBO1FBQzNCLElBQUksRUFDRkMsSUFBSSxFQUNKQyxLQUFLLEVBQ04sR0FBR0Y7UUFDSkosVUFBVU8sT0FBTyxDQUFDWixDQUFBQTtZQUNoQixJQUFJYTtZQUVKLE9BQU8sQ0FBQ0EsaUJBQWlCYixRQUFRLENBQUNVLEtBQUssS0FBSyxPQUFPLEtBQUssSUFBSUcsZUFBZUMsSUFBSSxDQUFDZCxVQUFVVztRQUM1RjtJQUNGLEdBQUc7UUFBQ047S0FBVTtJQUNkLE9BQU87UUFBQ0c7UUFBVVA7S0FBaUI7QUFDckM7QUFFQSxNQUFNYyxrQ0FBa0M7SUFDdENDLFdBQVc7QUFDYjtBQUNBLE1BQU1DLHVC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LENBQUNvckIsMEJBQTBCLG9CQUFNcHJCLDBEQUFtQixDQUFDMnFCLGtCQUFrQjtRQUMvRkMsV0FBV21EO0lBQ2IsR0FBR25xQixVQUFVc04sb0JBQU1sUiwwREFBbUIsQ0FBQ3lyQixtQkFBbUI7UUFDeER2YSxLQUFLQTtRQUNMck4sSUFBSUQsT0FBT0MsRUFBRTtRQUNicW5CLEtBQUtBO1FBQ0xRLElBQUl1QztRQUNKN0wsZ0JBQWdCQTtRQUNoQjlYLGFBQWFBO1FBQ2JxaEIsV0FBV0E7UUFDWEUsWUFBWUE7UUFDWjlrQixNQUFNZ1k7UUFDTjZNLE9BQU87WUFDTHNDO1lBQ0EsR0FBR3RDLEtBQUs7UUFDVjtRQUNBcmhCLFdBQVc0akI7SUFDYixHQUFHck4sWUFBWTtBQUNqQjtBQUV3akIsQ0FDeGpCLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQGRuZC1raXQvY29yZS9kaXN0L2NvcmUuZXNtLmpzPzBjMjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZUVmZmVjdCwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrLCB1c2VNZW1vLCB1c2VSZWYsIHVzZVJlZHVjZXIsIG1lbW8sIGNsb25lRWxlbWVudCwgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCwgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IHsgdXNlVW5pcXVlSWQsIGdldEV2ZW50Q29vcmRpbmF0ZXMsIGdldFdpbmRvdywgaXNEb2N1bWVudCwgaXNIVE1MRWxlbWVudCwgaXNTVkdFbGVtZW50LCBjYW5Vc2VET00sIGlzV2luZG93LCBpc05vZGUsIGdldE93bmVyRG9jdW1lbnQsIGFkZCwgaXNLZXlib2FyZEV2ZW50LCBzdWJ0cmFjdCwgdXNlTGF6eU1lbW8sIHVzZUludGVydmFsLCB1c2VQcmV2aW91cywgdXNlTGF0ZXN0VmFsdWUsIHVzZUV2ZW50LCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0LCB1c2VOb2RlUmVmLCBmaW5kRmlyc3RGb2N1c2FibGVOb2RlLCBDU1MgfSBmcm9tICdAZG5kLWtpdC91dGlsaXRpZXMnO1xuaW1wb3J0IHsgdXNlQW5ub3VuY2VtZW50LCBIaWRkZW5UZXh0LCBMaXZlUmVnaW9uIH0gZnJvbSAnQGRuZC1raXQvYWNjZXNzaWJpbGl0eSc7XG5cbmNvbnN0IERuZE1vbml0b3JDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQobnVsbCk7XG5cbmZ1bmN0aW9uIHVzZURuZE1vbml0b3IobGlzdGVuZXIpIHtcbiAgY29uc3QgcmVnaXN0ZXJMaXN0ZW5lciA9IHVzZUNvbnRleHQoRG5kTW9uaXRvckNvbnRleHQpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghcmVnaXN0ZXJMaXN0ZW5lcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1c2VEbmRNb25pdG9yIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBjaGlsZHJlbiBvZiA8RG5kQ29udGV4dD4nKTtcbiAgICB9XG5cbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IHJlZ2lzdGVyTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIHJldHVybiB1bnN1YnNjcmliZTtcbiAgfSwgW2xpc3RlbmVyLCByZWdpc3Rlckxpc3RlbmVyXSk7XG59XG5cbmZ1bmN0aW9uIHVzZURuZE1vbml0b3JQcm92aWRlcigpIHtcbiAgY29uc3QgW2xpc3RlbmVyc10gPSB1c2VTdGF0ZSgoKSA9PiBuZXcgU2V0KCkpO1xuICBjb25zdCByZWdpc3Rlckxpc3RlbmVyID0gdXNlQ2FsbGJhY2sobGlzdGVuZXIgPT4ge1xuICAgIGxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgIHJldHVybiAoKSA9PiBsaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgfSwgW2xpc3RlbmVyc10pO1xuICBjb25zdCBkaXNwYXRjaCA9IHVzZUNhbGxiYWNrKF9yZWYgPT4ge1xuICAgIGxldCB7XG4gICAgICB0eXBlLFxuICAgICAgZXZlbnRcbiAgICB9ID0gX3JlZjtcbiAgICBsaXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiB7XG4gICAgICB2YXIgX2xpc3RlbmVyJHR5cGU7XG5cbiAgICAgIHJldHVybiAoX2xpc3RlbmVyJHR5cGUgPSBsaXN0ZW5lclt0eXBlXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9saXN0ZW5lciR0eXBlLmNhbGwobGlzdGVuZXIsIGV2ZW50KTtcbiAgICB9KTtcbiAgfSwgW2xpc3RlbmVyc10pO1xuICByZXR1cm4gW2Rpc3BhdGNoLCByZWdpc3Rlckxpc3RlbmVyXTtcbn1cblxuY29uc3QgZGVmYXVsdFNjcmVlblJlYWRlckluc3RydWN0aW9ucyA9IHtcbiAgZHJhZ2dhYmxlOiBcIlxcbiAgICBUbyBwaWNrIHVwIGEgZHJhZ2dhYmxlIGl0ZW0sIHByZXNzIHRoZSBzcGFjZSBiYXIuXFxuICAgIFdoaWxlIGRyYWdnaW5nLCB1c2UgdGhlIGFycm93IGtleXMgdG8gbW92ZSB0aGUgaXRlbS5cXG4gICAgUHJlc3Mgc3BhY2UgYWdhaW4gdG8gZHJvcCB0aGUgaXRlbSBpbiBpdHMgbmV3IHBvc2l0aW9uLCBvciBwcmVzcyBlc2NhcGUgdG8gY2FuY2VsLlxcbiAgXCJcbn07XG5jb25zdCBkZWZhdWx0QW5ub3VuY2VtZW50cyA9IHtcbiAgb25EcmFnU3RhcnQoX3JlZikge1xuICAgIGxldCB7XG4gICAgICBhY3RpdmVcbiAgICB9ID0gX3JlZjtcbiAgICByZXR1cm4gXCJQaWNrZWQgdXAgZHJhZ2dhYmxlIGl0ZW0gXCIgKyBhY3RpdmUuaWQgKyBcIi5cIjtcbiAgfSxcblxuICBvbkRyYWdPdmVyKF9yZWYyKSB7XG4gICAgbGV0IHtcbiAgICAgIGFjdGl2ZSxcbiAgICAgIG92ZXJcbiAgICB9ID0gX3JlZjI7XG5cbiAgICBpZiAob3Zlcikge1xuICAgICAgcmV0dXJuIFwiRHJhZ2dhYmxlIGl0ZW0gXCIgKyBhY3RpdmUuaWQgKyBcIiB3YXMgbW92ZWQgb3ZlciBkcm9wcGFibGUgYXJlYSBcIiArIG92ZXIuaWQgKyBcIi5cIjtcbiAgICB9XG5cbiAgICByZXR1cm4gXCJEcmFnZ2FibGUgaXRlbSBcIiArIGFjdGl2ZS5pZCArIFwiIGlzIG5vIGxvbmdlciBvdmVyIGEgZHJvcHBhYmxlIGFyZWEuXCI7XG4gIH0sXG5cbiAgb25EcmFnRW5kKF9yZWYzKSB7XG4gICAgbGV0IHtcbiAgICAgIGFjdGl2ZSxcbiAgICAgIG92ZXJcbiAgICB9ID0gX3JlZjM7XG5cbiAgICBpZiAob3Zlcikge1xuICAgICAgcmV0dXJuIFwiRHJhZ2dhYmxlIGl0ZW0gXCIgKyBhY3RpdmUuaWQgKyBcIiB3YXMgZHJvcHBlZCBvdmVyIGRyb3BwYWJsZSBhcmVhIFwiICsgb3Zlci5pZDtcbiAgICB9XG5cbiAgICByZXR1cm4gXCJEcmFnZ2FibGUgaXRlbSBcIiArIGFjdGl2ZS5pZCArIFwiIHdhcyBkcm9wcGVkLlwiO1xuICB9LFxuXG4gIG9uRHJhZ0NhbmNlbChfcmVmNCkge1xuICAgIGxldCB7XG4gICAgICBhY3RpdmVcbiAgICB9ID0gX3JlZjQ7XG4gICAgcmV0dXJuIFwiRHJhZ2dpbmcgd2FzIGNhbmNlbGxlZC4gRHJhZ2dhYmxlIGl0ZW0gXCIgKyBhY3RpdmUuaWQgKyBcIiB3YXMgZHJvcHBlZC5cIjtcbiAgfVxuXG59O1xuXG5mdW5jdGlvbiBBY2Nlc3NpYmlsaXR5KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBhbm5vdW5jZW1lbnRzID0gZGVmYXVsdEFubm91bmNlbWVudHMsXG4gICAgY29udGFpbmVyLFxuICAgIGhpZGRlblRleHREZXNjcmliZWRCeUlkLFxuICAgIHNjcmVlblJlYWRlckluc3RydWN0aW9ucyA9IGRlZmF1bHRTY3JlZW5SZWFkZXJJbnN0cnVjdGlvbnNcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHtcbiAgICBhbm5vdW5jZSxcbiAgICBhbm5vdW5jZW1lbnRcbiAgfSA9IHVzZUFubm91bmNlbWVudCgpO1xuICBjb25zdCBsaXZlUmVnaW9uSWQgPSB1c2VVbmlxdWVJZChcIkRuZExpdmVSZWdpb25cIik7XG4gIGNvbnN0IFttb3VudGVkLCBzZXRNb3VudGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXRNb3VudGVkKHRydWUpO1xuICB9LCBbXSk7XG4gIHVzZURuZE1vbml0b3IodXNlTWVtbygoKSA9PiAoe1xuICAgIG9uRHJhZ1N0YXJ0KF9yZWYyKSB7XG4gICAgICBsZXQge1xuICAgICAgICBhY3RpdmVcbiAgICAgIH0gPSBfcmVmMjtcbiAgICAgIGFubm91bmNlKGFubm91bmNlbWVudHMub25EcmFnU3RhcnQoe1xuICAgICAgICBhY3RpdmVcbiAgICAgIH0pKTtcbiAgICB9LFxuXG4gICAgb25EcmFnTW92ZShfcmVmMykge1xuICAgICAgbGV0IHtcbiAgICAgICAgYWN0aXZlLFxuICAgICAgICBvdmVyXG4gICAgICB9ID0gX3JlZjM7XG5cbiAgICAgIGlmIChhbm5vdW5jZW1lbnRzLm9uRHJhZ01vdmUpIHtcbiAgICAgICAgYW5ub3VuY2UoYW5ub3VuY2VtZW50cy5vbkRyYWdNb3ZlKHtcbiAgICAgICAgICBhY3RpdmUsXG4gICAgICAgICAgb3ZlclxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIG9uRHJhZ092ZXIoX3JlZjQpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIGFjdGl2ZSxcbiAgICAgICAgb3ZlclxuICAgICAgfSA9IF9yZWY0O1xuICAgICAgYW5ub3VuY2UoYW5ub3VuY2VtZW50cy5vbkRyYWdPdmVyKHtcbiAgICAgICAgYWN0aXZlLFxuICAgICAgICBvdmVyXG4gICAgICB9KSk7XG4gICAgfSxcblxuICAgIG9uRHJhZ0VuZChfcmVmNSkge1xuICAgICAgbGV0IHtcbiAgICAgICAgYWN0aXZlLFxuICAgICAgICBvdmVyXG4gICAgICB9ID0gX3JlZjU7XG4gICAgICBhbm5vdW5jZShhbm5vdW5jZW1lbnRzLm9uRHJhZ0VuZCh7XG4gICAgICAgIGFjdGl2ZSxcbiAgICAgICAgb3ZlclxuICAgICAgfSkpO1xuICAgIH0sXG5cbiAgICBvbkRyYWdDYW5jZWwoX3JlZjYpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIGFjdGl2ZSxcbiAgICAgICAgb3ZlclxuICAgICAgfSA9IF9yZWY2O1xuICAgICAgYW5ub3VuY2UoYW5ub3VuY2VtZW50cy5vbkRyYWdDYW5jZWwoe1xuICAgICAgICBhY3RpdmUsXG4gICAgICAgIG92ZXJcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgfSksIFthbm5vdW5jZSwgYW5ub3VuY2VtZW50c10pKTtcblxuICBpZiAoIW1vdW50ZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IG1hcmt1cCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSGlkZGVuVGV4dCwge1xuICAgIGlkOiBoaWRkZW5UZXh0RGVzY3JpYmVkQnlJZCxcbiAgICB2YWx1ZTogc2NyZWVuUmVhZGVySW5zdHJ1Y3Rpb25zLmRyYWdnYWJsZVxuICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChMaXZlUmVnaW9uLCB7XG4gICAgaWQ6IGxpdmVSZWdpb25JZCxcbiAgICBhbm5vdW5jZW1lbnQ6IGFubm91bmNlbWVudFxuICB9KSk7XG4gIHJldHVybiBjb250YWluZXIgPyBjcmVhdGVQb3J0YWwobWFya3VwLCBjb250YWluZXIpIDogbWFya3VwO1xufVxuXG52YXIgQWN0aW9uO1xuXG4oZnVuY3Rpb24gKEFjdGlvbikge1xuICBBY3Rpb25bXCJEcmFnU3RhcnRcIl0gPSBcImRyYWdTdGFydFwiO1xuICBBY3Rpb25bXCJEcmFnTW92ZVwiXSA9IFwiZHJhZ01vdmVcIjtcbiAgQWN0aW9uW1wiRHJhZ0VuZFwiXSA9IFwiZHJhZ0VuZFwiO1xuICBBY3Rpb25bXCJEcmFnQ2FuY2VsXCJdID0gXCJkcmFnQ2FuY2VsXCI7XG4gIEFjdGlvbltcIkRyYWdPdmVyXCJdID0gXCJkcmFnT3ZlclwiO1xuICBBY3Rpb25bXCJSZWdpc3RlckRyb3BwYWJsZVwiXSA9IFwicmVnaXN0ZXJEcm9wcGFibGVcIjtcbiAgQWN0aW9uW1wiU2V0RHJvcHBhYmxlRGlzYWJsZWRcIl0gPSBcInNldERyb3BwYWJsZURpc2FibGVkXCI7XG4gIEFjdGlvbltcIlVucmVnaXN0ZXJEcm9wcGFibGVcIl0gPSBcInVucmVnaXN0ZXJEcm9wcGFibGVcIjtcbn0pKEFjdGlvbiB8fCAoQWN0aW9uID0ge30pKTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIHVzZVNlbnNvcihzZW5zb3IsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHVzZU1lbW8oKCkgPT4gKHtcbiAgICBzZW5zb3IsXG4gICAgb3B0aW9uczogb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucyA6IHt9XG4gIH0pLCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFtzZW5zb3IsIG9wdGlvbnNdKTtcbn1cblxuZnVuY3Rpb24gdXNlU2Vuc29ycygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNlbnNvcnMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgc2Vuc29yc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiB1c2VNZW1vKCgpID0+IFsuLi5zZW5zb3JzXS5maWx0ZXIoc2Vuc29yID0+IHNlbnNvciAhPSBudWxsKSwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBbLi4uc2Vuc29yc10pO1xufVxuXG5jb25zdCBkZWZhdWx0Q29vcmRpbmF0ZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIHg6IDAsXG4gIHk6IDBcbn0pO1xuXG4vKipcclxuICogUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXHJcbiAqL1xuZnVuY3Rpb24gZGlzdGFuY2VCZXR3ZWVuKHAxLCBwMikge1xuICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHAxLnggLSBwMi54LCAyKSArIE1hdGgucG93KHAxLnkgLSBwMi55LCAyKSk7XG59XG5cbmZ1bmN0aW9uIGdldFJlbGF0aXZlVHJhbnNmb3JtT3JpZ2luKGV2ZW50LCByZWN0KSB7XG4gIGNvbnN0IGV2ZW50Q29vcmRpbmF0ZXMgPSBnZXRFdmVudENvb3JkaW5hdGVzKGV2ZW50KTtcblxuICBpZiAoIWV2ZW50Q29vcmRpbmF0ZXMpIHtcbiAgICByZXR1cm4gJzAgMCc7XG4gIH1cblxuICBjb25zdCB0cmFuc2Zvcm1PcmlnaW4gPSB7XG4gICAgeDogKGV2ZW50Q29vcmRpbmF0ZXMueCAtIHJlY3QubGVmdCkgLyByZWN0LndpZHRoICogMTAwLFxuICAgIHk6IChldmVudENvb3JkaW5hdGVzLnkgLSByZWN0LnRvcCkgLyByZWN0LmhlaWdodCAqIDEwMFxuICB9O1xuICByZXR1cm4gdHJhbnNmb3JtT3JpZ2luLnggKyBcIiUgXCIgKyB0cmFuc2Zvcm1PcmlnaW4ueSArIFwiJVwiO1xufVxuXG4vKipcclxuICogU29ydCBjb2xsaXNpb25zIGZyb20gc21hbGxlc3QgdG8gZ3JlYXRlc3QgdmFsdWVcclxuICovXG5mdW5jdGlvbiBzb3J0Q29sbGlzaW9uc0FzYyhfcmVmLCBfcmVmMikge1xuICBsZXQge1xuICAgIGRhdGE6IHtcbiAgICAgIHZhbHVlOiBhXG4gICAgfVxuICB9ID0gX3JlZjtcbiAgbGV0IHtcbiAgICBkYXRhOiB7XG4gICAgICB2YWx1ZTogYlxuICAgIH1cbiAgfSA9IF9yZWYyO1xuICByZXR1cm4gYSAtIGI7XG59XG4vKipcclxuICogU29ydCBjb2xsaXNpb25zIGZyb20gZ3JlYXRlc3QgdG8gc21hbGxlc3QgdmFsdWVcclxuICovXG5cbmZ1bmN0aW9uIHNvcnRDb2xsaXNpb25zRGVzYyhfcmVmMywgX3JlZjQpIHtcbiAgbGV0IHtcbiAgICBkYXRhOiB7XG4gICAgICB2YWx1ZTogYVxuICAgIH1cbiAgfSA9IF9yZWYzO1xuICBsZXQge1xuICAgIGRhdGE6IHtcbiAgICAgIHZhbHVlOiBiXG4gICAgfVxuICB9ID0gX3JlZjQ7XG4gIHJldHVybiBiIC0gYTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgY29ybmVycyBvZiBhIGdpdmVuIHJlY3RhbmdsZTpcclxuICogW1RvcExlZnQge3gsIHl9LCBUb3BSaWdodCB7eCwgeX0sIEJvdHRvbUxlZnQge3gsIHl9LCBCb3R0b21SaWdodCB7eCwgeX1dXHJcbiAqL1xuXG5mdW5jdGlvbiBjb3JuZXJzT2ZSZWN0YW5nbGUoX3JlZjUpIHtcbiAgbGV0IHtcbiAgICBsZWZ0LFxuICAgIHRvcCxcbiAgICBoZWlnaHQsXG4gICAgd2lkdGhcbiAgfSA9IF9yZWY1O1xuICByZXR1cm4gW3tcbiAgICB4OiBsZWZ0LFxuICAgIHk6IHRvcFxuICB9LCB7XG4gICAgeDogbGVmdCArIHdpZHRoLFxuICAgIHk6IHRvcFxuICB9LCB7XG4gICAgeDogbGVmdCxcbiAgICB5OiB0b3AgKyBoZWlnaHRcbiAgfSwge1xuICAgIHg6IGxlZnQgKyB3aWR0aCxcbiAgICB5OiB0b3AgKyBoZWlnaHRcbiAgfV07XG59XG5mdW5jdGlvbiBnZXRGaXJzdENvbGxpc2lvbihjb2xsaXNpb25zLCBwcm9wZXJ0eSkge1xuICBpZiAoIWNvbGxpc2lvbnMgfHwgY29sbGlzaW9ucy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IFtmaXJzdENvbGxpc2lvbl0gPSBjb2xsaXNpb25zO1xuICByZXR1cm4gcHJvcGVydHkgPyBmaXJzdENvbGxpc2lvbltwcm9wZXJ0eV0gOiBmaXJzdENvbGxpc2lvbjtcbn1cblxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBjZW50ZXIgb2YgYSBnaXZlbiBDbGllbnRSZWN0XHJcbiAqL1xuXG5mdW5jdGlvbiBjZW50ZXJPZlJlY3RhbmdsZShyZWN0LCBsZWZ0LCB0b3ApIHtcbiAgaWYgKGxlZnQgPT09IHZvaWQgMCkge1xuICAgIGxlZnQgPSByZWN0LmxlZnQ7XG4gIH1cblxuICBpZiAodG9wID09PSB2b2lkIDApIHtcbiAgICB0b3AgPSByZWN0LnRvcDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogbGVmdCArIHJlY3Qud2lkdGggKiAwLjUsXG4gICAgeTogdG9wICsgcmVjdC5oZWlnaHQgKiAwLjVcbiAgfTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBjbG9zZXN0IHJlY3RhbmdsZXMgZnJvbSBhbiBhcnJheSBvZiByZWN0YW5nbGVzIHRvIHRoZSBjZW50ZXIgb2YgYSBnaXZlblxyXG4gKiByZWN0YW5nbGUuXHJcbiAqL1xuXG5cbmNvbnN0IGNsb3Nlc3RDZW50ZXIgPSBfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBjb2xsaXNpb25SZWN0LFxuICAgIGRyb3BwYWJsZVJlY3RzLFxuICAgIGRyb3BwYWJsZUNvbnRhaW5lcnNcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGNlbnRlclJlY3QgPSBjZW50ZXJPZlJlY3RhbmdsZShjb2xsaXNpb25SZWN0LCBjb2xsaXNpb25SZWN0LmxlZnQsIGNvbGxpc2lvblJlY3QudG9wKTtcbiAgY29uc3QgY29sbGlzaW9ucyA9IFtdO1xuXG4gIGZvciAoY29uc3QgZHJvcHBhYmxlQ29udGFpbmVyIG9mIGRyb3BwYWJsZUNvbnRhaW5lcnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBpZFxuICAgIH0gPSBkcm9wcGFibGVDb250YWluZXI7XG4gICAgY29uc3QgcmVjdCA9IGRyb3BwYWJsZVJlY3RzLmdldChpZCk7XG5cbiAgICBpZiAocmVjdCkge1xuICAgICAgY29uc3QgZGlzdEJldHdlZW4gPSBkaXN0YW5jZUJldHdlZW4oY2VudGVyT2ZSZWN0YW5nbGUocmVjdCksIGNlbnRlclJlY3QpO1xuICAgICAgY29sbGlzaW9ucy5wdXNoKHtcbiAgICAgICAgaWQsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBkcm9wcGFibGVDb250YWluZXIsXG4gICAgICAgICAgdmFsdWU6IGRpc3RCZXR3ZWVuXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb2xsaXNpb25zLnNvcnQoc29ydENvbGxpc2lvbnNBc2MpO1xufTtcblxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGNsb3Nlc3QgcmVjdGFuZ2xlcyBmcm9tIGFuIGFycmF5IG9mIHJlY3RhbmdsZXMgdG8gdGhlIGNvcm5lcnMgb2ZcclxuICogYW5vdGhlciByZWN0YW5nbGUuXHJcbiAqL1xuXG5jb25zdCBjbG9zZXN0Q29ybmVycyA9IF9yZWYgPT4ge1xuICBsZXQge1xuICAgIGNvbGxpc2lvblJlY3QsXG4gICAgZHJvcHBhYmxlUmVjdHMsXG4gICAgZHJvcHBhYmxlQ29udGFpbmVyc1xuICB9ID0gX3JlZjtcbiAgY29uc3QgY29ybmVycyA9IGNvcm5lcnNPZlJlY3RhbmdsZShjb2xsaXNpb25SZWN0KTtcbiAgY29uc3QgY29sbGlzaW9ucyA9IFtdO1xuXG4gIGZvciAoY29uc3QgZHJvcHBhYmxlQ29udGFpbmVyIG9mIGRyb3BwYWJsZUNvbnRhaW5lcnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBpZFxuICAgIH0gPSBkcm9wcGFibGVDb250YWluZXI7XG4gICAgY29uc3QgcmVjdCA9IGRyb3BwYWJsZVJlY3RzLmdldChpZCk7XG5cbiAgICBpZiAocmVjdCkge1xuICAgICAgY29uc3QgcmVjdENvcm5lcnMgPSBjb3JuZXJzT2ZSZWN0YW5nbGUocmVjdCk7XG4gICAgICBjb25zdCBkaXN0YW5jZXMgPSBjb3JuZXJzLnJlZHVjZSgoYWNjdW11bGF0b3IsIGNvcm5lciwgaW5kZXgpID0+IHtcbiAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yICsgZGlzdGFuY2VCZXR3ZWVuKHJlY3RDb3JuZXJzW2luZGV4XSwgY29ybmVyKTtcbiAgICAgIH0sIDApO1xuICAgICAgY29uc3QgZWZmZWN0aXZlRGlzdGFuY2UgPSBOdW1iZXIoKGRpc3RhbmNlcyAvIDQpLnRvRml4ZWQoNCkpO1xuICAgICAgY29sbGlzaW9ucy5wdXNoKHtcbiAgICAgICAgaWQsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBkcm9wcGFibGVDb250YWluZXIsXG4gICAgICAgICAgdmFsdWU6IGVmZmVjdGl2ZURpc3RhbmNlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb2xsaXNpb25zLnNvcnQoc29ydENvbGxpc2lvbnNBc2MpO1xufTtcblxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGludGVyc2VjdGluZyByZWN0YW5nbGUgYXJlYSBiZXR3ZWVuIHR3byByZWN0YW5nbGVzXHJcbiAqL1xuXG5mdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb25SYXRpbyhlbnRyeSwgdGFyZ2V0KSB7XG4gIGNvbnN0IHRvcCA9IE1hdGgubWF4KHRhcmdldC50b3AsIGVudHJ5LnRvcCk7XG4gIGNvbnN0IGxlZnQgPSBNYXRoLm1heCh0YXJnZXQubGVmdCwgZW50cnkubGVmdCk7XG4gIGNvbnN0IHJpZ2h0ID0gTWF0aC5taW4odGFyZ2V0LmxlZnQgKyB0YXJnZXQud2lkdGgsIGVudHJ5LmxlZnQgKyBlbnRyeS53aWR0aCk7XG4gIGNvbnN0IGJvdHRvbSA9IE1hdGgubWluKHRhcmdldC50b3AgKyB0YXJnZXQuaGVpZ2h0LCBlbnRyeS50b3AgKyBlbnRyeS5oZWlnaHQpO1xuICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuXG4gIGlmIChsZWZ0IDwgcmlnaHQgJiYgdG9wIDwgYm90dG9tKSB7XG4gICAgY29uc3QgdGFyZ2V0QXJlYSA9IHRhcmdldC53aWR0aCAqIHRhcmdldC5oZWlnaHQ7XG4gICAgY29uc3QgZW50cnlBcmVhID0gZW50cnkud2lkdGggKiBlbnRyeS5oZWlnaHQ7XG4gICAgY29uc3QgaW50ZXJzZWN0aW9uQXJlYSA9IHdpZHRoICogaGVpZ2h0O1xuICAgIGNvbnN0IGludGVyc2VjdGlvblJhdGlvID0gaW50ZXJzZWN0aW9uQXJlYSAvICh0YXJnZXRBcmVhICsgZW50cnlBcmVhIC0gaW50ZXJzZWN0aW9uQXJlYSk7XG4gICAgcmV0dXJuIE51bWJlcihpbnRlcnNlY3Rpb25SYXRpby50b0ZpeGVkKDQpKTtcbiAgfSAvLyBSZWN0YW5nbGVzIGRvIG5vdCBvdmVybGFwLCBvciBvdmVybGFwIGhhcyBhbiBhcmVhIG9mIHplcm8gKGVkZ2UvY29ybmVyIG92ZXJsYXApXG5cblxuICByZXR1cm4gMDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSByZWN0YW5nbGVzIHRoYXQgaGFzIHRoZSBncmVhdGVzdCBpbnRlcnNlY3Rpb24gYXJlYSB3aXRoIGEgZ2l2ZW5cclxuICogcmVjdGFuZ2xlIGluIGFuIGFycmF5IG9mIHJlY3RhbmdsZXMuXHJcbiAqL1xuXG5jb25zdCByZWN0SW50ZXJzZWN0aW9uID0gX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgY29sbGlzaW9uUmVjdCxcbiAgICBkcm9wcGFibGVSZWN0cyxcbiAgICBkcm9wcGFibGVDb250YWluZXJzXG4gIH0gPSBfcmVmO1xuICBjb25zdCBjb2xsaXNpb25zID0gW107XG5cbiAgZm9yIChjb25zdCBkcm9wcGFibGVDb250YWluZXIgb2YgZHJvcHBhYmxlQ29udGFpbmVycykge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkXG4gICAgfSA9IGRyb3BwYWJsZUNvbnRhaW5lcjtcbiAgICBjb25zdCByZWN0ID0gZHJvcHBhYmxlUmVjdHMuZ2V0KGlkKTtcblxuICAgIGlmIChyZWN0KSB7XG4gICAgICBjb25zdCBpbnRlcnNlY3Rpb25SYXRpbyA9IGdldEludGVyc2VjdGlvblJhdGlvKHJlY3QsIGNvbGxpc2lvblJlY3QpO1xuXG4gICAgICBpZiAoaW50ZXJzZWN0aW9uUmF0aW8gPiAwKSB7XG4gICAgICAgIGNvbGxpc2lvbnMucHVzaCh7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgZHJvcHBhYmxlQ29udGFpbmVyLFxuICAgICAgICAgICAgdmFsdWU6IGludGVyc2VjdGlvblJhdGlvXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29sbGlzaW9ucy5zb3J0KHNvcnRDb2xsaXNpb25zRGVzYyk7XG59O1xuXG4vKipcclxuICogQ2hlY2sgaWYgYSBnaXZlbiBwb2ludCBpcyBjb250YWluZWQgd2l0aGluIGEgYm91bmRpbmcgcmVjdGFuZ2xlXHJcbiAqL1xuXG5mdW5jdGlvbiBpc1BvaW50V2l0aGluUmVjdChwb2ludCwgcmVjdCkge1xuICBjb25zdCB7XG4gICAgdG9wLFxuICAgIGxlZnQsXG4gICAgYm90dG9tLFxuICAgIHJpZ2h0XG4gIH0gPSByZWN0O1xuICByZXR1cm4gdG9wIDw9IHBvaW50LnkgJiYgcG9pbnQueSA8PSBib3R0b20gJiYgbGVmdCA8PSBwb2ludC54ICYmIHBvaW50LnggPD0gcmlnaHQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgcmVjdGFuZ2xlcyB0aGF0IHRoZSBwb2ludGVyIGlzIGhvdmVyaW5nIG92ZXJcclxuICovXG5cblxuY29uc3QgcG9pbnRlcldpdGhpbiA9IF9yZWYgPT4ge1xuICBsZXQge1xuICAgIGRyb3BwYWJsZUNvbnRhaW5lcnMsXG4gICAgZHJvcHBhYmxlUmVjdHMsXG4gICAgcG9pbnRlckNvb3JkaW5hdGVzXG4gIH0gPSBfcmVmO1xuXG4gIGlmICghcG9pbnRlckNvb3JkaW5hdGVzKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3QgY29sbGlzaW9ucyA9IFtdO1xuXG4gIGZvciAoY29uc3QgZHJvcHBhYmxlQ29udGFpbmVyIG9mIGRyb3BwYWJsZUNvbnRhaW5lcnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBpZFxuICAgIH0gPSBkcm9wcGFibGVDb250YWluZXI7XG4gICAgY29uc3QgcmVjdCA9IGRyb3BwYWJsZVJlY3RzLmdldChpZCk7XG5cbiAgICBpZiAocmVjdCAmJiBpc1BvaW50V2l0aGluUmVjdChwb2ludGVyQ29vcmRpbmF0ZXMsIHJlY3QpKSB7XG4gICAgICAvKiBUaGVyZSBtYXkgYmUgbW9yZSB0aGFuIGEgc2luZ2xlIHJlY3RhbmdsZSBpbnRlcnNlY3RpbmdcclxuICAgICAgICogd2l0aCB0aGUgcG9pbnRlciBjb29yZGluYXRlcy4gSW4gb3JkZXIgdG8gc29ydCB0aGVcclxuICAgICAgICogY29sbGlkaW5nIHJlY3RhbmdsZXMsIHdlIG1lYXN1cmUgdGhlIGRpc3RhbmNlIGJldHdlZW5cclxuICAgICAgICogdGhlIHBvaW50ZXIgYW5kIHRoZSBjb3JuZXJzIG9mIHRoZSBpbnRlcnNlY3RpbmcgcmVjdGFuZ2xlXHJcbiAgICAgICAqL1xuICAgICAgY29uc3QgY29ybmVycyA9IGNvcm5lcnNPZlJlY3RhbmdsZShyZWN0KTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlcyA9IGNvcm5lcnMucmVkdWNlKChhY2N1bXVsYXRvciwgY29ybmVyKSA9PiB7XG4gICAgICAgIHJldHVybiBhY2N1bXVsYXRvciArIGRpc3RhbmNlQmV0d2Vlbihwb2ludGVyQ29vcmRpbmF0ZXMsIGNvcm5lcik7XG4gICAgICB9LCAwKTtcbiAgICAgIGNvbnN0IGVmZmVjdGl2ZURpc3RhbmNlID0gTnVtYmVyKChkaXN0YW5jZXMgLyA0KS50b0ZpeGVkKDQpKTtcbiAgICAgIGNvbGxpc2lvbnMucHVzaCh7XG4gICAgICAgIGlkLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgZHJvcHBhYmxlQ29udGFpbmVyLFxuICAgICAgICAgIHZhbHVlOiBlZmZlY3RpdmVEaXN0YW5jZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29sbGlzaW9ucy5zb3J0KHNvcnRDb2xsaXNpb25zQXNjKTtcbn07XG5cbmZ1bmN0aW9uIGFkanVzdFNjYWxlKHRyYW5zZm9ybSwgcmVjdDEsIHJlY3QyKSB7XG4gIHJldHVybiB7IC4uLnRyYW5zZm9ybSxcbiAgICBzY2FsZVg6IHJlY3QxICYmIHJlY3QyID8gcmVjdDEud2lkdGggLyByZWN0Mi53aWR0aCA6IDEsXG4gICAgc2NhbGVZOiByZWN0MSAmJiByZWN0MiA/IHJlY3QxLmhlaWdodCAvIHJlY3QyLmhlaWdodCA6IDFcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVjdERlbHRhKHJlY3QxLCByZWN0Mikge1xuICByZXR1cm4gcmVjdDEgJiYgcmVjdDIgPyB7XG4gICAgeDogcmVjdDEubGVmdCAtIHJlY3QyLmxlZnQsXG4gICAgeTogcmVjdDEudG9wIC0gcmVjdDIudG9wXG4gIH0gOiBkZWZhdWx0Q29vcmRpbmF0ZXM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlY3RBZGp1c3RtZW50Rm4obW9kaWZpZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGFkanVzdENsaWVudFJlY3QocmVjdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhZGp1c3RtZW50cyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhZGp1c3RtZW50c1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkanVzdG1lbnRzLnJlZHVjZSgoYWNjLCBhZGp1c3RtZW50KSA9PiAoeyAuLi5hY2MsXG4gICAgICB0b3A6IGFjYy50b3AgKyBtb2RpZmllciAqIGFkanVzdG1lbnQueSxcbiAgICAgIGJvdHRvbTogYWNjLmJvdHRvbSArIG1vZGlmaWVyICogYWRqdXN0bWVudC55LFxuICAgICAgbGVmdDogYWNjLmxlZnQgKyBtb2RpZmllciAqIGFkanVzdG1lbnQueCxcbiAgICAgIHJpZ2h0OiBhY2MucmlnaHQgKyBtb2RpZmllciAqIGFkanVzdG1lbnQueFxuICAgIH0pLCB7IC4uLnJlY3RcbiAgICB9KTtcbiAgfTtcbn1cbmNvbnN0IGdldEFkanVzdGVkUmVjdCA9IC8qI19fUFVSRV9fKi9jcmVhdGVSZWN0QWRqdXN0bWVudEZuKDEpO1xuXG5mdW5jdGlvbiBwYXJzZVRyYW5zZm9ybSh0cmFuc2Zvcm0pIHtcbiAgaWYgKHRyYW5zZm9ybS5zdGFydHNXaXRoKCdtYXRyaXgzZCgnKSkge1xuICAgIGNvbnN0IHRyYW5zZm9ybUFycmF5ID0gdHJhbnNmb3JtLnNsaWNlKDksIC0xKS5zcGxpdCgvLCAvKTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogK3RyYW5zZm9ybUFycmF5WzEyXSxcbiAgICAgIHk6ICt0cmFuc2Zvcm1BcnJheVsxM10sXG4gICAgICBzY2FsZVg6ICt0cmFuc2Zvcm1BcnJheVswXSxcbiAgICAgIHNjYWxlWTogK3RyYW5zZm9ybUFycmF5WzVdXG4gICAgfTtcbiAgfSBlbHNlIGlmICh0cmFuc2Zvcm0uc3RhcnRzV2l0aCgnbWF0cml4KCcpKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtQXJyYXkgPSB0cmFuc2Zvcm0uc2xpY2UoNywgLTEpLnNwbGl0KC8sIC8pO1xuICAgIHJldHVybiB7XG4gICAgICB4OiArdHJhbnNmb3JtQXJyYXlbNF0sXG4gICAgICB5OiArdHJhbnNmb3JtQXJyYXlbNV0sXG4gICAgICBzY2FsZVg6ICt0cmFuc2Zvcm1BcnJheVswXSxcbiAgICAgIHNjYWxlWTogK3RyYW5zZm9ybUFycmF5WzNdXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBpbnZlcnNlVHJhbnNmb3JtKHJlY3QsIHRyYW5zZm9ybSwgdHJhbnNmb3JtT3JpZ2luKSB7XG4gIGNvbnN0IHBhcnNlZFRyYW5zZm9ybSA9IHBhcnNlVHJhbnNmb3JtKHRyYW5zZm9ybSk7XG5cbiAgaWYgKCFwYXJzZWRUcmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gcmVjdDtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBzY2FsZVgsXG4gICAgc2NhbGVZLFxuICAgIHg6IHRyYW5zbGF0ZVgsXG4gICAgeTogdHJhbnNsYXRlWVxuICB9ID0gcGFyc2VkVHJhbnNmb3JtO1xuICBjb25zdCB4ID0gcmVjdC5sZWZ0IC0gdHJhbnNsYXRlWCAtICgxIC0gc2NhbGVYKSAqIHBhcnNlRmxvYXQodHJhbnNmb3JtT3JpZ2luKTtcbiAgY29uc3QgeSA9IHJlY3QudG9wIC0gdHJhbnNsYXRlWSAtICgxIC0gc2NhbGVZKSAqIHBhcnNlRmxvYXQodHJhbnNmb3JtT3JpZ2luLnNsaWNlKHRyYW5zZm9ybU9yaWdpbi5pbmRleE9mKCcgJykgKyAxKSk7XG4gIGNvbnN0IHcgPSBzY2FsZVggPyByZWN0LndpZHRoIC8gc2NhbGVYIDogcmVjdC53aWR0aDtcbiAgY29uc3QgaCA9IHNjYWxlWSA/IHJlY3QuaGVpZ2h0IC8gc2NhbGVZIDogcmVjdC5oZWlnaHQ7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHcsXG4gICAgaGVpZ2h0OiBoLFxuICAgIHRvcDogeSxcbiAgICByaWdodDogeCArIHcsXG4gICAgYm90dG9tOiB5ICsgaCxcbiAgICBsZWZ0OiB4XG4gIH07XG59XG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBpZ25vcmVUcmFuc2Zvcm06IGZhbHNlXG59O1xuLyoqXHJcbiAqIFJldHVybnMgdGhlIGJvdW5kaW5nIGNsaWVudCByZWN0IG9mIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0LlxyXG4gKi9cblxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdChlbGVtZW50LCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG4gIH1cblxuICBsZXQgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgaWYgKG9wdGlvbnMuaWdub3JlVHJhbnNmb3JtKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHJhbnNmb3JtLFxuICAgICAgdHJhbnNmb3JtT3JpZ2luXG4gICAgfSA9IGdldFdpbmRvdyhlbGVtZW50KS5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuXG4gICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgcmVjdCA9IGludmVyc2VUcmFuc2Zvcm0ocmVjdCwgdHJhbnNmb3JtLCB0cmFuc2Zvcm1PcmlnaW4pO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHtcbiAgICB0b3AsXG4gICAgbGVmdCxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgYm90dG9tLFxuICAgIHJpZ2h0XG4gIH0gPSByZWN0O1xuICByZXR1cm4ge1xuICAgIHRvcCxcbiAgICBsZWZ0LFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBib3R0b20sXG4gICAgcmlnaHRcbiAgfTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBib3VuZGluZyBjbGllbnQgcmVjdCBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydC5cclxuICpcclxuICogQHJlbWFya3NcclxuICogVGhlIENsaWVudFJlY3QgcmV0dXJuZWQgYnkgdGhpcyBtZXRob2QgZG9lcyBub3QgdGFrZSBpbnRvIGFjY291bnQgdHJhbnNmb3Jtc1xyXG4gKiBhcHBsaWVkIHRvIHRoZSBlbGVtZW50IGl0IG1lYXN1cmVzLlxyXG4gKlxyXG4gKi9cblxuZnVuY3Rpb24gZ2V0VHJhbnNmb3JtQWdub3N0aWNDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldENsaWVudFJlY3QoZWxlbWVudCwge1xuICAgIGlnbm9yZVRyYW5zZm9ybTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0V2luZG93Q2xpZW50UmVjdChlbGVtZW50KSB7XG4gIGNvbnN0IHdpZHRoID0gZWxlbWVudC5pbm5lcldpZHRoO1xuICBjb25zdCBoZWlnaHQgPSBlbGVtZW50LmlubmVySGVpZ2h0O1xuICByZXR1cm4ge1xuICAgIHRvcDogMCxcbiAgICBsZWZ0OiAwLFxuICAgIHJpZ2h0OiB3aWR0aCxcbiAgICBib3R0b206IGhlaWdodCxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNGaXhlZChub2RlLCBjb21wdXRlZFN0eWxlKSB7XG4gIGlmIChjb21wdXRlZFN0eWxlID09PSB2b2lkIDApIHtcbiAgICBjb21wdXRlZFN0eWxlID0gZ2V0V2luZG93KG5vZGUpLmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gIH1cblxuICByZXR1cm4gY29tcHV0ZWRTdHlsZS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJztcbn1cblxuZnVuY3Rpb24gaXNTY3JvbGxhYmxlKGVsZW1lbnQsIGNvbXB1dGVkU3R5bGUpIHtcbiAgaWYgKGNvbXB1dGVkU3R5bGUgPT09IHZvaWQgMCkge1xuICAgIGNvbXB1dGVkU3R5bGUgPSBnZXRXaW5kb3coZWxlbWVudCkuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgfVxuXG4gIGNvbnN0IG92ZXJmbG93UmVnZXggPSAvKGF1dG98c2Nyb2xsfG92ZXJsYXkpLztcbiAgY29uc3QgcHJvcGVydGllcyA9IFsnb3ZlcmZsb3cnLCAnb3ZlcmZsb3dYJywgJ292ZXJmbG93WSddO1xuICByZXR1cm4gcHJvcGVydGllcy5zb21lKHByb3BlcnR5ID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IGNvbXB1dGVkU3R5bGVbcHJvcGVydHldO1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gb3ZlcmZsb3dSZWdleC50ZXN0KHZhbHVlKSA6IGZhbHNlO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsYWJsZUFuY2VzdG9ycyhlbGVtZW50LCBsaW1pdCkge1xuICBjb25zdCBzY3JvbGxQYXJlbnRzID0gW107XG5cbiAgZnVuY3Rpb24gZmluZFNjcm9sbGFibGVBbmNlc3RvcnMobm9kZSkge1xuICAgIGlmIChsaW1pdCAhPSBudWxsICYmIHNjcm9sbFBhcmVudHMubGVuZ3RoID49IGxpbWl0KSB7XG4gICAgICByZXR1cm4gc2Nyb2xsUGFyZW50cztcbiAgICB9XG5cbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHJldHVybiBzY3JvbGxQYXJlbnRzO1xuICAgIH1cblxuICAgIGlmIChpc0RvY3VtZW50KG5vZGUpICYmIG5vZGUuc2Nyb2xsaW5nRWxlbWVudCAhPSBudWxsICYmICFzY3JvbGxQYXJlbnRzLmluY2x1ZGVzKG5vZGUuc2Nyb2xsaW5nRWxlbWVudCkpIHtcbiAgICAgIHNjcm9sbFBhcmVudHMucHVzaChub2RlLnNjcm9sbGluZ0VsZW1lbnQpO1xuICAgICAgcmV0dXJuIHNjcm9sbFBhcmVudHM7XG4gICAgfVxuXG4gICAgaWYgKCFpc0hUTUxFbGVtZW50KG5vZGUpIHx8IGlzU1ZHRWxlbWVudChub2RlKSkge1xuICAgICAgcmV0dXJuIHNjcm9sbFBhcmVudHM7XG4gICAgfVxuXG4gICAgaWYgKHNjcm9sbFBhcmVudHMuaW5jbHVkZXMobm9kZSkpIHtcbiAgICAgIHJldHVybiBzY3JvbGxQYXJlbnRzO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBnZXRXaW5kb3coZWxlbWVudCkuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblxuICAgIGlmIChub2RlICE9PSBlbGVtZW50KSB7XG4gICAgICBpZiAoaXNTY3JvbGxhYmxlKG5vZGUsIGNvbXB1dGVkU3R5bGUpKSB7XG4gICAgICAgIHNjcm9sbFBhcmVudHMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNGaXhlZChub2RlLCBjb21wdXRlZFN0eWxlKSkge1xuICAgICAgcmV0dXJuIHNjcm9sbFBhcmVudHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbmRTY3JvbGxhYmxlQW5jZXN0b3JzKG5vZGUucGFyZW50Tm9kZSk7XG4gIH1cblxuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gc2Nyb2xsUGFyZW50cztcbiAgfVxuXG4gIHJldHVybiBmaW5kU2Nyb2xsYWJsZUFuY2VzdG9ycyhlbGVtZW50KTtcbn1cbmZ1bmN0aW9uIGdldEZpcnN0U2Nyb2xsYWJsZUFuY2VzdG9yKG5vZGUpIHtcbiAgY29uc3QgW2ZpcnN0U2Nyb2xsYWJsZUFuY2VzdG9yXSA9IGdldFNjcm9sbGFibGVBbmNlc3RvcnMobm9kZSwgMSk7XG4gIHJldHVybiBmaXJzdFNjcm9sbGFibGVBbmNlc3RvciAhPSBudWxsID8gZmlyc3RTY3JvbGxhYmxlQW5jZXN0b3IgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRTY3JvbGxhYmxlRWxlbWVudChlbGVtZW50KSB7XG4gIGlmICghY2FuVXNlRE9NIHx8ICFlbGVtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoaXNXaW5kb3coZWxlbWVudCkpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIGlmICghaXNOb2RlKGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoaXNEb2N1bWVudChlbGVtZW50KSB8fCBlbGVtZW50ID09PSBnZXRPd25lckRvY3VtZW50KGVsZW1lbnQpLnNjcm9sbGluZ0VsZW1lbnQpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG5cbiAgaWYgKGlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRTY3JvbGxYQ29vcmRpbmF0ZShlbGVtZW50KSB7XG4gIGlmIChpc1dpbmRvdyhlbGVtZW50KSkge1xuICAgIHJldHVybiBlbGVtZW50LnNjcm9sbFg7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudC5zY3JvbGxMZWZ0O1xufVxuZnVuY3Rpb24gZ2V0U2Nyb2xsWUNvb3JkaW5hdGUoZWxlbWVudCkge1xuICBpZiAoaXNXaW5kb3coZWxlbWVudCkpIHtcbiAgICByZXR1cm4gZWxlbWVudC5zY3JvbGxZO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQuc2Nyb2xsVG9wO1xufVxuZnVuY3Rpb24gZ2V0U2Nyb2xsQ29vcmRpbmF0ZXMoZWxlbWVudCkge1xuICByZXR1cm4ge1xuICAgIHg6IGdldFNjcm9sbFhDb29yZGluYXRlKGVsZW1lbnQpLFxuICAgIHk6IGdldFNjcm9sbFlDb29yZGluYXRlKGVsZW1lbnQpXG4gIH07XG59XG5cbnZhciBEaXJlY3Rpb247XG5cbihmdW5jdGlvbiAoRGlyZWN0aW9uKSB7XG4gIERpcmVjdGlvbltEaXJlY3Rpb25bXCJGb3J3YXJkXCJdID0gMV0gPSBcIkZvcndhcmRcIjtcbiAgRGlyZWN0aW9uW0RpcmVjdGlvbltcIkJhY2t3YXJkXCJdID0gLTFdID0gXCJCYWNrd2FyZFwiO1xufSkoRGlyZWN0aW9uIHx8IChEaXJlY3Rpb24gPSB7fSkpO1xuXG5mdW5jdGlvbiBpc0RvY3VtZW50U2Nyb2xsaW5nRWxlbWVudChlbGVtZW50KSB7XG4gIGlmICghY2FuVXNlRE9NIHx8ICFlbGVtZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQgPT09IGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGdldFNjcm9sbFBvc2l0aW9uKHNjcm9sbGluZ0NvbnRhaW5lcikge1xuICBjb25zdCBtaW5TY3JvbGwgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG4gIGNvbnN0IGRpbWVuc2lvbnMgPSBpc0RvY3VtZW50U2Nyb2xsaW5nRWxlbWVudChzY3JvbGxpbmdDb250YWluZXIpID8ge1xuICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0LFxuICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aFxuICB9IDoge1xuICAgIGhlaWdodDogc2Nyb2xsaW5nQ29udGFpbmVyLmNsaWVudEhlaWdodCxcbiAgICB3aWR0aDogc2Nyb2xsaW5nQ29udGFpbmVyLmNsaWVudFdpZHRoXG4gIH07XG4gIGNvbnN0IG1heFNjcm9sbCA9IHtcbiAgICB4OiBzY3JvbGxpbmdDb250YWluZXIuc2Nyb2xsV2lkdGggLSBkaW1lbnNpb25zLndpZHRoLFxuICAgIHk6IHNjcm9sbGluZ0NvbnRhaW5lci5zY3JvbGxIZWlnaHQgLSBkaW1lbnNpb25zLmhlaWdodFxuICB9O1xuICBjb25zdCBpc1RvcCA9IHNjcm9sbGluZ0NvbnRhaW5lci5zY3JvbGxUb3AgPD0gbWluU2Nyb2xsLnk7XG4gIGNvbnN0IGlzTGVmdCA9IHNjcm9sbGluZ0NvbnRhaW5lci5zY3JvbGxMZWZ0IDw9IG1pblNjcm9sbC54O1xuICBjb25zdCBpc0JvdHRvbSA9IHNjcm9sbGluZ0NvbnRhaW5lci5zY3JvbGxUb3AgPj0gbWF4U2Nyb2xsLnk7XG4gIGNvbnN0IGlzUmlnaHQgPSBzY3JvbGxpbmdDb250YWluZXIuc2Nyb2xsTGVmdCA+PSBtYXhTY3JvbGwueDtcbiAgcmV0dXJuIHtcbiAgICBpc1RvcCxcbiAgICBpc0xlZnQsXG4gICAgaXNCb3R0b20sXG4gICAgaXNSaWdodCxcbiAgICBtYXhTY3JvbGwsXG4gICAgbWluU2Nyb2xsXG4gIH07XG59XG5cbmNvbnN0IGRlZmF1bHRUaHJlc2hvbGQgPSB7XG4gIHg6IDAuMixcbiAgeTogMC4yXG59O1xuZnVuY3Rpb24gZ2V0U2Nyb2xsRGlyZWN0aW9uQW5kU3BlZWQoc2Nyb2xsQ29udGFpbmVyLCBzY3JvbGxDb250YWluZXJSZWN0LCBfcmVmLCBhY2NlbGVyYXRpb24sIHRocmVzaG9sZFBlcmNlbnRhZ2UpIHtcbiAgbGV0IHtcbiAgICB0b3AsXG4gICAgbGVmdCxcbiAgICByaWdodCxcbiAgICBib3R0b21cbiAgfSA9IF9yZWY7XG5cbiAgaWYgKGFjY2VsZXJhdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgYWNjZWxlcmF0aW9uID0gMTA7XG4gIH1cblxuICBpZiAodGhyZXNob2xkUGVyY2VudGFnZSA9PT0gdm9pZCAwKSB7XG4gICAgdGhyZXNob2xkUGVyY2VudGFnZSA9IGRlZmF1bHRUaHJlc2hvbGQ7XG4gIH1cblxuICBjb25zdCB7XG4gICAgaXNUb3AsXG4gICAgaXNCb3R0b20sXG4gICAgaXNMZWZ0LFxuICAgIGlzUmlnaHRcbiAgfSA9IGdldFNjcm9sbFBvc2l0aW9uKHNjcm9sbENvbnRhaW5lcik7XG4gIGNvbnN0IGRpcmVjdGlvbiA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcbiAgY29uc3Qgc3BlZWQgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG4gIGNvbnN0IHRocmVzaG9sZCA9IHtcbiAgICBoZWlnaHQ6IHNjcm9sbENvbnRhaW5lclJlY3QuaGVpZ2h0ICogdGhyZXNob2xkUGVyY2VudGFnZS55LFxuICAgIHdpZHRoOiBzY3JvbGxDb250YWluZXJSZWN0LndpZHRoICogdGhyZXNob2xkUGVyY2VudGFnZS54XG4gIH07XG5cbiAgaWYgKCFpc1RvcCAmJiB0b3AgPD0gc2Nyb2xsQ29udGFpbmVyUmVjdC50b3AgKyB0aHJlc2hvbGQuaGVpZ2h0KSB7XG4gICAgLy8gU2Nyb2xsIFVwXG4gICAgZGlyZWN0aW9uLnkgPSBEaXJlY3Rpb24uQmFja3dhcmQ7XG4gICAgc3BlZWQueSA9IGFjY2VsZXJhdGlvbiAqIE1hdGguYWJzKChzY3JvbGxDb250YWluZXJSZWN0LnRvcCArIHRocmVzaG9sZC5oZWlnaHQgLSB0b3ApIC8gdGhyZXNob2xkLmhlaWdodCk7XG4gIH0gZWxzZSBpZiAoIWlzQm90dG9tICYmIGJvdHRvbSA+PSBzY3JvbGxDb250YWluZXJSZWN0LmJvdHRvbSAtIHRocmVzaG9sZC5oZWlnaHQpIHtcbiAgICAvLyBTY3JvbGwgRG93blxuICAgIGRpcmVjdGlvbi55ID0gRGlyZWN0aW9uLkZvcndhcmQ7XG4gICAgc3BlZWQueSA9IGFjY2VsZXJhdGlvbiAqIE1hdGguYWJzKChzY3JvbGxDb250YWluZXJSZWN0LmJvdHRvbSAtIHRocmVzaG9sZC5oZWlnaHQgLSBib3R0b20pIC8gdGhyZXNob2xkLmhlaWdodCk7XG4gIH1cblxuICBpZiAoIWlzUmlnaHQgJiYgcmlnaHQgPj0gc2Nyb2xsQ29udGFpbmVyUmVjdC5yaWdodCAtIHRocmVzaG9sZC53aWR0aCkge1xuICAgIC8vIFNjcm9sbCBSaWdodFxuICAgIGRpcmVjdGlvbi54ID0gRGlyZWN0aW9uLkZvcndhcmQ7XG4gICAgc3BlZWQueCA9IGFjY2VsZXJhdGlvbiAqIE1hdGguYWJzKChzY3JvbGxDb250YWluZXJSZWN0LnJpZ2h0IC0gdGhyZXNob2xkLndpZHRoIC0gcmlnaHQpIC8gdGhyZXNob2xkLndpZHRoKTtcbiAgfSBlbHNlIGlmICghaXNMZWZ0ICYmIGxlZnQgPD0gc2Nyb2xsQ29udGFpbmVyUmVjdC5sZWZ0ICsgdGhyZXNob2xkLndpZHRoKSB7XG4gICAgLy8gU2Nyb2xsIExlZnRcbiAgICBkaXJlY3Rpb24ueCA9IERpcmVjdGlvbi5CYWNrd2FyZDtcbiAgICBzcGVlZC54ID0gYWNjZWxlcmF0aW9uICogTWF0aC5hYnMoKHNjcm9sbENvbnRhaW5lclJlY3QubGVmdCArIHRocmVzaG9sZC53aWR0aCAtIGxlZnQpIC8gdGhyZXNob2xkLndpZHRoKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZGlyZWN0aW9uLFxuICAgIHNwZWVkXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFNjcm9sbEVsZW1lbnRSZWN0KGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT09IGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBpbm5lcldpZHRoLFxuICAgICAgaW5uZXJIZWlnaHRcbiAgICB9ID0gd2luZG93O1xuICAgIHJldHVybiB7XG4gICAgICB0b3A6IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IGlubmVyV2lkdGgsXG4gICAgICBib3R0b206IGlubmVySGVpZ2h0LFxuICAgICAgd2lkdGg6IGlubmVyV2lkdGgsXG4gICAgICBoZWlnaHQ6IGlubmVySGVpZ2h0XG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICB0b3AsXG4gICAgbGVmdCxcbiAgICByaWdodCxcbiAgICBib3R0b21cbiAgfSA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiB7XG4gICAgdG9wLFxuICAgIGxlZnQsXG4gICAgcmlnaHQsXG4gICAgYm90dG9tLFxuICAgIHdpZHRoOiBlbGVtZW50LmNsaWVudFdpZHRoLFxuICAgIGhlaWdodDogZWxlbWVudC5jbGllbnRIZWlnaHRcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsT2Zmc2V0cyhzY3JvbGxhYmxlQW5jZXN0b3JzKSB7XG4gIHJldHVybiBzY3JvbGxhYmxlQW5jZXN0b3JzLnJlZHVjZSgoYWNjLCBub2RlKSA9PiB7XG4gICAgcmV0dXJuIGFkZChhY2MsIGdldFNjcm9sbENvb3JkaW5hdGVzKG5vZGUpKTtcbiAgfSwgZGVmYXVsdENvb3JkaW5hdGVzKTtcbn1cbmZ1bmN0aW9uIGdldFNjcm9sbFhPZmZzZXQoc2Nyb2xsYWJsZUFuY2VzdG9ycykge1xuICByZXR1cm4gc2Nyb2xsYWJsZUFuY2VzdG9ycy5yZWR1Y2UoKGFjYywgbm9kZSkgPT4ge1xuICAgIHJldHVybiBhY2MgKyBnZXRTY3JvbGxYQ29vcmRpbmF0ZShub2RlKTtcbiAgfSwgMCk7XG59XG5mdW5jdGlvbiBnZXRTY3JvbGxZT2Zmc2V0KHNjcm9sbGFibGVBbmNlc3RvcnMpIHtcbiAgcmV0dXJuIHNjcm9sbGFibGVBbmNlc3RvcnMucmVkdWNlKChhY2MsIG5vZGUpID0+IHtcbiAgICByZXR1cm4gYWNjICsgZ2V0U2Nyb2xsWUNvb3JkaW5hdGUobm9kZSk7XG4gIH0sIDApO1xufVxuXG5mdW5jdGlvbiBzY3JvbGxJbnRvVmlld0lmTmVlZGVkKGVsZW1lbnQsIG1lYXN1cmUpIHtcbiAgaWYgKG1lYXN1cmUgPT09IHZvaWQgMCkge1xuICAgIG1lYXN1cmUgPSBnZXRDbGllbnRSZWN0O1xuICB9XG5cbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIHRvcCxcbiAgICBsZWZ0LFxuICAgIGJvdHRvbSxcbiAgICByaWdodFxuICB9ID0gbWVhc3VyZShlbGVtZW50KTtcbiAgY29uc3QgZmlyc3RTY3JvbGxhYmxlQW5jZXN0b3IgPSBnZXRGaXJzdFNjcm9sbGFibGVBbmNlc3RvcihlbGVtZW50KTtcblxuICBpZiAoIWZpcnN0U2Nyb2xsYWJsZUFuY2VzdG9yKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGJvdHRvbSA8PSAwIHx8IHJpZ2h0IDw9IDAgfHwgdG9wID49IHdpbmRvdy5pbm5lckhlaWdodCB8fCBsZWZ0ID49IHdpbmRvdy5pbm5lcldpZHRoKSB7XG4gICAgZWxlbWVudC5zY3JvbGxJbnRvVmlldyh7XG4gICAgICBibG9jazogJ2NlbnRlcicsXG4gICAgICBpbmxpbmU6ICdjZW50ZXInXG4gICAgfSk7XG4gIH1cbn1cblxuY29uc3QgcHJvcGVydGllcyA9IFtbJ3gnLCBbJ2xlZnQnLCAncmlnaHQnXSwgZ2V0U2Nyb2xsWE9mZnNldF0sIFsneScsIFsndG9wJywgJ2JvdHRvbSddLCBnZXRTY3JvbGxZT2Zmc2V0XV07XG5jbGFzcyBSZWN0IHtcbiAgY29uc3RydWN0b3IocmVjdCwgZWxlbWVudCkge1xuICAgIHRoaXMucmVjdCA9IHZvaWQgMDtcbiAgICB0aGlzLndpZHRoID0gdm9pZCAwO1xuICAgIHRoaXMuaGVpZ2h0ID0gdm9pZCAwO1xuICAgIHRoaXMudG9wID0gdm9pZCAwO1xuICAgIHRoaXMuYm90dG9tID0gdm9pZCAwO1xuICAgIHRoaXMucmlnaHQgPSB2b2lkIDA7XG4gICAgdGhpcy5sZWZ0ID0gdm9pZCAwO1xuICAgIGNvbnN0IHNjcm9sbGFibGVBbmNlc3RvcnMgPSBnZXRTY3JvbGxhYmxlQW5jZXN0b3JzKGVsZW1lbnQpO1xuICAgIGNvbnN0IHNjcm9sbE9mZnNldHMgPSBnZXRTY3JvbGxPZmZzZXRzKHNjcm9sbGFibGVBbmNlc3RvcnMpO1xuICAgIHRoaXMucmVjdCA9IHsgLi4ucmVjdFxuICAgIH07XG4gICAgdGhpcy53aWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSByZWN0LmhlaWdodDtcblxuICAgIGZvciAoY29uc3QgW2F4aXMsIGtleXMsIGdldFNjcm9sbE9mZnNldF0gb2YgcHJvcGVydGllcykge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG4gICAgICAgICAgZ2V0OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50T2Zmc2V0cyA9IGdldFNjcm9sbE9mZnNldChzY3JvbGxhYmxlQW5jZXN0b3JzKTtcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbE9mZnNldHNEZWx0bGEgPSBzY3JvbGxPZmZzZXRzW2F4aXNdIC0gY3VycmVudE9mZnNldHM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWN0W2tleV0gKyBzY3JvbGxPZmZzZXRzRGVsdGxhO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3JlY3QnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgIH0pO1xuICB9XG5cbn1cblxuY2xhc3MgTGlzdGVuZXJzIHtcbiAgY29uc3RydWN0b3IodGFyZ2V0KSB7XG4gICAgdGhpcy50YXJnZXQgPSB2b2lkIDA7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcblxuICAgIHRoaXMucmVtb3ZlQWxsID0gKCkgPT4ge1xuICAgICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiB7XG4gICAgICAgIHZhciBfdGhpcyR0YXJnZXQ7XG5cbiAgICAgICAgcmV0dXJuIChfdGhpcyR0YXJnZXQgPSB0aGlzLnRhcmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKC4uLmxpc3RlbmVyKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgfVxuXG4gIGFkZChldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMkdGFyZ2V0MjtcblxuICAgIChfdGhpcyR0YXJnZXQyID0gdGhpcy50YXJnZXQpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyR0YXJnZXQyLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICB0aGlzLmxpc3RlbmVycy5wdXNoKFtldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnNdKTtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIGdldEV2ZW50TGlzdGVuZXJUYXJnZXQodGFyZ2V0KSB7XG4gIC8vIElmIHRoZSBgZXZlbnQudGFyZ2V0YCBlbGVtZW50IGlzIHJlbW92ZWQgZnJvbSB0aGUgZG9jdW1lbnQgZXZlbnRzIHdpbGwgc3RpbGwgYmUgdGFyZ2V0ZWRcbiAgLy8gYXQgaXQsIGFuZCBoZW5jZSB3b24ndCBhbHdheXMgYnViYmxlIHVwIHRvIHRoZSB3aW5kb3cgb3IgZG9jdW1lbnQgYW55bW9yZS5cbiAgLy8gSWYgdGhlcmUgaXMgYW55IHJpc2sgb2YgYW4gZWxlbWVudCBiZWluZyByZW1vdmVkIHdoaWxlIGl0IGlzIGJlaW5nIGRyYWdnZWQsXG4gIC8vIHRoZSBiZXN0IHByYWN0aWNlIGlzIHRvIGF0dGFjaCB0aGUgZXZlbnQgbGlzdGVuZXJzIGRpcmVjdGx5IHRvIHRoZSB0YXJnZXQuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldFxuICBjb25zdCB7XG4gICAgRXZlbnRUYXJnZXRcbiAgfSA9IGdldFdpbmRvdyh0YXJnZXQpO1xuICByZXR1cm4gdGFyZ2V0IGluc3RhbmNlb2YgRXZlbnRUYXJnZXQgPyB0YXJnZXQgOiBnZXRPd25lckRvY3VtZW50KHRhcmdldCk7XG59XG5cbmZ1bmN0aW9uIGhhc0V4Y2VlZGVkRGlzdGFuY2UoZGVsdGEsIG1lYXN1cmVtZW50KSB7XG4gIGNvbnN0IGR4ID0gTWF0aC5hYnMoZGVsdGEueCk7XG4gIGNvbnN0IGR5ID0gTWF0aC5hYnMoZGVsdGEueSk7XG5cbiAgaWYgKHR5cGVvZiBtZWFzdXJlbWVudCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KGR4ICoqIDIgKyBkeSAqKiAyKSA+IG1lYXN1cmVtZW50O1xuICB9XG5cbiAgaWYgKCd4JyBpbiBtZWFzdXJlbWVudCAmJiAneScgaW4gbWVhc3VyZW1lbnQpIHtcbiAgICByZXR1cm4gZHggPiBtZWFzdXJlbWVudC54ICYmIGR5ID4gbWVhc3VyZW1lbnQueTtcbiAgfVxuXG4gIGlmICgneCcgaW4gbWVhc3VyZW1lbnQpIHtcbiAgICByZXR1cm4gZHggPiBtZWFzdXJlbWVudC54O1xuICB9XG5cbiAgaWYgKCd5JyBpbiBtZWFzdXJlbWVudCkge1xuICAgIHJldHVybiBkeSA+IG1lYXN1cmVtZW50Lnk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBFdmVudE5hbWU7XG5cbihmdW5jdGlvbiAoRXZlbnROYW1lKSB7XG4gIEV2ZW50TmFtZVtcIkNsaWNrXCJdID0gXCJjbGlja1wiO1xuICBFdmVudE5hbWVbXCJEcmFnU3RhcnRcIl0gPSBcImRyYWdzdGFydFwiO1xuICBFdmVudE5hbWVbXCJLZXlkb3duXCJdID0gXCJrZXlkb3duXCI7XG4gIEV2ZW50TmFtZVtcIkNvbnRleHRNZW51XCJdID0gXCJjb250ZXh0bWVudVwiO1xuICBFdmVudE5hbWVbXCJSZXNpemVcIl0gPSBcInJlc2l6ZVwiO1xuICBFdmVudE5hbWVbXCJTZWxlY3Rpb25DaGFuZ2VcIl0gPSBcInNlbGVjdGlvbmNoYW5nZVwiO1xuICBFdmVudE5hbWVbXCJWaXNpYmlsaXR5Q2hhbmdlXCJdID0gXCJ2aXNpYmlsaXR5Y2hhbmdlXCI7XG59KShFdmVudE5hbWUgfHwgKEV2ZW50TmFtZSA9IHt9KSk7XG5cbmZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2ZW50KSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG59XG5mdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oZXZlbnQpIHtcbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG59XG5cbnZhciBLZXlib2FyZENvZGU7XG5cbihmdW5jdGlvbiAoS2V5Ym9hcmRDb2RlKSB7XG4gIEtleWJvYXJkQ29kZVtcIlNwYWNlXCJdID0gXCJTcGFjZVwiO1xuICBLZXlib2FyZENvZGVbXCJEb3duXCJdID0gXCJBcnJvd0Rvd25cIjtcbiAgS2V5Ym9hcmRDb2RlW1wiUmlnaHRcIl0gPSBcIkFycm93UmlnaHRcIjtcbiAgS2V5Ym9hcmRDb2RlW1wiTGVmdFwiXSA9IFwiQXJyb3dMZWZ0XCI7XG4gIEtleWJvYXJkQ29kZVtcIlVwXCJdID0gXCJBcnJvd1VwXCI7XG4gIEtleWJvYXJkQ29kZVtcIkVzY1wiXSA9IFwiRXNjYXBlXCI7XG4gIEtleWJvYXJkQ29kZVtcIkVudGVyXCJdID0gXCJFbnRlclwiO1xufSkoS2V5Ym9hcmRDb2RlIHx8IChLZXlib2FyZENvZGUgPSB7fSkpO1xuXG5jb25zdCBkZWZhdWx0S2V5Ym9hcmRDb2RlcyA9IHtcbiAgc3RhcnQ6IFtLZXlib2FyZENvZGUuU3BhY2UsIEtleWJvYXJkQ29kZS5FbnRlcl0sXG4gIGNhbmNlbDogW0tleWJvYXJkQ29kZS5Fc2NdLFxuICBlbmQ6IFtLZXlib2FyZENvZGUuU3BhY2UsIEtleWJvYXJkQ29kZS5FbnRlcl1cbn07XG5jb25zdCBkZWZhdWx0S2V5Ym9hcmRDb29yZGluYXRlR2V0dGVyID0gKGV2ZW50LCBfcmVmKSA9PiB7XG4gIGxldCB7XG4gICAgY3VycmVudENvb3JkaW5hdGVzXG4gIH0gPSBfcmVmO1xuXG4gIHN3aXRjaCAoZXZlbnQuY29kZSkge1xuICAgIGNhc2UgS2V5Ym9hcmRDb2RlLlJpZ2h0OlxuICAgICAgcmV0dXJuIHsgLi4uY3VycmVudENvb3JkaW5hdGVzLFxuICAgICAgICB4OiBjdXJyZW50Q29vcmRpbmF0ZXMueCArIDI1XG4gICAgICB9O1xuXG4gICAgY2FzZSBLZXlib2FyZENvZGUuTGVmdDpcbiAgICAgIHJldHVybiB7IC4uLmN1cnJlbnRDb29yZGluYXRlcyxcbiAgICAgICAgeDogY3VycmVudENvb3JkaW5hdGVzLnggLSAyNVxuICAgICAgfTtcblxuICAgIGNhc2UgS2V5Ym9hcmRDb2RlLkRvd246XG4gICAgICByZXR1cm4geyAuLi5jdXJyZW50Q29vcmRpbmF0ZXMsXG4gICAgICAgIHk6IGN1cnJlbnRDb29yZGluYXRlcy55ICsgMjVcbiAgICAgIH07XG5cbiAgICBjYXNlIEtleWJvYXJkQ29kZS5VcDpcbiAgICAgIHJldHVybiB7IC4uLmN1cnJlbnRDb29yZGluYXRlcyxcbiAgICAgICAgeTogY3VycmVudENvb3JkaW5hdGVzLnkgLSAyNVxuICAgICAgfTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG5jbGFzcyBLZXlib2FyZFNlbnNvciB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgdGhpcy5wcm9wcyA9IHZvaWQgMDtcbiAgICB0aGlzLmF1dG9TY3JvbGxFbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5yZWZlcmVuY2VDb29yZGluYXRlcyA9IHZvaWQgMDtcbiAgICB0aGlzLmxpc3RlbmVycyA9IHZvaWQgMDtcbiAgICB0aGlzLndpbmRvd0xpc3RlbmVycyA9IHZvaWQgMDtcbiAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgY29uc3Qge1xuICAgICAgZXZlbnQ6IHtcbiAgICAgICAgdGFyZ2V0XG4gICAgICB9XG4gICAgfSA9IHByb3BzO1xuICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICB0aGlzLmxpc3RlbmVycyA9IG5ldyBMaXN0ZW5lcnMoZ2V0T3duZXJEb2N1bWVudCh0YXJnZXQpKTtcbiAgICB0aGlzLndpbmRvd0xpc3RlbmVycyA9IG5ldyBMaXN0ZW5lcnMoZ2V0V2luZG93KHRhcmdldCkpO1xuICAgIHRoaXMuaGFuZGxlS2V5RG93biA9IHRoaXMuaGFuZGxlS2V5RG93bi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuaGFuZGxlQ2FuY2VsID0gdGhpcy5oYW5kbGVDYW5jZWwuYmluZCh0aGlzKTtcbiAgICB0aGlzLmF0dGFjaCgpO1xuICB9XG5cbiAgYXR0YWNoKCkge1xuICAgIHRoaXMuaGFuZGxlU3RhcnQoKTtcbiAgICB0aGlzLndpbmRvd0xpc3RlbmVycy5hZGQoRXZlbnROYW1lLlJlc2l6ZSwgdGhpcy5oYW5kbGVDYW5jZWwpO1xuICAgIHRoaXMud2luZG93TGlzdGVuZXJzLmFkZChFdmVudE5hbWUuVmlzaWJpbGl0eUNoYW5nZSwgdGhpcy5oYW5kbGVDYW5jZWwpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5saXN0ZW5lcnMuYWRkKEV2ZW50TmFtZS5LZXlkb3duLCB0aGlzLmhhbmRsZUtleURvd24pKTtcbiAgfVxuXG4gIGhhbmRsZVN0YXJ0KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGFjdGl2ZU5vZGUsXG4gICAgICBvblN0YXJ0XG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qgbm9kZSA9IGFjdGl2ZU5vZGUubm9kZS5jdXJyZW50O1xuXG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIHNjcm9sbEludG9WaWV3SWZOZWVkZWQobm9kZSk7XG4gICAgfVxuXG4gICAgb25TdGFydChkZWZhdWx0Q29vcmRpbmF0ZXMpO1xuICB9XG5cbiAgaGFuZGxlS2V5RG93bihldmVudCkge1xuICAgIGlmIChpc0tleWJvYXJkRXZlbnQoZXZlbnQpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFjdGl2ZSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGtleWJvYXJkQ29kZXMgPSBkZWZhdWx0S2V5Ym9hcmRDb2RlcyxcbiAgICAgICAgY29vcmRpbmF0ZUdldHRlciA9IGRlZmF1bHRLZXlib2FyZENvb3JkaW5hdGVHZXR0ZXIsXG4gICAgICAgIHNjcm9sbEJlaGF2aW9yID0gJ3Ntb290aCdcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb2RlXG4gICAgICB9ID0gZXZlbnQ7XG5cbiAgICAgIGlmIChrZXlib2FyZENvZGVzLmVuZC5pbmNsdWRlcyhjb2RlKSkge1xuICAgICAgICB0aGlzLmhhbmRsZUVuZChldmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGtleWJvYXJkQ29kZXMuY2FuY2VsLmluY2x1ZGVzKGNvZGUpKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlQ2FuY2VsKGV2ZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbGxpc2lvblJlY3RcbiAgICAgIH0gPSBjb250ZXh0LmN1cnJlbnQ7XG4gICAgICBjb25zdCBjdXJyZW50Q29vcmRpbmF0ZXMgPSBjb2xsaXNpb25SZWN0ID8ge1xuICAgICAgICB4OiBjb2xsaXNpb25SZWN0LmxlZnQsXG4gICAgICAgIHk6IGNvbGxpc2lvblJlY3QudG9wXG4gICAgICB9IDogZGVmYXVsdENvb3JkaW5hdGVzO1xuXG4gICAgICBpZiAoIXRoaXMucmVmZXJlbmNlQ29vcmRpbmF0ZXMpIHtcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VDb29yZGluYXRlcyA9IGN1cnJlbnRDb29yZGluYXRlcztcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV3Q29vcmRpbmF0ZXMgPSBjb29yZGluYXRlR2V0dGVyKGV2ZW50LCB7XG4gICAgICAgIGFjdGl2ZSxcbiAgICAgICAgY29udGV4dDogY29udGV4dC5jdXJyZW50LFxuICAgICAgICBjdXJyZW50Q29vcmRpbmF0ZXNcbiAgICAgIH0pO1xuXG4gICAgICBpZiAobmV3Q29vcmRpbmF0ZXMpIHtcbiAgICAgICAgY29uc3QgY29vcmRpbmF0ZXNEZWx0YSA9IHN1YnRyYWN0KG5ld0Nvb3JkaW5hdGVzLCBjdXJyZW50Q29vcmRpbmF0ZXMpO1xuICAgICAgICBjb25zdCBzY3JvbGxEZWx0YSA9IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHNjcm9sbGFibGVBbmNlc3RvcnNcbiAgICAgICAgfSA9IGNvbnRleHQuY3VycmVudDtcblxuICAgICAgICBmb3IgKGNvbnN0IHNjcm9sbENvbnRhaW5lciBvZiBzY3JvbGxhYmxlQW5jZXN0b3JzKSB7XG4gICAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gZXZlbnQuY29kZTtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBpc1RvcCxcbiAgICAgICAgICAgIGlzUmlnaHQsXG4gICAgICAgICAgICBpc0xlZnQsXG4gICAgICAgICAgICBpc0JvdHRvbSxcbiAgICAgICAgICAgIG1heFNjcm9sbCxcbiAgICAgICAgICAgIG1pblNjcm9sbFxuICAgICAgICAgIH0gPSBnZXRTY3JvbGxQb3NpdGlvbihzY3JvbGxDb250YWluZXIpO1xuICAgICAgICAgIGNvbnN0IHNjcm9sbEVsZW1lbnRSZWN0ID0gZ2V0U2Nyb2xsRWxlbWVudFJlY3Qoc2Nyb2xsQ29udGFpbmVyKTtcbiAgICAgICAgICBjb25zdCBjbGFtcGVkQ29vcmRpbmF0ZXMgPSB7XG4gICAgICAgICAgICB4OiBNYXRoLm1pbihkaXJlY3Rpb24gPT09IEtleWJvYXJkQ29kZS5SaWdodCA/IHNjcm9sbEVsZW1lbnRSZWN0LnJpZ2h0IC0gc2Nyb2xsRWxlbWVudFJlY3Qud2lkdGggLyAyIDogc2Nyb2xsRWxlbWVudFJlY3QucmlnaHQsIE1hdGgubWF4KGRpcmVjdGlvbiA9PT0gS2V5Ym9hcmRDb2RlLlJpZ2h0ID8gc2Nyb2xsRWxlbWVudFJlY3QubGVmdCA6IHNjcm9sbEVsZW1lbnRSZWN0LmxlZnQgKyBzY3JvbGxFbGVtZW50UmVjdC53aWR0aCAvIDIsIG5ld0Nvb3JkaW5hdGVzLngpKSxcbiAgICAgICAgICAgIHk6IE1hdGgubWluKGRpcmVjdGlvbiA9PT0gS2V5Ym9hcmRDb2RlLkRvd24gPyBzY3JvbGxFbGVtZW50UmVjdC5ib3R0b20gLSBzY3JvbGxFbGVtZW50UmVjdC5oZWlnaHQgLyAyIDogc2Nyb2xsRWxlbWVudFJlY3QuYm90dG9tLCBNYXRoLm1heChkaXJlY3Rpb24gPT09IEtleWJvYXJkQ29kZS5Eb3duID8gc2Nyb2xsRWxlbWVudFJlY3QudG9wIDogc2Nyb2xsRWxlbWVudFJlY3QudG9wICsgc2Nyb2xsRWxlbWVudFJlY3QuaGVpZ2h0IC8gMiwgbmV3Q29vcmRpbmF0ZXMueSkpXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zdCBjYW5TY3JvbGxYID0gZGlyZWN0aW9uID09PSBLZXlib2FyZENvZGUuUmlnaHQgJiYgIWlzUmlnaHQgfHwgZGlyZWN0aW9uID09PSBLZXlib2FyZENvZGUuTGVmdCAmJiAhaXNMZWZ0O1xuICAgICAgICAgIGNvbnN0IGNhblNjcm9sbFkgPSBkaXJlY3Rpb24gPT09IEtleWJvYXJkQ29kZS5Eb3duICYmICFpc0JvdHRvbSB8fCBkaXJlY3Rpb24gPT09IEtleWJvYXJkQ29kZS5VcCAmJiAhaXNUb3A7XG5cbiAgICAgICAgICBpZiAoY2FuU2Nyb2xsWCAmJiBjbGFtcGVkQ29vcmRpbmF0ZXMueCAhPT0gbmV3Q29vcmRpbmF0ZXMueCkge1xuICAgICAgICAgICAgY29uc3QgbmV3U2Nyb2xsQ29vcmRpbmF0ZXMgPSBzY3JvbGxDb250YWluZXIuc2Nyb2xsTGVmdCArIGNvb3JkaW5hdGVzRGVsdGEueDtcbiAgICAgICAgICAgIGNvbnN0IGNhblNjcm9sbFRvTmV3Q29vcmRpbmF0ZXMgPSBkaXJlY3Rpb24gPT09IEtleWJvYXJkQ29kZS5SaWdodCAmJiBuZXdTY3JvbGxDb29yZGluYXRlcyA8PSBtYXhTY3JvbGwueCB8fCBkaXJlY3Rpb24gPT09IEtleWJvYXJkQ29kZS5MZWZ0ICYmIG5ld1Njcm9sbENvb3JkaW5hdGVzID49IG1pblNjcm9sbC54O1xuXG4gICAgICAgICAgICBpZiAoY2FuU2Nyb2xsVG9OZXdDb29yZGluYXRlcyAmJiAhY29vcmRpbmF0ZXNEZWx0YS55KSB7XG4gICAgICAgICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gdXBkYXRlIGNvb3JkaW5hdGVzLCB0aGUgc2Nyb2xsIGFkanVzdG1lbnQgYWxvbmUgd2lsbCB0cmlnZ2VyXG4gICAgICAgICAgICAgIC8vIGxvZ2ljIHRvIGF1dG8tZGV0ZWN0IHRoZSBuZXcgY29udGFpbmVyIHdlIGFyZSBvdmVyXG4gICAgICAgICAgICAgIHNjcm9sbENvbnRhaW5lci5zY3JvbGxUbyh7XG4gICAgICAgICAgICAgICAgbGVmdDogbmV3U2Nyb2xsQ29vcmRpbmF0ZXMsXG4gICAgICAgICAgICAgICAgYmVoYXZpb3I6IHNjcm9sbEJlaGF2aW9yXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjYW5TY3JvbGxUb05ld0Nvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICAgIHNjcm9sbERlbHRhLnggPSBzY3JvbGxDb250YWluZXIuc2Nyb2xsTGVmdCAtIG5ld1Njcm9sbENvb3JkaW5hdGVzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2Nyb2xsRGVsdGEueCA9IGRpcmVjdGlvbiA9PT0gS2V5Ym9hcmRDb2RlLlJpZ2h0ID8gc2Nyb2xsQ29udGFpbmVyLnNjcm9sbExlZnQgLSBtYXhTY3JvbGwueCA6IHNjcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0IC0gbWluU2Nyb2xsLng7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzY3JvbGxEZWx0YS54KSB7XG4gICAgICAgICAgICAgIHNjcm9sbENvbnRhaW5lci5zY3JvbGxCeSh7XG4gICAgICAgICAgICAgICAgbGVmdDogLXNjcm9sbERlbHRhLngsXG4gICAgICAgICAgICAgICAgYmVoYXZpb3I6IHNjcm9sbEJlaGF2aW9yXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2UgaWYgKGNhblNjcm9sbFkgJiYgY2xhbXBlZENvb3JkaW5hdGVzLnkgIT09IG5ld0Nvb3JkaW5hdGVzLnkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1Njcm9sbENvb3JkaW5hdGVzID0gc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcCArIGNvb3JkaW5hdGVzRGVsdGEueTtcbiAgICAgICAgICAgIGNvbnN0IGNhblNjcm9sbFRvTmV3Q29vcmRpbmF0ZXMgPSBkaXJlY3Rpb24gPT09IEtleWJvYXJkQ29kZS5Eb3duICYmIG5ld1Njcm9sbENvb3JkaW5hdGVzIDw9IG1heFNjcm9sbC55IHx8IGRpcmVjdGlvbiA9PT0gS2V5Ym9hcmRDb2RlLlVwICYmIG5ld1Njcm9sbENvb3JkaW5hdGVzID49IG1pblNjcm9sbC55O1xuXG4gICAgICAgICAgICBpZiAoY2FuU2Nyb2xsVG9OZXdDb29yZGluYXRlcyAmJiAhY29vcmRpbmF0ZXNEZWx0YS54KSB7XG4gICAgICAgICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gdXBkYXRlIGNvb3JkaW5hdGVzLCB0aGUgc2Nyb2xsIGFkanVzdG1lbnQgYWxvbmUgd2lsbCB0cmlnZ2VyXG4gICAgICAgICAgICAgIC8vIGxvZ2ljIHRvIGF1dG8tZGV0ZWN0IHRoZSBuZXcgY29udGFpbmVyIHdlIGFyZSBvdmVyXG4gICAgICAgICAgICAgIHNjcm9sbENvbnRhaW5lci5zY3JvbGxUbyh7XG4gICAgICAgICAgICAgICAgdG9wOiBuZXdTY3JvbGxDb29yZGluYXRlcyxcbiAgICAgICAgICAgICAgICBiZWhhdmlvcjogc2Nyb2xsQmVoYXZpb3JcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNhblNjcm9sbFRvTmV3Q29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICAgICAgc2Nyb2xsRGVsdGEueSA9IHNjcm9sbENvbnRhaW5lci5zY3JvbGxUb3AgLSBuZXdTY3JvbGxDb29yZGluYXRlcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNjcm9sbERlbHRhLnkgPSBkaXJlY3Rpb24gPT09IEtleWJvYXJkQ29kZS5Eb3duID8gc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcCAtIG1heFNjcm9sbC55IDogc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcCAtIG1pblNjcm9sbC55O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2Nyb2xsRGVsdGEueSkge1xuICAgICAgICAgICAgICBzY3JvbGxDb250YWluZXIuc2Nyb2xsQnkoe1xuICAgICAgICAgICAgICAgIHRvcDogLXNjcm9sbERlbHRhLnksXG4gICAgICAgICAgICAgICAgYmVoYXZpb3I6IHNjcm9sbEJlaGF2aW9yXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmhhbmRsZU1vdmUoZXZlbnQsIGFkZChzdWJ0cmFjdChuZXdDb29yZGluYXRlcywgdGhpcy5yZWZlcmVuY2VDb29yZGluYXRlcyksIHNjcm9sbERlbHRhKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlTW92ZShldmVudCwgY29vcmRpbmF0ZXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBvbk1vdmVcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIG9uTW92ZShjb29yZGluYXRlcyk7XG4gIH1cblxuICBoYW5kbGVFbmQoZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBvbkVuZFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy5kZXRhY2goKTtcbiAgICBvbkVuZCgpO1xuICB9XG5cbiAgaGFuZGxlQ2FuY2VsKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgb25DYW5jZWxcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgb25DYW5jZWwoKTtcbiAgfVxuXG4gIGRldGFjaCgpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5yZW1vdmVBbGwoKTtcbiAgICB0aGlzLndpbmRvd0xpc3RlbmVycy5yZW1vdmVBbGwoKTtcbiAgfVxuXG59XG5LZXlib2FyZFNlbnNvci5hY3RpdmF0b3JzID0gW3tcbiAgZXZlbnROYW1lOiAnb25LZXlEb3duJyxcbiAgaGFuZGxlcjogKGV2ZW50LCBfcmVmLCBfcmVmMikgPT4ge1xuICAgIGxldCB7XG4gICAgICBrZXlib2FyZENvZGVzID0gZGVmYXVsdEtleWJvYXJkQ29kZXMsXG4gICAgICBvbkFjdGl2YXRpb25cbiAgICB9ID0gX3JlZjtcbiAgICBsZXQge1xuICAgICAgYWN0aXZlXG4gICAgfSA9IF9yZWYyO1xuICAgIGNvbnN0IHtcbiAgICAgIGNvZGVcbiAgICB9ID0gZXZlbnQubmF0aXZlRXZlbnQ7XG5cbiAgICBpZiAoa2V5Ym9hcmRDb2Rlcy5zdGFydC5pbmNsdWRlcyhjb2RlKSkge1xuICAgICAgY29uc3QgYWN0aXZhdG9yID0gYWN0aXZlLmFjdGl2YXRvck5vZGUuY3VycmVudDtcblxuICAgICAgaWYgKGFjdGl2YXRvciAmJiBldmVudC50YXJnZXQgIT09IGFjdGl2YXRvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBvbkFjdGl2YXRpb24gPT0gbnVsbCA/IHZvaWQgMCA6IG9uQWN0aXZhdGlvbih7XG4gICAgICAgIGV2ZW50OiBldmVudC5uYXRpdmVFdmVudFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1dO1xuXG5mdW5jdGlvbiBpc0Rpc3RhbmNlQ29uc3RyYWludChjb25zdHJhaW50KSB7XG4gIHJldHVybiBCb29sZWFuKGNvbnN0cmFpbnQgJiYgJ2Rpc3RhbmNlJyBpbiBjb25zdHJhaW50KTtcbn1cblxuZnVuY3Rpb24gaXNEZWxheUNvbnN0cmFpbnQoY29uc3RyYWludCkge1xuICByZXR1cm4gQm9vbGVhbihjb25zdHJhaW50ICYmICdkZWxheScgaW4gY29uc3RyYWludCk7XG59XG5cbmNsYXNzIEFic3RyYWN0UG9pbnRlclNlbnNvciB7XG4gIGNvbnN0cnVjdG9yKHByb3BzLCBldmVudHMsIGxpc3RlbmVyVGFyZ2V0KSB7XG4gICAgdmFyIF9nZXRFdmVudENvb3JkaW5hdGVzO1xuXG4gICAgaWYgKGxpc3RlbmVyVGFyZ2V0ID09PSB2b2lkIDApIHtcbiAgICAgIGxpc3RlbmVyVGFyZ2V0ID0gZ2V0RXZlbnRMaXN0ZW5lclRhcmdldChwcm9wcy5ldmVudC50YXJnZXQpO1xuICAgIH1cblxuICAgIHRoaXMucHJvcHMgPSB2b2lkIDA7XG4gICAgdGhpcy5ldmVudHMgPSB2b2lkIDA7XG4gICAgdGhpcy5hdXRvU2Nyb2xsRW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5kb2N1bWVudCA9IHZvaWQgMDtcbiAgICB0aGlzLmFjdGl2YXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuaW5pdGlhbENvb3JkaW5hdGVzID0gdm9pZCAwO1xuICAgIHRoaXMudGltZW91dElkID0gbnVsbDtcbiAgICB0aGlzLmxpc3RlbmVycyA9IHZvaWQgMDtcbiAgICB0aGlzLmRvY3VtZW50TGlzdGVuZXJzID0gdm9pZCAwO1xuICAgIHRoaXMud2luZG93TGlzdGVuZXJzID0gdm9pZCAwO1xuICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICB0aGlzLmV2ZW50cyA9IGV2ZW50cztcbiAgICBjb25zdCB7XG4gICAgICBldmVudFxuICAgIH0gPSBwcm9wcztcbiAgICBjb25zdCB7XG4gICAgICB0YXJnZXRcbiAgICB9ID0gZXZlbnQ7XG4gICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgIHRoaXMuZXZlbnRzID0gZXZlbnRzO1xuICAgIHRoaXMuZG9jdW1lbnQgPSBnZXRPd25lckRvY3VtZW50KHRhcmdldCk7XG4gICAgdGhpcy5kb2N1bWVudExpc3RlbmVycyA9IG5ldyBMaXN0ZW5lcnModGhpcy5kb2N1bWVudCk7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSBuZXcgTGlzdGVuZXJzKGxpc3RlbmVyVGFyZ2V0KTtcbiAgICB0aGlzLndpbmRvd0xpc3RlbmVycyA9IG5ldyBMaXN0ZW5lcnMoZ2V0V2luZG93KHRhcmdldCkpO1xuICAgIHRoaXMuaW5pdGlhbENvb3JkaW5hdGVzID0gKF9nZXRFdmVudENvb3JkaW5hdGVzID0gZ2V0RXZlbnRDb29yZGluYXRlcyhldmVudCkpICE9IG51bGwgPyBfZ2V0RXZlbnRDb29yZGluYXRlcyA6IGRlZmF1bHRDb29yZGluYXRlcztcbiAgICB0aGlzLmhhbmRsZVN0YXJ0ID0gdGhpcy5oYW5kbGVTdGFydC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuaGFuZGxlTW92ZSA9IHRoaXMuaGFuZGxlTW92ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuaGFuZGxlRW5kID0gdGhpcy5oYW5kbGVFbmQuYmluZCh0aGlzKTtcbiAgICB0aGlzLmhhbmRsZUNhbmNlbCA9IHRoaXMuaGFuZGxlQ2FuY2VsLmJpbmQodGhpcyk7XG4gICAgdGhpcy5oYW5kbGVLZXlkb3duID0gdGhpcy5oYW5kbGVLZXlkb3duLmJpbmQodGhpcyk7XG4gICAgdGhpcy5yZW1vdmVUZXh0U2VsZWN0aW9uID0gdGhpcy5yZW1vdmVUZXh0U2VsZWN0aW9uLmJpbmQodGhpcyk7XG4gICAgdGhpcy5hdHRhY2goKTtcbiAgfVxuXG4gIGF0dGFjaCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBldmVudHMsXG4gICAgICBwcm9wczoge1xuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgYWN0aXZhdGlvbkNvbnN0cmFpbnQsXG4gICAgICAgICAgYnlwYXNzQWN0aXZhdGlvbkNvbnN0cmFpbnRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIHRoaXMubGlzdGVuZXJzLmFkZChldmVudHMubW92ZS5uYW1lLCB0aGlzLmhhbmRsZU1vdmUsIHtcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfSk7XG4gICAgdGhpcy5saXN0ZW5lcnMuYWRkKGV2ZW50cy5lbmQubmFtZSwgdGhpcy5oYW5kbGVFbmQpO1xuICAgIHRoaXMud2luZG93TGlzdGVuZXJzLmFkZChFdmVudE5hbWUuUmVzaXplLCB0aGlzLmhhbmRsZUNhbmNlbCk7XG4gICAgdGhpcy53aW5kb3dMaXN0ZW5lcnMuYWRkKEV2ZW50TmFtZS5EcmFnU3RhcnQsIHByZXZlbnREZWZhdWx0KTtcbiAgICB0aGlzLndpbmRvd0xpc3RlbmVycy5hZGQoRXZlbnROYW1lLlZpc2liaWxpdHlDaGFuZ2UsIHRoaXMuaGFuZGxlQ2FuY2VsKTtcbiAgICB0aGlzLndpbmRvd0xpc3RlbmVycy5hZGQoRXZlbnROYW1lLkNvbnRleHRNZW51LCBwcmV2ZW50RGVmYXVsdCk7XG4gICAgdGhpcy5kb2N1bWVudExpc3RlbmVycy5hZGQoRXZlbnROYW1lLktleWRvd24sIHRoaXMuaGFuZGxlS2V5ZG93bik7XG5cbiAgICBpZiAoYWN0aXZhdGlvbkNvbnN0cmFpbnQpIHtcbiAgICAgIGlmIChieXBhc3NBY3RpdmF0aW9uQ29uc3RyYWludCAhPSBudWxsICYmIGJ5cGFzc0FjdGl2YXRpb25Db25zdHJhaW50KHtcbiAgICAgICAgZXZlbnQ6IHRoaXMucHJvcHMuZXZlbnQsXG4gICAgICAgIGFjdGl2ZU5vZGU6IHRoaXMucHJvcHMuYWN0aXZlTm9kZSxcbiAgICAgICAgb3B0aW9uczogdGhpcy5wcm9wcy5vcHRpb25zXG4gICAgICB9KSkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVTdGFydCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNEZWxheUNvbnN0cmFpbnQoYWN0aXZhdGlvbkNvbnN0cmFpbnQpKSB7XG4gICAgICAgIHRoaXMudGltZW91dElkID0gc2V0VGltZW91dCh0aGlzLmhhbmRsZVN0YXJ0LCBhY3RpdmF0aW9uQ29uc3RyYWludC5kZWxheSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRGlzdGFuY2VDb25zdHJhaW50KGFjdGl2YXRpb25Db25zdHJhaW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5oYW5kbGVTdGFydCgpO1xuICB9XG5cbiAgZGV0YWNoKCkge1xuICAgIHRoaXMubGlzdGVuZXJzLnJlbW92ZUFsbCgpO1xuICAgIHRoaXMud2luZG93TGlzdGVuZXJzLnJlbW92ZUFsbCgpOyAvLyBXYWl0IHVudGlsIHRoZSBuZXh0IGV2ZW50IGxvb3AgYmVmb3JlIHJlbW92aW5nIGRvY3VtZW50IGxpc3RlbmVyc1xuICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugd2UgbGlzdGVuIGZvciBgY2xpY2tgIGFuZCBgc2VsZWN0aW9uYCBldmVudHMgb24gdGhlIGRvY3VtZW50XG5cbiAgICBzZXRUaW1lb3V0KHRoaXMuZG9jdW1lbnRMaXN0ZW5lcnMucmVtb3ZlQWxsLCA1MCk7XG5cbiAgICBpZiAodGhpcy50aW1lb3V0SWQgIT09IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZCk7XG4gICAgICB0aGlzLnRpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlU3RhcnQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaW5pdGlhbENvb3JkaW5hdGVzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgb25TdGFydFxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgaWYgKGluaXRpYWxDb29yZGluYXRlcykge1xuICAgICAgdGhpcy5hY3RpdmF0ZWQgPSB0cnVlOyAvLyBTdG9wIHByb3BhZ2F0aW9uIG9mIGNsaWNrIGV2ZW50cyBvbmNlIGFjdGl2YXRpb24gY29uc3RyYWludHMgYXJlIG1ldFxuXG4gICAgICB0aGlzLmRvY3VtZW50TGlzdGVuZXJzLmFkZChFdmVudE5hbWUuQ2xpY2ssIHN0b3BQcm9wYWdhdGlvbiwge1xuICAgICAgICBjYXB0dXJlOiB0cnVlXG4gICAgICB9KTsgLy8gUmVtb3ZlIGFueSB0ZXh0IHNlbGVjdGlvbiBmcm9tIHRoZSBkb2N1bWVudFxuXG4gICAgICB0aGlzLnJlbW92ZVRleHRTZWxlY3Rpb24oKTsgLy8gUHJldmVudCBmdXJ0aGVyIHRleHQgc2VsZWN0aW9uIHdoaWxlIGRyYWdnaW5nXG5cbiAgICAgIHRoaXMuZG9jdW1lbnRMaXN0ZW5lcnMuYWRkKEV2ZW50TmFtZS5TZWxlY3Rpb25DaGFuZ2UsIHRoaXMucmVtb3ZlVGV4dFNlbGVjdGlvbik7XG4gICAgICBvblN0YXJ0KGluaXRpYWxDb29yZGluYXRlcyk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlTW92ZShldmVudCkge1xuICAgIHZhciBfZ2V0RXZlbnRDb29yZGluYXRlczI7XG5cbiAgICBjb25zdCB7XG4gICAgICBhY3RpdmF0ZWQsXG4gICAgICBpbml0aWFsQ29vcmRpbmF0ZXMsXG4gICAgICBwcm9wc1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIG9uTW92ZSxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgYWN0aXZhdGlvbkNvbnN0cmFpbnRcbiAgICAgIH1cbiAgICB9ID0gcHJvcHM7XG5cbiAgICBpZiAoIWluaXRpYWxDb29yZGluYXRlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gKF9nZXRFdmVudENvb3JkaW5hdGVzMiA9IGdldEV2ZW50Q29vcmRpbmF0ZXMoZXZlbnQpKSAhPSBudWxsID8gX2dldEV2ZW50Q29vcmRpbmF0ZXMyIDogZGVmYXVsdENvb3JkaW5hdGVzO1xuICAgIGNvbnN0IGRlbHRhID0gc3VidHJhY3QoaW5pdGlhbENvb3JkaW5hdGVzLCBjb29yZGluYXRlcyk7IC8vIENvbnN0cmFpbnQgdmFsaWRhdGlvblxuXG4gICAgaWYgKCFhY3RpdmF0ZWQgJiYgYWN0aXZhdGlvbkNvbnN0cmFpbnQpIHtcbiAgICAgIGlmIChpc0Rpc3RhbmNlQ29uc3RyYWludChhY3RpdmF0aW9uQ29uc3RyYWludCkpIHtcbiAgICAgICAgaWYgKGFjdGl2YXRpb25Db25zdHJhaW50LnRvbGVyYW5jZSAhPSBudWxsICYmIGhhc0V4Y2VlZGVkRGlzdGFuY2UoZGVsdGEsIGFjdGl2YXRpb25Db25zdHJhaW50LnRvbGVyYW5jZSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVDYW5jZWwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNFeGNlZWRlZERpc3RhbmNlKGRlbHRhLCBhY3RpdmF0aW9uQ29uc3RyYWludC5kaXN0YW5jZSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVTdGFydCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0RlbGF5Q29uc3RyYWludChhY3RpdmF0aW9uQ29uc3RyYWludCkpIHtcbiAgICAgICAgaWYgKGhhc0V4Y2VlZGVkRGlzdGFuY2UoZGVsdGEsIGFjdGl2YXRpb25Db25zdHJhaW50LnRvbGVyYW5jZSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVDYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LmNhbmNlbGFibGUpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgb25Nb3ZlKGNvb3JkaW5hdGVzKTtcbiAgfVxuXG4gIGhhbmRsZUVuZCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBvbkVuZFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgb25FbmQoKTtcbiAgfVxuXG4gIGhhbmRsZUNhbmNlbCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBvbkNhbmNlbFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgb25DYW5jZWwoKTtcbiAgfVxuXG4gIGhhbmRsZUtleWRvd24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuY29kZSA9PT0gS2V5Ym9hcmRDb2RlLkVzYykge1xuICAgICAgdGhpcy5oYW5kbGVDYW5jZWwoKTtcbiAgICB9XG4gIH1cblxuICByZW1vdmVUZXh0U2VsZWN0aW9uKCkge1xuICAgIHZhciBfdGhpcyRkb2N1bWVudCRnZXRTZWw7XG5cbiAgICAoX3RoaXMkZG9jdW1lbnQkZ2V0U2VsID0gdGhpcy5kb2N1bWVudC5nZXRTZWxlY3Rpb24oKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGRvY3VtZW50JGdldFNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgfVxuXG59XG5cbmNvbnN0IGV2ZW50cyA9IHtcbiAgbW92ZToge1xuICAgIG5hbWU6ICdwb2ludGVybW92ZSdcbiAgfSxcbiAgZW5kOiB7XG4gICAgbmFtZTogJ3BvaW50ZXJ1cCdcbiAgfVxufTtcbmNsYXNzIFBvaW50ZXJTZW5zb3IgZXh0ZW5kcyBBYnN0cmFjdFBvaW50ZXJTZW5zb3Ige1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIGNvbnN0IHtcbiAgICAgIGV2ZW50XG4gICAgfSA9IHByb3BzOyAvLyBQb2ludGVyIGV2ZW50cyBzdG9wIGZpcmluZyBpZiB0aGUgdGFyZ2V0IGlzIHVubW91bnRlZCB3aGlsZSBkcmFnZ2luZ1xuICAgIC8vIFRoZXJlZm9yZSB3ZSBhdHRhY2ggbGlzdGVuZXJzIHRvIHRoZSBvd25lciBkb2N1bWVudCBpbnN0ZWFkXG5cbiAgICBjb25zdCBsaXN0ZW5lclRhcmdldCA9IGdldE93bmVyRG9jdW1lbnQoZXZlbnQudGFyZ2V0KTtcbiAgICBzdXBlcihwcm9wcywgZXZlbnRzLCBsaXN0ZW5lclRhcmdldCk7XG4gIH1cblxufVxuUG9pbnRlclNlbnNvci5hY3RpdmF0b3JzID0gW3tcbiAgZXZlbnROYW1lOiAnb25Qb2ludGVyRG93bicsXG4gIGhhbmRsZXI6IChfcmVmLCBfcmVmMikgPT4ge1xuICAgIGxldCB7XG4gICAgICBuYXRpdmVFdmVudDogZXZlbnRcbiAgICB9ID0gX3JlZjtcbiAgICBsZXQge1xuICAgICAgb25BY3RpdmF0aW9uXG4gICAgfSA9IF9yZWYyO1xuXG4gICAgaWYgKCFldmVudC5pc1ByaW1hcnkgfHwgZXZlbnQuYnV0dG9uICE9PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgb25BY3RpdmF0aW9uID09IG51bGwgPyB2b2lkIDAgOiBvbkFjdGl2YXRpb24oe1xuICAgICAgZXZlbnRcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufV07XG5cbmNvbnN0IGV2ZW50cyQxID0ge1xuICBtb3ZlOiB7XG4gICAgbmFtZTogJ21vdXNlbW92ZSdcbiAgfSxcbiAgZW5kOiB7XG4gICAgbmFtZTogJ21vdXNldXAnXG4gIH1cbn07XG52YXIgTW91c2VCdXR0b247XG5cbihmdW5jdGlvbiAoTW91c2VCdXR0b24pIHtcbiAgTW91c2VCdXR0b25bTW91c2VCdXR0b25bXCJSaWdodENsaWNrXCJdID0gMl0gPSBcIlJpZ2h0Q2xpY2tcIjtcbn0pKE1vdXNlQnV0dG9uIHx8IChNb3VzZUJ1dHRvbiA9IHt9KSk7XG5cbmNsYXNzIE1vdXNlU2Vuc29yIGV4dGVuZHMgQWJzdHJhY3RQb2ludGVyU2Vuc29yIHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcywgZXZlbnRzJDEsIGdldE93bmVyRG9jdW1lbnQocHJvcHMuZXZlbnQudGFyZ2V0KSk7XG4gIH1cblxufVxuTW91c2VTZW5zb3IuYWN0aXZhdG9ycyA9IFt7XG4gIGV2ZW50TmFtZTogJ29uTW91c2VEb3duJyxcbiAgaGFuZGxlcjogKF9yZWYsIF9yZWYyKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIG5hdGl2ZUV2ZW50OiBldmVudFxuICAgIH0gPSBfcmVmO1xuICAgIGxldCB7XG4gICAgICBvbkFjdGl2YXRpb25cbiAgICB9ID0gX3JlZjI7XG5cbiAgICBpZiAoZXZlbnQuYnV0dG9uID09PSBNb3VzZUJ1dHRvbi5SaWdodENsaWNrKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgb25BY3RpdmF0aW9uID09IG51bGwgPyB2b2lkIDAgOiBvbkFjdGl2YXRpb24oe1xuICAgICAgZXZlbnRcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufV07XG5cbmNvbnN0IGV2ZW50cyQyID0ge1xuICBtb3ZlOiB7XG4gICAgbmFtZTogJ3RvdWNobW92ZSdcbiAgfSxcbiAgZW5kOiB7XG4gICAgbmFtZTogJ3RvdWNoZW5kJ1xuICB9XG59O1xuY2xhc3MgVG91Y2hTZW5zb3IgZXh0ZW5kcyBBYnN0cmFjdFBvaW50ZXJTZW5zb3Ige1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzLCBldmVudHMkMik7XG4gIH1cblxuICBzdGF0aWMgc2V0dXAoKSB7XG4gICAgLy8gQWRkaW5nIGEgbm9uLWNhcHR1cmUgYW5kIG5vbi1wYXNzaXZlIGB0b3VjaG1vdmVgIGxpc3RlbmVyIGluIG9yZGVyXG4gICAgLy8gdG8gZm9yY2UgYGV2ZW50LnByZXZlbnREZWZhdWx0KClgIGNhbGxzIHRvIHdvcmsgaW4gZHluYW1pY2FsbHkgYWRkZWRcbiAgICAvLyB0b3VjaG1vdmUgZXZlbnQgaGFuZGxlcnMuIFRoaXMgaXMgcmVxdWlyZWQgZm9yIGlPUyBTYWZhcmkuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRzJDIubW92ZS5uYW1lLCBub29wLCB7XG4gICAgICBjYXB0dXJlOiBmYWxzZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHRlYXJkb3duKCkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRzJDIubW92ZS5uYW1lLCBub29wKTtcbiAgICB9OyAvLyBXZSBjcmVhdGUgYSBuZXcgaGFuZGxlciBiZWNhdXNlIHRoZSB0ZWFyZG93biBmdW5jdGlvbiBvZiBhbm90aGVyIHNlbnNvclxuICAgIC8vIGNvdWxkIHJlbW92ZSBvdXIgZXZlbnQgbGlzdGVuZXIgaWYgd2UgdXNlIGEgcmVmZXJlbnRpYWxseSBlcXVhbCBsaXN0ZW5lci5cblxuICAgIGZ1bmN0aW9uIG5vb3AoKSB7fVxuICB9XG5cbn1cblRvdWNoU2Vuc29yLmFjdGl2YXRvcnMgPSBbe1xuICBldmVudE5hbWU6ICdvblRvdWNoU3RhcnQnLFxuICBoYW5kbGVyOiAoX3JlZiwgX3JlZjIpID0+IHtcbiAgICBsZXQge1xuICAgICAgbmF0aXZlRXZlbnQ6IGV2ZW50XG4gICAgfSA9IF9yZWY7XG4gICAgbGV0IHtcbiAgICAgIG9uQWN0aXZhdGlvblxuICAgIH0gPSBfcmVmMjtcbiAgICBjb25zdCB7XG4gICAgICB0b3VjaGVzXG4gICAgfSA9IGV2ZW50O1xuXG4gICAgaWYgKHRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG9uQWN0aXZhdGlvbiA9PSBudWxsID8gdm9pZCAwIDogb25BY3RpdmF0aW9uKHtcbiAgICAgIGV2ZW50XG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1dO1xuXG52YXIgQXV0b1Njcm9sbEFjdGl2YXRvcjtcblxuKGZ1bmN0aW9uIChBdXRvU2Nyb2xsQWN0aXZhdG9yKSB7XG4gIEF1dG9TY3JvbGxBY3RpdmF0b3JbQXV0b1Njcm9sbEFjdGl2YXRvcltcIlBvaW50ZXJcIl0gPSAwXSA9IFwiUG9pbnRlclwiO1xuICBBdXRvU2Nyb2xsQWN0aXZhdG9yW0F1dG9TY3JvbGxBY3RpdmF0b3JbXCJEcmFnZ2FibGVSZWN0XCJdID0gMV0gPSBcIkRyYWdnYWJsZVJlY3RcIjtcbn0pKEF1dG9TY3JvbGxBY3RpdmF0b3IgfHwgKEF1dG9TY3JvbGxBY3RpdmF0b3IgPSB7fSkpO1xuXG52YXIgVHJhdmVyc2FsT3JkZXI7XG5cbihmdW5jdGlvbiAoVHJhdmVyc2FsT3JkZXIpIHtcbiAgVHJhdmVyc2FsT3JkZXJbVHJhdmVyc2FsT3JkZXJbXCJUcmVlT3JkZXJcIl0gPSAwXSA9IFwiVHJlZU9yZGVyXCI7XG4gIFRyYXZlcnNhbE9yZGVyW1RyYXZlcnNhbE9yZGVyW1wiUmV2ZXJzZWRUcmVlT3JkZXJcIl0gPSAxXSA9IFwiUmV2ZXJzZWRUcmVlT3JkZXJcIjtcbn0pKFRyYXZlcnNhbE9yZGVyIHx8IChUcmF2ZXJzYWxPcmRlciA9IHt9KSk7XG5cbmZ1bmN0aW9uIHVzZUF1dG9TY3JvbGxlcihfcmVmKSB7XG4gIGxldCB7XG4gICAgYWNjZWxlcmF0aW9uLFxuICAgIGFjdGl2YXRvciA9IEF1dG9TY3JvbGxBY3RpdmF0b3IuUG9pbnRlcixcbiAgICBjYW5TY3JvbGwsXG4gICAgZHJhZ2dpbmdSZWN0LFxuICAgIGVuYWJsZWQsXG4gICAgaW50ZXJ2YWwgPSA1LFxuICAgIG9yZGVyID0gVHJhdmVyc2FsT3JkZXIuVHJlZU9yZGVyLFxuICAgIHBvaW50ZXJDb29yZGluYXRlcyxcbiAgICBzY3JvbGxhYmxlQW5jZXN0b3JzLFxuICAgIHNjcm9sbGFibGVBbmNlc3RvclJlY3RzLFxuICAgIGRlbHRhLFxuICAgIHRocmVzaG9sZFxuICB9ID0gX3JlZjtcbiAgY29uc3Qgc2Nyb2xsSW50ZW50ID0gdXNlU2Nyb2xsSW50ZW50KHtcbiAgICBkZWx0YSxcbiAgICBkaXNhYmxlZDogIWVuYWJsZWRcbiAgfSk7XG4gIGNvbnN0IFtzZXRBdXRvU2Nyb2xsSW50ZXJ2YWwsIGNsZWFyQXV0b1Njcm9sbEludGVydmFsXSA9IHVzZUludGVydmFsKCk7XG4gIGNvbnN0IHNjcm9sbFNwZWVkID0gdXNlUmVmKHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfSk7XG4gIGNvbnN0IHNjcm9sbERpcmVjdGlvbiA9IHVzZVJlZih7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH0pO1xuICBjb25zdCByZWN0ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgc3dpdGNoIChhY3RpdmF0b3IpIHtcbiAgICAgIGNhc2UgQXV0b1Njcm9sbEFjdGl2YXRvci5Qb2ludGVyOlxuICAgICAgICByZXR1cm4gcG9pbnRlckNvb3JkaW5hdGVzID8ge1xuICAgICAgICAgIHRvcDogcG9pbnRlckNvb3JkaW5hdGVzLnksXG4gICAgICAgICAgYm90dG9tOiBwb2ludGVyQ29vcmRpbmF0ZXMueSxcbiAgICAgICAgICBsZWZ0OiBwb2ludGVyQ29vcmRpbmF0ZXMueCxcbiAgICAgICAgICByaWdodDogcG9pbnRlckNvb3JkaW5hdGVzLnhcbiAgICAgICAgfSA6IG51bGw7XG5cbiAgICAgIGNhc2UgQXV0b1Njcm9sbEFjdGl2YXRvci5EcmFnZ2FibGVSZWN0OlxuICAgICAgICByZXR1cm4gZHJhZ2dpbmdSZWN0O1xuICAgIH1cbiAgfSwgW2FjdGl2YXRvciwgZHJhZ2dpbmdSZWN0LCBwb2ludGVyQ29vcmRpbmF0ZXNdKTtcbiAgY29uc3Qgc2Nyb2xsQ29udGFpbmVyUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBhdXRvU2Nyb2xsID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IHNjcm9sbENvbnRhaW5lciA9IHNjcm9sbENvbnRhaW5lclJlZi5jdXJyZW50O1xuXG4gICAgaWYgKCFzY3JvbGxDb250YWluZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzY3JvbGxMZWZ0ID0gc2Nyb2xsU3BlZWQuY3VycmVudC54ICogc2Nyb2xsRGlyZWN0aW9uLmN1cnJlbnQueDtcbiAgICBjb25zdCBzY3JvbGxUb3AgPSBzY3JvbGxTcGVlZC5jdXJyZW50LnkgKiBzY3JvbGxEaXJlY3Rpb24uY3VycmVudC55O1xuICAgIHNjcm9sbENvbnRhaW5lci5zY3JvbGxCeShzY3JvbGxMZWZ0LCBzY3JvbGxUb3ApO1xuICB9LCBbXSk7XG4gIGNvbnN0IHNvcnRlZFNjcm9sbGFibGVBbmNlc3RvcnMgPSB1c2VNZW1vKCgpID0+IG9yZGVyID09PSBUcmF2ZXJzYWxPcmRlci5UcmVlT3JkZXIgPyBbLi4uc2Nyb2xsYWJsZUFuY2VzdG9yc10ucmV2ZXJzZSgpIDogc2Nyb2xsYWJsZUFuY2VzdG9ycywgW29yZGVyLCBzY3JvbGxhYmxlQW5jZXN0b3JzXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkIHx8ICFzY3JvbGxhYmxlQW5jZXN0b3JzLmxlbmd0aCB8fCAhcmVjdCkge1xuICAgICAgY2xlYXJBdXRvU2Nyb2xsSW50ZXJ2YWwoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHNjcm9sbENvbnRhaW5lciBvZiBzb3J0ZWRTY3JvbGxhYmxlQW5jZXN0b3JzKSB7XG4gICAgICBpZiAoKGNhblNjcm9sbCA9PSBudWxsID8gdm9pZCAwIDogY2FuU2Nyb2xsKHNjcm9sbENvbnRhaW5lcikpID09PSBmYWxzZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaW5kZXggPSBzY3JvbGxhYmxlQW5jZXN0b3JzLmluZGV4T2Yoc2Nyb2xsQ29udGFpbmVyKTtcbiAgICAgIGNvbnN0IHNjcm9sbENvbnRhaW5lclJlY3QgPSBzY3JvbGxhYmxlQW5jZXN0b3JSZWN0c1tpbmRleF07XG5cbiAgICAgIGlmICghc2Nyb2xsQ29udGFpbmVyUmVjdCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qge1xuICAgICAgICBkaXJlY3Rpb24sXG4gICAgICAgIHNwZWVkXG4gICAgICB9ID0gZ2V0U2Nyb2xsRGlyZWN0aW9uQW5kU3BlZWQoc2Nyb2xsQ29udGFpbmVyLCBzY3JvbGxDb250YWluZXJSZWN0LCByZWN0LCBhY2NlbGVyYXRpb24sIHRocmVzaG9sZCk7XG5cbiAgICAgIGZvciAoY29uc3QgYXhpcyBvZiBbJ3gnLCAneSddKSB7XG4gICAgICAgIGlmICghc2Nyb2xsSW50ZW50W2F4aXNdW2RpcmVjdGlvbltheGlzXV0pIHtcbiAgICAgICAgICBzcGVlZFtheGlzXSA9IDA7XG4gICAgICAgICAgZGlyZWN0aW9uW2F4aXNdID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3BlZWQueCA+IDAgfHwgc3BlZWQueSA+IDApIHtcbiAgICAgICAgY2xlYXJBdXRvU2Nyb2xsSW50ZXJ2YWwoKTtcbiAgICAgICAgc2Nyb2xsQ29udGFpbmVyUmVmLmN1cnJlbnQgPSBzY3JvbGxDb250YWluZXI7XG4gICAgICAgIHNldEF1dG9TY3JvbGxJbnRlcnZhbChhdXRvU2Nyb2xsLCBpbnRlcnZhbCk7XG4gICAgICAgIHNjcm9sbFNwZWVkLmN1cnJlbnQgPSBzcGVlZDtcbiAgICAgICAgc2Nyb2xsRGlyZWN0aW9uLmN1cnJlbnQgPSBkaXJlY3Rpb247XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzY3JvbGxTcGVlZC5jdXJyZW50ID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICAgIHNjcm9sbERpcmVjdGlvbi5jdXJyZW50ID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICAgIGNsZWFyQXV0b1Njcm9sbEludGVydmFsKCk7XG4gIH0sIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgW2FjY2VsZXJhdGlvbiwgYXV0b1Njcm9sbCwgY2FuU2Nyb2xsLCBjbGVhckF1dG9TY3JvbGxJbnRlcnZhbCwgZW5hYmxlZCwgaW50ZXJ2YWwsIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgSlNPTi5zdHJpbmdpZnkocmVjdCksIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgSlNPTi5zdHJpbmdpZnkoc2Nyb2xsSW50ZW50KSwgc2V0QXV0b1Njcm9sbEludGVydmFsLCBzY3JvbGxhYmxlQW5jZXN0b3JzLCBzb3J0ZWRTY3JvbGxhYmxlQW5jZXN0b3JzLCBzY3JvbGxhYmxlQW5jZXN0b3JSZWN0cywgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBKU09OLnN0cmluZ2lmeSh0aHJlc2hvbGQpXSk7XG59XG5jb25zdCBkZWZhdWx0U2Nyb2xsSW50ZW50ID0ge1xuICB4OiB7XG4gICAgW0RpcmVjdGlvbi5CYWNrd2FyZF06IGZhbHNlLFxuICAgIFtEaXJlY3Rpb24uRm9yd2FyZF06IGZhbHNlXG4gIH0sXG4gIHk6IHtcbiAgICBbRGlyZWN0aW9uLkJhY2t3YXJkXTogZmFsc2UsXG4gICAgW0RpcmVjdGlvbi5Gb3J3YXJkXTogZmFsc2VcbiAgfVxufTtcblxuZnVuY3Rpb24gdXNlU2Nyb2xsSW50ZW50KF9yZWYyKSB7XG4gIGxldCB7XG4gICAgZGVsdGEsXG4gICAgZGlzYWJsZWRcbiAgfSA9IF9yZWYyO1xuICBjb25zdCBwcmV2aW91c0RlbHRhID0gdXNlUHJldmlvdXMoZGVsdGEpO1xuICByZXR1cm4gdXNlTGF6eU1lbW8ocHJldmlvdXNJbnRlbnQgPT4ge1xuICAgIGlmIChkaXNhYmxlZCB8fCAhcHJldmlvdXNEZWx0YSB8fCAhcHJldmlvdXNJbnRlbnQpIHtcbiAgICAgIC8vIFJlc2V0IHNjcm9sbCBpbnRlbnQgdHJhY2tpbmcgd2hlbiBhdXRvLXNjcm9sbGluZyBpcyBkaXNhYmxlZFxuICAgICAgcmV0dXJuIGRlZmF1bHRTY3JvbGxJbnRlbnQ7XG4gICAgfVxuXG4gICAgY29uc3QgZGlyZWN0aW9uID0ge1xuICAgICAgeDogTWF0aC5zaWduKGRlbHRhLnggLSBwcmV2aW91c0RlbHRhLngpLFxuICAgICAgeTogTWF0aC5zaWduKGRlbHRhLnkgLSBwcmV2aW91c0RlbHRhLnkpXG4gICAgfTsgLy8gS2VlcCB0cmFjayBvZiB0aGUgdXNlciBpbnRlbnQgdG8gc2Nyb2xsIGluIGVhY2ggZGlyZWN0aW9uIGZvciBib3RoIGF4aXNcblxuICAgIHJldHVybiB7XG4gICAgICB4OiB7XG4gICAgICAgIFtEaXJlY3Rpb24uQmFja3dhcmRdOiBwcmV2aW91c0ludGVudC54W0RpcmVjdGlvbi5CYWNrd2FyZF0gfHwgZGlyZWN0aW9uLnggPT09IC0xLFxuICAgICAgICBbRGlyZWN0aW9uLkZvcndhcmRdOiBwcmV2aW91c0ludGVudC54W0RpcmVjdGlvbi5Gb3J3YXJkXSB8fCBkaXJlY3Rpb24ueCA9PT0gMVxuICAgICAgfSxcbiAgICAgIHk6IHtcbiAgICAgICAgW0RpcmVjdGlvbi5CYWNrd2FyZF06IHByZXZpb3VzSW50ZW50LnlbRGlyZWN0aW9uLkJhY2t3YXJkXSB8fCBkaXJlY3Rpb24ueSA9PT0gLTEsXG4gICAgICAgIFtEaXJlY3Rpb24uRm9yd2FyZF06IHByZXZpb3VzSW50ZW50LnlbRGlyZWN0aW9uLkZvcndhcmRdIHx8IGRpcmVjdGlvbi55ID09PSAxXG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2Rpc2FibGVkLCBkZWx0YSwgcHJldmlvdXNEZWx0YV0pO1xufVxuXG5mdW5jdGlvbiB1c2VDYWNoZWROb2RlKGRyYWdnYWJsZU5vZGVzLCBpZCkge1xuICBjb25zdCBkcmFnZ2FibGVOb2RlID0gaWQgIT09IG51bGwgPyBkcmFnZ2FibGVOb2Rlcy5nZXQoaWQpIDogdW5kZWZpbmVkO1xuICBjb25zdCBub2RlID0gZHJhZ2dhYmxlTm9kZSA/IGRyYWdnYWJsZU5vZGUubm9kZS5jdXJyZW50IDogbnVsbDtcbiAgcmV0dXJuIHVzZUxhenlNZW1vKGNhY2hlZE5vZGUgPT4ge1xuICAgIHZhciBfcmVmO1xuXG4gICAgaWYgKGlkID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IC8vIEluIHNvbWUgY2FzZXMsIHRoZSBkcmFnZ2FibGUgbm9kZSBjYW4gdW5tb3VudCB3aGlsZSBkcmFnZ2luZ1xuICAgIC8vIFRoaXMgaXMgdGhlIGNhc2UgZm9yIHZpcnR1YWxpemVkIGxpc3RzLiBJbiB0aG9zZSBzaXR1YXRpb25zLFxuICAgIC8vIHdlIGZhbGwgYmFjayB0byB0aGUgbGFzdCBrbm93biB2YWx1ZSBmb3IgdGhhdCBub2RlLlxuXG5cbiAgICByZXR1cm4gKF9yZWYgPSBub2RlICE9IG51bGwgPyBub2RlIDogY2FjaGVkTm9kZSkgIT0gbnVsbCA/IF9yZWYgOiBudWxsO1xuICB9LCBbbm9kZSwgaWRdKTtcbn1cblxuZnVuY3Rpb24gdXNlQ29tYmluZUFjdGl2YXRvcnMoc2Vuc29ycywgZ2V0U3ludGhldGljSGFuZGxlcikge1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiBzZW5zb3JzLnJlZHVjZSgoYWNjdW11bGF0b3IsIHNlbnNvcikgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHNlbnNvcjogU2Vuc29yXG4gICAgfSA9IHNlbnNvcjtcbiAgICBjb25zdCBzZW5zb3JBY3RpdmF0b3JzID0gU2Vuc29yLmFjdGl2YXRvcnMubWFwKGFjdGl2YXRvciA9PiAoe1xuICAgICAgZXZlbnROYW1lOiBhY3RpdmF0b3IuZXZlbnROYW1lLFxuICAgICAgaGFuZGxlcjogZ2V0U3ludGhldGljSGFuZGxlcihhY3RpdmF0b3IuaGFuZGxlciwgc2Vuc29yKVxuICAgIH0pKTtcbiAgICByZXR1cm4gWy4uLmFjY3VtdWxhdG9yLCAuLi5zZW5zb3JBY3RpdmF0b3JzXTtcbiAgfSwgW10pLCBbc2Vuc29ycywgZ2V0U3ludGhldGljSGFuZGxlcl0pO1xufVxuXG52YXIgTWVhc3VyaW5nU3RyYXRlZ3k7XG5cbihmdW5jdGlvbiAoTWVhc3VyaW5nU3RyYXRlZ3kpIHtcbiAgTWVhc3VyaW5nU3RyYXRlZ3lbTWVhc3VyaW5nU3RyYXRlZ3lbXCJBbHdheXNcIl0gPSAwXSA9IFwiQWx3YXlzXCI7XG4gIE1lYXN1cmluZ1N0cmF0ZWd5W01lYXN1cmluZ1N0cmF0ZWd5W1wiQmVmb3JlRHJhZ2dpbmdcIl0gPSAxXSA9IFwiQmVmb3JlRHJhZ2dpbmdcIjtcbiAgTWVhc3VyaW5nU3RyYXRlZ3lbTWVhc3VyaW5nU3RyYXRlZ3lbXCJXaGlsZURyYWdnaW5nXCJdID0gMl0gPSBcIldoaWxlRHJhZ2dpbmdcIjtcbn0pKE1lYXN1cmluZ1N0cmF0ZWd5IHx8IChNZWFzdXJpbmdTdHJhdGVneSA9IHt9KSk7XG5cbnZhciBNZWFzdXJpbmdGcmVxdWVuY3k7XG5cbihmdW5jdGlvbiAoTWVhc3VyaW5nRnJlcXVlbmN5KSB7XG4gIE1lYXN1cmluZ0ZyZXF1ZW5jeVtcIk9wdGltaXplZFwiXSA9IFwib3B0aW1pemVkXCI7XG59KShNZWFzdXJpbmdGcmVxdWVuY3kgfHwgKE1lYXN1cmluZ0ZyZXF1ZW5jeSA9IHt9KSk7XG5cbmNvbnN0IGRlZmF1bHRWYWx1ZSA9IC8qI19fUFVSRV9fKi9uZXcgTWFwKCk7XG5mdW5jdGlvbiB1c2VEcm9wcGFibGVNZWFzdXJpbmcoY29udGFpbmVycywgX3JlZikge1xuICBsZXQge1xuICAgIGRyYWdnaW5nLFxuICAgIGRlcGVuZGVuY2llcyxcbiAgICBjb25maWdcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IFtxdWV1ZSwgc2V0UXVldWVdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IHtcbiAgICBmcmVxdWVuY3ksXG4gICAgbWVhc3VyZSxcbiAgICBzdHJhdGVneVxuICB9ID0gY29uZmlnO1xuICBjb25zdCBjb250YWluZXJzUmVmID0gdXNlUmVmKGNvbnRhaW5lcnMpO1xuICBjb25zdCBkaXNhYmxlZCA9IGlzRGlzYWJsZWQoKTtcbiAgY29uc3QgZGlzYWJsZWRSZWYgPSB1c2VMYXRlc3RWYWx1ZShkaXNhYmxlZCk7XG4gIGNvbnN0IG1lYXN1cmVEcm9wcGFibGVDb250YWluZXJzID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKGlkcykge1xuICAgIGlmIChpZHMgPT09IHZvaWQgMCkge1xuICAgICAgaWRzID0gW107XG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZXRRdWV1ZSh2YWx1ZSA9PiB7XG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGlkcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlLmNvbmNhdChpZHMuZmlsdGVyKGlkID0+ICF2YWx1ZS5pbmNsdWRlcyhpZCkpKTtcbiAgICB9KTtcbiAgfSwgW2Rpc2FibGVkUmVmXSk7XG4gIGNvbnN0IHRpbWVvdXRJZCA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgZHJvcHBhYmxlUmVjdHMgPSB1c2VMYXp5TWVtbyhwcmV2aW91c1ZhbHVlID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgJiYgIWRyYWdnaW5nKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH1cblxuICAgIGlmICghcHJldmlvdXNWYWx1ZSB8fCBwcmV2aW91c1ZhbHVlID09PSBkZWZhdWx0VmFsdWUgfHwgY29udGFpbmVyc1JlZi5jdXJyZW50ICE9PSBjb250YWluZXJzIHx8IHF1ZXVlICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcblxuICAgICAgZm9yIChsZXQgY29udGFpbmVyIG9mIGNvbnRhaW5lcnMpIHtcbiAgICAgICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChxdWV1ZSAmJiBxdWV1ZS5sZW5ndGggPiAwICYmICFxdWV1ZS5pbmNsdWRlcyhjb250YWluZXIuaWQpICYmIGNvbnRhaW5lci5yZWN0LmN1cnJlbnQpIHtcbiAgICAgICAgICAvLyBUaGlzIGNvbnRhaW5lciBkb2VzIG5vdCBuZWVkIHRvIGJlIHJlLW1lYXN1cmVkXG4gICAgICAgICAgbWFwLnNldChjb250YWluZXIuaWQsIGNvbnRhaW5lci5yZWN0LmN1cnJlbnQpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgbm9kZSA9IGNvbnRhaW5lci5ub2RlLmN1cnJlbnQ7XG4gICAgICAgIGNvbnN0IHJlY3QgPSBub2RlID8gbmV3IFJlY3QobWVhc3VyZShub2RlKSwgbm9kZSkgOiBudWxsO1xuICAgICAgICBjb250YWluZXIucmVjdC5jdXJyZW50ID0gcmVjdDtcblxuICAgICAgICBpZiAocmVjdCkge1xuICAgICAgICAgIG1hcC5zZXQoY29udGFpbmVyLmlkLCByZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFwO1xuICAgIH1cblxuICAgIHJldHVybiBwcmV2aW91c1ZhbHVlO1xuICB9LCBbY29udGFpbmVycywgcXVldWUsIGRyYWdnaW5nLCBkaXNhYmxlZCwgbWVhc3VyZV0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnRhaW5lcnNSZWYuY3VycmVudCA9IGNvbnRhaW5lcnM7XG4gIH0sIFtjb250YWluZXJzXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbWVhc3VyZURyb3BwYWJsZUNvbnRhaW5lcnMoKTtcbiAgfSwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBbZHJhZ2dpbmcsIGRpc2FibGVkXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHF1ZXVlICYmIHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgIHNldFF1ZXVlKG51bGwpO1xuICAgIH1cbiAgfSwgLy9lc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFtKU09OLnN0cmluZ2lmeShxdWV1ZSldKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgfHwgdHlwZW9mIGZyZXF1ZW5jeSAhPT0gJ251bWJlcicgfHwgdGltZW91dElkLmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aW1lb3V0SWQuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgbWVhc3VyZURyb3BwYWJsZUNvbnRhaW5lcnMoKTtcbiAgICAgIHRpbWVvdXRJZC5jdXJyZW50ID0gbnVsbDtcbiAgICB9LCBmcmVxdWVuY3kpO1xuICB9LCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFtmcmVxdWVuY3ksIGRpc2FibGVkLCBtZWFzdXJlRHJvcHBhYmxlQ29udGFpbmVycywgLi4uZGVwZW5kZW5jaWVzXSk7XG4gIHJldHVybiB7XG4gICAgZHJvcHBhYmxlUmVjdHMsXG4gICAgbWVhc3VyZURyb3BwYWJsZUNvbnRhaW5lcnMsXG4gICAgbWVhc3VyaW5nU2NoZWR1bGVkOiBxdWV1ZSAhPSBudWxsXG4gIH07XG5cbiAgZnVuY3Rpb24gaXNEaXNhYmxlZCgpIHtcbiAgICBzd2l0Y2ggKHN0cmF0ZWd5KSB7XG4gICAgICBjYXNlIE1lYXN1cmluZ1N0cmF0ZWd5LkFsd2F5czpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBjYXNlIE1lYXN1cmluZ1N0cmF0ZWd5LkJlZm9yZURyYWdnaW5nOlxuICAgICAgICByZXR1cm4gZHJhZ2dpbmc7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAhZHJhZ2dpbmc7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVzZUluaXRpYWxWYWx1ZSh2YWx1ZSwgY29tcHV0ZUZuKSB7XG4gIHJldHVybiB1c2VMYXp5TWVtbyhwcmV2aW91c1ZhbHVlID0+IHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAocHJldmlvdXNWYWx1ZSkge1xuICAgICAgcmV0dXJuIHByZXZpb3VzVmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGVvZiBjb21wdXRlRm4gPT09ICdmdW5jdGlvbicgPyBjb21wdXRlRm4odmFsdWUpIDogdmFsdWU7XG4gIH0sIFtjb21wdXRlRm4sIHZhbHVlXSk7XG59XG5cbmZ1bmN0aW9uIHVzZUluaXRpYWxSZWN0KG5vZGUsIG1lYXN1cmUpIHtcbiAgcmV0dXJuIHVzZUluaXRpYWxWYWx1ZShub2RlLCBtZWFzdXJlKTtcbn1cblxuLyoqXHJcbiAqIFJldHVybnMgYSBuZXcgTXV0YXRpb25PYnNlcnZlciBpbnN0YW5jZS5cclxuICogSWYgYE11dGF0aW9uT2JzZXJ2ZXJgIGlzIHVuZGVmaW5lZCBpbiB0aGUgZXhlY3V0aW9uIGVudmlyb25tZW50LCByZXR1cm5zIGB1bmRlZmluZWRgLlxyXG4gKi9cblxuZnVuY3Rpb24gdXNlTXV0YXRpb25PYnNlcnZlcihfcmVmKSB7XG4gIGxldCB7XG4gICAgY2FsbGJhY2ssXG4gICAgZGlzYWJsZWRcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGhhbmRsZU11dGF0aW9ucyA9IHVzZUV2ZW50KGNhbGxiYWNrKTtcbiAgY29uc3QgbXV0YXRpb25PYnNlcnZlciA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGlmIChkaXNhYmxlZCB8fCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2Ygd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIE11dGF0aW9uT2JzZXJ2ZXJcbiAgICB9ID0gd2luZG93O1xuICAgIHJldHVybiBuZXcgTXV0YXRpb25PYnNlcnZlcihoYW5kbGVNdXRhdGlvbnMpO1xuICB9LCBbaGFuZGxlTXV0YXRpb25zLCBkaXNhYmxlZF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiBtdXRhdGlvbk9ic2VydmVyID09IG51bGwgPyB2b2lkIDAgOiBtdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfSwgW211dGF0aW9uT2JzZXJ2ZXJdKTtcbiAgcmV0dXJuIG11dGF0aW9uT2JzZXJ2ZXI7XG59XG5cbi8qKlxyXG4gKiBSZXR1cm5zIGEgbmV3IFJlc2l6ZU9ic2VydmVyIGluc3RhbmNlIGJvdW5kIHRvIHRoZSBgb25SZXNpemVgIGNhbGxiYWNrLlxyXG4gKiBJZiBgUmVzaXplT2JzZXJ2ZXJgIGlzIHVuZGVmaW5lZCBpbiB0aGUgZXhlY3V0aW9uIGVudmlyb25tZW50LCByZXR1cm5zIGB1bmRlZmluZWRgLlxyXG4gKi9cblxuZnVuY3Rpb24gdXNlUmVzaXplT2JzZXJ2ZXIoX3JlZikge1xuICBsZXQge1xuICAgIGNhbGxiYWNrLFxuICAgIGRpc2FibGVkXG4gIH0gPSBfcmVmO1xuICBjb25zdCBoYW5kbGVSZXNpemUgPSB1c2VFdmVudChjYWxsYmFjayk7XG4gIGNvbnN0IHJlc2l6ZU9ic2VydmVyID0gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkIHx8IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB3aW5kb3cuUmVzaXplT2JzZXJ2ZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIFJlc2l6ZU9ic2VydmVyXG4gICAgfSA9IHdpbmRvdztcbiAgICByZXR1cm4gbmV3IFJlc2l6ZU9ic2VydmVyKGhhbmRsZVJlc2l6ZSk7XG4gIH0sIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgW2Rpc2FibGVkXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHJlc2l6ZU9ic2VydmVyID09IG51bGwgPyB2b2lkIDAgOiByZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH0sIFtyZXNpemVPYnNlcnZlcl0pO1xuICByZXR1cm4gcmVzaXplT2JzZXJ2ZXI7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRNZWFzdXJlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIG5ldyBSZWN0KGdldENsaWVudFJlY3QoZWxlbWVudCksIGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiB1c2VSZWN0KGVsZW1lbnQsIG1lYXN1cmUsIGZhbGxiYWNrUmVjdCkge1xuICBpZiAobWVhc3VyZSA9PT0gdm9pZCAwKSB7XG4gICAgbWVhc3VyZSA9IGRlZmF1bHRNZWFzdXJlO1xuICB9XG5cbiAgY29uc3QgW3JlY3QsIG1lYXN1cmVSZWN0XSA9IHVzZVJlZHVjZXIocmVkdWNlciwgbnVsbCk7XG4gIGNvbnN0IG11dGF0aW9uT2JzZXJ2ZXIgPSB1c2VNdXRhdGlvbk9ic2VydmVyKHtcbiAgICBjYWxsYmFjayhyZWNvcmRzKSB7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IHJlY29yZCBvZiByZWNvcmRzKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIHRhcmdldFxuICAgICAgICB9ID0gcmVjb3JkO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAnY2hpbGRMaXN0JyAmJiB0YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiB0YXJnZXQuY29udGFpbnMoZWxlbWVudCkpIHtcbiAgICAgICAgICBtZWFzdXJlUmVjdCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gIH0pO1xuICBjb25zdCByZXNpemVPYnNlcnZlciA9IHVzZVJlc2l6ZU9ic2VydmVyKHtcbiAgICBjYWxsYmFjazogbWVhc3VyZVJlY3RcbiAgfSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIG1lYXN1cmVSZWN0KCk7XG5cbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgcmVzaXplT2JzZXJ2ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc2l6ZU9ic2VydmVyLm9ic2VydmUoZWxlbWVudCk7XG4gICAgICBtdXRhdGlvbk9ic2VydmVyID09IG51bGwgPyB2b2lkIDAgOiBtdXRhdGlvbk9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQuYm9keSwge1xuICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIHN1YnRyZWU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNpemVPYnNlcnZlciA9PSBudWxsID8gdm9pZCAwIDogcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgbXV0YXRpb25PYnNlcnZlciA9PSBudWxsID8gdm9pZCAwIDogbXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfVxuICB9LCBbZWxlbWVudF0pO1xuICByZXR1cm4gcmVjdDtcblxuICBmdW5jdGlvbiByZWR1Y2VyKGN1cnJlbnRSZWN0KSB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC5pc0Nvbm5lY3RlZCA9PT0gZmFsc2UpIHtcbiAgICAgIHZhciBfcmVmO1xuXG4gICAgICAvLyBGYWxsIGJhY2sgdG8gbGFzdCByZWN0IHdlIG1lYXN1cmVkIGlmIHRoZSBlbGVtZW50IGlzXG4gICAgICAvLyBubyBsb25nZXIgY29ubmVjdGVkIHRvIHRoZSBET00uXG4gICAgICByZXR1cm4gKF9yZWYgPSBjdXJyZW50UmVjdCAhPSBudWxsID8gY3VycmVudFJlY3QgOiBmYWxsYmFja1JlY3QpICE9IG51bGwgPyBfcmVmIDogbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBuZXdSZWN0ID0gbWVhc3VyZShlbGVtZW50KTtcblxuICAgIGlmIChKU09OLnN0cmluZ2lmeShjdXJyZW50UmVjdCkgPT09IEpTT04uc3RyaW5naWZ5KG5ld1JlY3QpKSB7XG4gICAgICByZXR1cm4gY3VycmVudFJlY3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld1JlY3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlUmVjdERlbHRhKHJlY3QpIHtcbiAgY29uc3QgaW5pdGlhbFJlY3QgPSB1c2VJbml0aWFsVmFsdWUocmVjdCk7XG4gIHJldHVybiBnZXRSZWN0RGVsdGEocmVjdCwgaW5pdGlhbFJlY3QpO1xufVxuXG5jb25zdCBkZWZhdWx0VmFsdWUkMSA9IFtdO1xuZnVuY3Rpb24gdXNlU2Nyb2xsYWJsZUFuY2VzdG9ycyhub2RlKSB7XG4gIGNvbnN0IHByZXZpb3VzTm9kZSA9IHVzZVJlZihub2RlKTtcbiAgY29uc3QgYW5jZXN0b3JzID0gdXNlTGF6eU1lbW8ocHJldmlvdXNWYWx1ZSA9PiB7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlJDE7XG4gICAgfVxuXG4gICAgaWYgKHByZXZpb3VzVmFsdWUgJiYgcHJldmlvdXNWYWx1ZSAhPT0gZGVmYXVsdFZhbHVlJDEgJiYgbm9kZSAmJiBwcmV2aW91c05vZGUuY3VycmVudCAmJiBub2RlLnBhcmVudE5vZGUgPT09IHByZXZpb3VzTm9kZS5jdXJyZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIHJldHVybiBwcmV2aW91c1ZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRTY3JvbGxhYmxlQW5jZXN0b3JzKG5vZGUpO1xuICB9LCBbbm9kZV0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHByZXZpb3VzTm9kZS5jdXJyZW50ID0gbm9kZTtcbiAgfSwgW25vZGVdKTtcbiAgcmV0dXJuIGFuY2VzdG9ycztcbn1cblxuZnVuY3Rpb24gdXNlU2Nyb2xsT2Zmc2V0cyhlbGVtZW50cykge1xuICBjb25zdCBbc2Nyb2xsQ29vcmRpbmF0ZXMsIHNldFNjcm9sbENvb3JkaW5hdGVzXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBwcmV2RWxlbWVudHMgPSB1c2VSZWYoZWxlbWVudHMpOyAvLyBUby1kbzogVGhyb3R0bGUgdGhlIGhhbmRsZVNjcm9sbCBjYWxsYmFja1xuXG4gIGNvbnN0IGhhbmRsZVNjcm9sbCA9IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICBjb25zdCBzY3JvbGxpbmdFbGVtZW50ID0gZ2V0U2Nyb2xsYWJsZUVsZW1lbnQoZXZlbnQudGFyZ2V0KTtcblxuICAgIGlmICghc2Nyb2xsaW5nRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNldFNjcm9sbENvb3JkaW5hdGVzKHNjcm9sbENvb3JkaW5hdGVzID0+IHtcbiAgICAgIGlmICghc2Nyb2xsQ29vcmRpbmF0ZXMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHNjcm9sbENvb3JkaW5hdGVzLnNldChzY3JvbGxpbmdFbGVtZW50LCBnZXRTY3JvbGxDb29yZGluYXRlcyhzY3JvbGxpbmdFbGVtZW50KSk7XG4gICAgICByZXR1cm4gbmV3IE1hcChzY3JvbGxDb29yZGluYXRlcyk7XG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBwcmV2aW91c0VsZW1lbnRzID0gcHJldkVsZW1lbnRzLmN1cnJlbnQ7XG5cbiAgICBpZiAoZWxlbWVudHMgIT09IHByZXZpb3VzRWxlbWVudHMpIHtcbiAgICAgIGNsZWFudXAocHJldmlvdXNFbGVtZW50cyk7XG4gICAgICBjb25zdCBlbnRyaWVzID0gZWxlbWVudHMubWFwKGVsZW1lbnQgPT4ge1xuICAgICAgICBjb25zdCBzY3JvbGxhYmxlRWxlbWVudCA9IGdldFNjcm9sbGFibGVFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgIGlmIChzY3JvbGxhYmxlRWxlbWVudCkge1xuICAgICAgICAgIHNjcm9sbGFibGVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhhbmRsZVNjcm9sbCwge1xuICAgICAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBbc2Nyb2xsYWJsZUVsZW1lbnQsIGdldFNjcm9sbENvb3JkaW5hdGVzKHNjcm9sbGFibGVFbGVtZW50KV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0pLmZpbHRlcihlbnRyeSA9PiBlbnRyeSAhPSBudWxsKTtcbiAgICAgIHNldFNjcm9sbENvb3JkaW5hdGVzKGVudHJpZXMubGVuZ3RoID8gbmV3IE1hcChlbnRyaWVzKSA6IG51bGwpO1xuICAgICAgcHJldkVsZW1lbnRzLmN1cnJlbnQgPSBlbGVtZW50cztcbiAgICB9XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYW51cChlbGVtZW50cyk7XG4gICAgICBjbGVhbnVwKHByZXZpb3VzRWxlbWVudHMpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjbGVhbnVwKGVsZW1lbnRzKSB7XG4gICAgICBlbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICBjb25zdCBzY3JvbGxhYmxlRWxlbWVudCA9IGdldFNjcm9sbGFibGVFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICBzY3JvbGxhYmxlRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogc2Nyb2xsYWJsZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlU2Nyb2xsKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2hhbmRsZVNjcm9sbCwgZWxlbWVudHNdKTtcbiAgcmV0dXJuIHVzZU1lbW8oKCkgPT4ge1xuICAgIGlmIChlbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBzY3JvbGxDb29yZGluYXRlcyA/IEFycmF5LmZyb20oc2Nyb2xsQ29vcmRpbmF0ZXMudmFsdWVzKCkpLnJlZHVjZSgoYWNjLCBjb29yZGluYXRlcykgPT4gYWRkKGFjYywgY29vcmRpbmF0ZXMpLCBkZWZhdWx0Q29vcmRpbmF0ZXMpIDogZ2V0U2Nyb2xsT2Zmc2V0cyhlbGVtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZmF1bHRDb29yZGluYXRlcztcbiAgfSwgW2VsZW1lbnRzLCBzY3JvbGxDb29yZGluYXRlc10pO1xufVxuXG5mdW5jdGlvbiB1c2VTY3JvbGxPZmZzZXRzRGVsdGEoc2Nyb2xsT2Zmc2V0cywgZGVwZW5kZW5jaWVzKSB7XG4gIGlmIChkZXBlbmRlbmNpZXMgPT09IHZvaWQgMCkge1xuICAgIGRlcGVuZGVuY2llcyA9IFtdO1xuICB9XG5cbiAgY29uc3QgaW5pdGlhbFNjcm9sbE9mZnNldHMgPSB1c2VSZWYobnVsbCk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaW5pdGlhbFNjcm9sbE9mZnNldHMuY3VycmVudCA9IG51bGw7XG4gIH0sIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgZGVwZW5kZW5jaWVzKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYXNTY3JvbGxPZmZzZXRzID0gc2Nyb2xsT2Zmc2V0cyAhPT0gZGVmYXVsdENvb3JkaW5hdGVzO1xuXG4gICAgaWYgKGhhc1Njcm9sbE9mZnNldHMgJiYgIWluaXRpYWxTY3JvbGxPZmZzZXRzLmN1cnJlbnQpIHtcbiAgICAgIGluaXRpYWxTY3JvbGxPZmZzZXRzLmN1cnJlbnQgPSBzY3JvbGxPZmZzZXRzO1xuICAgIH1cblxuICAgIGlmICghaGFzU2Nyb2xsT2Zmc2V0cyAmJiBpbml0aWFsU2Nyb2xsT2Zmc2V0cy5jdXJyZW50KSB7XG4gICAgICBpbml0aWFsU2Nyb2xsT2Zmc2V0cy5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH0sIFtzY3JvbGxPZmZzZXRzXSk7XG4gIHJldHVybiBpbml0aWFsU2Nyb2xsT2Zmc2V0cy5jdXJyZW50ID8gc3VidHJhY3Qoc2Nyb2xsT2Zmc2V0cywgaW5pdGlhbFNjcm9sbE9mZnNldHMuY3VycmVudCkgOiBkZWZhdWx0Q29vcmRpbmF0ZXM7XG59XG5cbmZ1bmN0aW9uIHVzZVNlbnNvclNldHVwKHNlbnNvcnMpIHtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWNhblVzZURPTSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHRlYXJkb3duRm5zID0gc2Vuc29ycy5tYXAoX3JlZiA9PiB7XG4gICAgICBsZXQge1xuICAgICAgICBzZW5zb3JcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgcmV0dXJuIHNlbnNvci5zZXR1cCA9PSBudWxsID8gdm9pZCAwIDogc2Vuc29yLnNldHVwKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgdGVhcmRvd24gb2YgdGVhcmRvd25GbnMpIHtcbiAgICAgICAgdGVhcmRvd24gPT0gbnVsbCA/IHZvaWQgMCA6IHRlYXJkb3duKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgLy8gVE8tRE86IFNlbnNvcnMgbGVuZ3RoIGNvdWxkIHRoZW9yZXRpY2FsbHkgY2hhbmdlIHdoaWNoIHdvdWxkIG5vdCBiZSBhIHZhbGlkIGRlcGVuZGVuY3lcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBzZW5zb3JzLm1hcChfcmVmMiA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHNlbnNvclxuICAgIH0gPSBfcmVmMjtcbiAgICByZXR1cm4gc2Vuc29yO1xuICB9KSk7XG59XG5cbmZ1bmN0aW9uIHVzZVN5bnRoZXRpY0xpc3RlbmVycyhsaXN0ZW5lcnMsIGlkKSB7XG4gIHJldHVybiB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gbGlzdGVuZXJzLnJlZHVjZSgoYWNjLCBfcmVmKSA9PiB7XG4gICAgICBsZXQge1xuICAgICAgICBldmVudE5hbWUsXG4gICAgICAgIGhhbmRsZXJcbiAgICAgIH0gPSBfcmVmO1xuXG4gICAgICBhY2NbZXZlbnROYW1lXSA9IGV2ZW50ID0+IHtcbiAgICAgICAgaGFuZGxlcihldmVudCwgaWQpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gIH0sIFtsaXN0ZW5lcnMsIGlkXSk7XG59XG5cbmZ1bmN0aW9uIHVzZVdpbmRvd1JlY3QoZWxlbWVudCkge1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiBlbGVtZW50ID8gZ2V0V2luZG93Q2xpZW50UmVjdChlbGVtZW50KSA6IG51bGwsIFtlbGVtZW50XSk7XG59XG5cbmNvbnN0IGRlZmF1bHRWYWx1ZSQyID0gW107XG5mdW5jdGlvbiB1c2VSZWN0cyhlbGVtZW50cywgbWVhc3VyZSkge1xuICBpZiAobWVhc3VyZSA9PT0gdm9pZCAwKSB7XG4gICAgbWVhc3VyZSA9IGdldENsaWVudFJlY3Q7XG4gIH1cblxuICBjb25zdCBbZmlyc3RFbGVtZW50XSA9IGVsZW1lbnRzO1xuICBjb25zdCB3aW5kb3dSZWN0ID0gdXNlV2luZG93UmVjdChmaXJzdEVsZW1lbnQgPyBnZXRXaW5kb3coZmlyc3RFbGVtZW50KSA6IG51bGwpO1xuICBjb25zdCBbcmVjdHMsIG1lYXN1cmVSZWN0c10gPSB1c2VSZWR1Y2VyKHJlZHVjZXIsIGRlZmF1bHRWYWx1ZSQyKTtcbiAgY29uc3QgcmVzaXplT2JzZXJ2ZXIgPSB1c2VSZXNpemVPYnNlcnZlcih7XG4gICAgY2FsbGJhY2s6IG1lYXN1cmVSZWN0c1xuICB9KTtcblxuICBpZiAoZWxlbWVudHMubGVuZ3RoID4gMCAmJiByZWN0cyA9PT0gZGVmYXVsdFZhbHVlJDIpIHtcbiAgICBtZWFzdXJlUmVjdHMoKTtcbiAgfVxuXG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChlbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgIGVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiByZXNpemVPYnNlcnZlciA9PSBudWxsID8gdm9pZCAwIDogcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc2l6ZU9ic2VydmVyID09IG51bGwgPyB2b2lkIDAgOiByZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICBtZWFzdXJlUmVjdHMoKTtcbiAgICB9XG4gIH0sIFtlbGVtZW50c10pO1xuICByZXR1cm4gcmVjdHM7XG5cbiAgZnVuY3Rpb24gcmVkdWNlcigpIHtcbiAgICBpZiAoIWVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZSQyO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50cy5tYXAoZWxlbWVudCA9PiBpc0RvY3VtZW50U2Nyb2xsaW5nRWxlbWVudChlbGVtZW50KSA/IHdpbmRvd1JlY3QgOiBuZXcgUmVjdChtZWFzdXJlKGVsZW1lbnQpLCBlbGVtZW50KSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TWVhc3VyYWJsZU5vZGUobm9kZSkge1xuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGNvbnN0IGZpcnN0Q2hpbGQgPSBub2RlLmNoaWxkcmVuWzBdO1xuICByZXR1cm4gaXNIVE1MRWxlbWVudChmaXJzdENoaWxkKSA/IGZpcnN0Q2hpbGQgOiBub2RlO1xufVxuXG5mdW5jdGlvbiB1c2VEcmFnT3ZlcmxheU1lYXN1cmluZyhfcmVmKSB7XG4gIGxldCB7XG4gICAgbWVhc3VyZVxuICB9ID0gX3JlZjtcbiAgY29uc3QgW3JlY3QsIHNldFJlY3RdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IGhhbmRsZVJlc2l6ZSA9IHVzZUNhbGxiYWNrKGVudHJpZXMgPT4ge1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgdGFyZ2V0XG4gICAgfSBvZiBlbnRyaWVzKSB7XG4gICAgICBpZiAoaXNIVE1MRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgICAgIHNldFJlY3QocmVjdCA9PiB7XG4gICAgICAgICAgY29uc3QgbmV3UmVjdCA9IG1lYXN1cmUodGFyZ2V0KTtcbiAgICAgICAgICByZXR1cm4gcmVjdCA/IHsgLi4ucmVjdCxcbiAgICAgICAgICAgIHdpZHRoOiBuZXdSZWN0LndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBuZXdSZWN0LmhlaWdodFxuICAgICAgICAgIH0gOiBuZXdSZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LCBbbWVhc3VyZV0pO1xuICBjb25zdCByZXNpemVPYnNlcnZlciA9IHVzZVJlc2l6ZU9ic2VydmVyKHtcbiAgICBjYWxsYmFjazogaGFuZGxlUmVzaXplXG4gIH0pO1xuICBjb25zdCBoYW5kbGVOb2RlQ2hhbmdlID0gdXNlQ2FsbGJhY2soZWxlbWVudCA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IGdldE1lYXN1cmFibGVOb2RlKGVsZW1lbnQpO1xuICAgIHJlc2l6ZU9ic2VydmVyID09IG51bGwgPyB2b2lkIDAgOiByZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG5cbiAgICBpZiAobm9kZSkge1xuICAgICAgcmVzaXplT2JzZXJ2ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc2l6ZU9ic2VydmVyLm9ic2VydmUobm9kZSk7XG4gICAgfVxuXG4gICAgc2V0UmVjdChub2RlID8gbWVhc3VyZShub2RlKSA6IG51bGwpO1xuICB9LCBbbWVhc3VyZSwgcmVzaXplT2JzZXJ2ZXJdKTtcbiAgY29uc3QgW25vZGVSZWYsIHNldFJlZl0gPSB1c2VOb2RlUmVmKGhhbmRsZU5vZGVDaGFuZ2UpO1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiAoe1xuICAgIG5vZGVSZWYsXG4gICAgcmVjdCxcbiAgICBzZXRSZWZcbiAgfSksIFtyZWN0LCBub2RlUmVmLCBzZXRSZWZdKTtcbn1cblxuY29uc3QgZGVmYXVsdFNlbnNvcnMgPSBbe1xuICBzZW5zb3I6IFBvaW50ZXJTZW5zb3IsXG4gIG9wdGlvbnM6IHt9XG59LCB7XG4gIHNlbnNvcjogS2V5Ym9hcmRTZW5zb3IsXG4gIG9wdGlvbnM6IHt9XG59XTtcbmNvbnN0IGRlZmF1bHREYXRhID0ge1xuICBjdXJyZW50OiB7fVxufTtcbmNvbnN0IGRlZmF1bHRNZWFzdXJpbmdDb25maWd1cmF0aW9uID0ge1xuICBkcmFnZ2FibGU6IHtcbiAgICBtZWFzdXJlOiBnZXRUcmFuc2Zvcm1BZ25vc3RpY0NsaWVudFJlY3RcbiAgfSxcbiAgZHJvcHBhYmxlOiB7XG4gICAgbWVhc3VyZTogZ2V0VHJhbnNmb3JtQWdub3N0aWNDbGllbnRSZWN0LFxuICAgIHN0cmF0ZWd5OiBNZWFzdXJpbmdTdHJhdGVneS5XaGlsZURyYWdnaW5nLFxuICAgIGZyZXF1ZW5jeTogTWVhc3VyaW5nRnJlcXVlbmN5Lk9wdGltaXplZFxuICB9LFxuICBkcmFnT3ZlcmxheToge1xuICAgIG1lYXN1cmU6IGdldENsaWVudFJlY3RcbiAgfVxufTtcblxuY2xhc3MgRHJvcHBhYmxlQ29udGFpbmVyc01hcCBleHRlbmRzIE1hcCB7XG4gIGdldChpZCkge1xuICAgIHZhciBfc3VwZXIkZ2V0O1xuXG4gICAgcmV0dXJuIGlkICE9IG51bGwgPyAoX3N1cGVyJGdldCA9IHN1cGVyLmdldChpZCkpICE9IG51bGwgPyBfc3VwZXIkZ2V0IDogdW5kZWZpbmVkIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnZhbHVlcygpKTtcbiAgfVxuXG4gIGdldEVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmZpbHRlcihfcmVmID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIGRpc2FibGVkXG4gICAgICB9ID0gX3JlZjtcbiAgICAgIHJldHVybiAhZGlzYWJsZWQ7XG4gICAgfSk7XG4gIH1cblxuICBnZXROb2RlRm9yKGlkKSB7XG4gICAgdmFyIF90aGlzJGdldCRub2RlJGN1cnJlbiwgX3RoaXMkZ2V0O1xuXG4gICAgcmV0dXJuIChfdGhpcyRnZXQkbm9kZSRjdXJyZW4gPSAoX3RoaXMkZ2V0ID0gdGhpcy5nZXQoaWQpKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkZ2V0Lm5vZGUuY3VycmVudCkgIT0gbnVsbCA/IF90aGlzJGdldCRub2RlJGN1cnJlbiA6IHVuZGVmaW5lZDtcbiAgfVxuXG59XG5cbmNvbnN0IGRlZmF1bHRQdWJsaWNDb250ZXh0ID0ge1xuICBhY3RpdmF0b3JFdmVudDogbnVsbCxcbiAgYWN0aXZlOiBudWxsLFxuICBhY3RpdmVOb2RlOiBudWxsLFxuICBhY3RpdmVOb2RlUmVjdDogbnVsbCxcbiAgY29sbGlzaW9uczogbnVsbCxcbiAgY29udGFpbmVyTm9kZVJlY3Q6IG51bGwsXG4gIGRyYWdnYWJsZU5vZGVzOiAvKiNfX1BVUkVfXyovbmV3IE1hcCgpLFxuICBkcm9wcGFibGVSZWN0czogLyojX19QVVJFX18qL25ldyBNYXAoKSxcbiAgZHJvcHBhYmxlQ29udGFpbmVyczogLyojX19QVVJFX18qL25ldyBEcm9wcGFibGVDb250YWluZXJzTWFwKCksXG4gIG92ZXI6IG51bGwsXG4gIGRyYWdPdmVybGF5OiB7XG4gICAgbm9kZVJlZjoge1xuICAgICAgY3VycmVudDogbnVsbFxuICAgIH0sXG4gICAgcmVjdDogbnVsbCxcbiAgICBzZXRSZWY6IG5vb3BcbiAgfSxcbiAgc2Nyb2xsYWJsZUFuY2VzdG9yczogW10sXG4gIHNjcm9sbGFibGVBbmNlc3RvclJlY3RzOiBbXSxcbiAgbWVhc3VyaW5nQ29uZmlndXJhdGlvbjogZGVmYXVsdE1lYXN1cmluZ0NvbmZpZ3VyYXRpb24sXG4gIG1lYXN1cmVEcm9wcGFibGVDb250YWluZXJzOiBub29wLFxuICB3aW5kb3dSZWN0OiBudWxsLFxuICBtZWFzdXJpbmdTY2hlZHVsZWQ6IGZhbHNlXG59O1xuY29uc3QgZGVmYXVsdEludGVybmFsQ29udGV4dCA9IHtcbiAgYWN0aXZhdG9yRXZlbnQ6IG51bGwsXG4gIGFjdGl2YXRvcnM6IFtdLFxuICBhY3RpdmU6IG51bGwsXG4gIGFjdGl2ZU5vZGVSZWN0OiBudWxsLFxuICBhcmlhRGVzY3JpYmVkQnlJZDoge1xuICAgIGRyYWdnYWJsZTogJydcbiAgfSxcbiAgZGlzcGF0Y2g6IG5vb3AsXG4gIGRyYWdnYWJsZU5vZGVzOiAvKiNfX1BVUkVfXyovbmV3IE1hcCgpLFxuICBvdmVyOiBudWxsLFxuICBtZWFzdXJlRHJvcHBhYmxlQ29udGFpbmVyczogbm9vcFxufTtcbmNvbnN0IEludGVybmFsQ29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KGRlZmF1bHRJbnRlcm5hbENvbnRleHQpO1xuY29uc3QgUHVibGljQ29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KGRlZmF1bHRQdWJsaWNDb250ZXh0KTtcblxuZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlKCkge1xuICByZXR1cm4ge1xuICAgIGRyYWdnYWJsZToge1xuICAgICAgYWN0aXZlOiBudWxsLFxuICAgICAgaW5pdGlhbENvb3JkaW5hdGVzOiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sXG4gICAgICBub2RlczogbmV3IE1hcCgpLFxuICAgICAgdHJhbnNsYXRlOiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH1cbiAgICB9LFxuICAgIGRyb3BwYWJsZToge1xuICAgICAgY29udGFpbmVyczogbmV3IERyb3BwYWJsZUNvbnRhaW5lcnNNYXAoKVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBBY3Rpb24uRHJhZ1N0YXJ0OlxuICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsXG4gICAgICAgIGRyYWdnYWJsZTogeyAuLi5zdGF0ZS5kcmFnZ2FibGUsXG4gICAgICAgICAgaW5pdGlhbENvb3JkaW5hdGVzOiBhY3Rpb24uaW5pdGlhbENvb3JkaW5hdGVzLFxuICAgICAgICAgIGFjdGl2ZTogYWN0aW9uLmFjdGl2ZVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgY2FzZSBBY3Rpb24uRHJhZ01vdmU6XG4gICAgICBpZiAoIXN0YXRlLmRyYWdnYWJsZS5hY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4geyAuLi5zdGF0ZSxcbiAgICAgICAgZHJhZ2dhYmxlOiB7IC4uLnN0YXRlLmRyYWdnYWJsZSxcbiAgICAgICAgICB0cmFuc2xhdGU6IHtcbiAgICAgICAgICAgIHg6IGFjdGlvbi5jb29yZGluYXRlcy54IC0gc3RhdGUuZHJhZ2dhYmxlLmluaXRpYWxDb29yZGluYXRlcy54LFxuICAgICAgICAgICAgeTogYWN0aW9uLmNvb3JkaW5hdGVzLnkgLSBzdGF0ZS5kcmFnZ2FibGUuaW5pdGlhbENvb3JkaW5hdGVzLnlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICBjYXNlIEFjdGlvbi5EcmFnRW5kOlxuICAgIGNhc2UgQWN0aW9uLkRyYWdDYW5jZWw6XG4gICAgICByZXR1cm4geyAuLi5zdGF0ZSxcbiAgICAgICAgZHJhZ2dhYmxlOiB7IC4uLnN0YXRlLmRyYWdnYWJsZSxcbiAgICAgICAgICBhY3RpdmU6IG51bGwsXG4gICAgICAgICAgaW5pdGlhbENvb3JkaW5hdGVzOiB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdHJhbnNsYXRlOiB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgIGNhc2UgQWN0aW9uLlJlZ2lzdGVyRHJvcHBhYmxlOlxuICAgICAge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZWxlbWVudFxuICAgICAgICB9ID0gYWN0aW9uO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaWRcbiAgICAgICAgfSA9IGVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lcnMgPSBuZXcgRHJvcHBhYmxlQ29udGFpbmVyc01hcChzdGF0ZS5kcm9wcGFibGUuY29udGFpbmVycyk7XG4gICAgICAgIGNvbnRhaW5lcnMuc2V0KGlkLCBlbGVtZW50KTtcbiAgICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsXG4gICAgICAgICAgZHJvcHBhYmxlOiB7IC4uLnN0YXRlLmRyb3BwYWJsZSxcbiAgICAgICAgICAgIGNvbnRhaW5lcnNcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICBjYXNlIEFjdGlvbi5TZXREcm9wcGFibGVEaXNhYmxlZDpcbiAgICAgIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGlkLFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICBkaXNhYmxlZFxuICAgICAgICB9ID0gYWN0aW9uO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gc3RhdGUuZHJvcHBhYmxlLmNvbnRhaW5lcnMuZ2V0KGlkKTtcblxuICAgICAgICBpZiAoIWVsZW1lbnQgfHwga2V5ICE9PSBlbGVtZW50LmtleSkge1xuICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lcnMgPSBuZXcgRHJvcHBhYmxlQ29udGFpbmVyc01hcChzdGF0ZS5kcm9wcGFibGUuY29udGFpbmVycyk7XG4gICAgICAgIGNvbnRhaW5lcnMuc2V0KGlkLCB7IC4uLmVsZW1lbnQsXG4gICAgICAgICAgZGlzYWJsZWRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IC4uLnN0YXRlLFxuICAgICAgICAgIGRyb3BwYWJsZTogeyAuLi5zdGF0ZS5kcm9wcGFibGUsXG4gICAgICAgICAgICBjb250YWluZXJzXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgY2FzZSBBY3Rpb24uVW5yZWdpc3RlckRyb3BwYWJsZTpcbiAgICAgIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGlkLFxuICAgICAgICAgIGtleVxuICAgICAgICB9ID0gYWN0aW9uO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gc3RhdGUuZHJvcHBhYmxlLmNvbnRhaW5lcnMuZ2V0KGlkKTtcblxuICAgICAgICBpZiAoIWVsZW1lbnQgfHwga2V5ICE9PSBlbGVtZW50LmtleSkge1xuICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lcnMgPSBuZXcgRHJvcHBhYmxlQ29udGFpbmVyc01hcChzdGF0ZS5kcm9wcGFibGUuY29udGFpbmVycyk7XG4gICAgICAgIGNvbnRhaW5lcnMuZGVsZXRlKGlkKTtcbiAgICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsXG4gICAgICAgICAgZHJvcHBhYmxlOiB7IC4uLnN0YXRlLmRyb3BwYWJsZSxcbiAgICAgICAgICAgIGNvbnRhaW5lcnNcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVzdG9yZUZvY3VzKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBkaXNhYmxlZFxuICB9ID0gX3JlZjtcbiAgY29uc3Qge1xuICAgIGFjdGl2ZSxcbiAgICBhY3RpdmF0b3JFdmVudCxcbiAgICBkcmFnZ2FibGVOb2Rlc1xuICB9ID0gdXNlQ29udGV4dChJbnRlcm5hbENvbnRleHQpO1xuICBjb25zdCBwcmV2aW91c0FjdGl2YXRvckV2ZW50ID0gdXNlUHJldmlvdXMoYWN0aXZhdG9yRXZlbnQpO1xuICBjb25zdCBwcmV2aW91c0FjdGl2ZUlkID0gdXNlUHJldmlvdXMoYWN0aXZlID09IG51bGwgPyB2b2lkIDAgOiBhY3RpdmUuaWQpOyAvLyBSZXN0b3JlIGtleWJvYXJkIGZvY3VzIG9uIHRoZSBhY3RpdmF0b3Igbm9kZVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFhY3RpdmF0b3JFdmVudCAmJiBwcmV2aW91c0FjdGl2YXRvckV2ZW50ICYmIHByZXZpb3VzQWN0aXZlSWQgIT0gbnVsbCkge1xuICAgICAgaWYgKCFpc0tleWJvYXJkRXZlbnQocHJldmlvdXNBY3RpdmF0b3JFdmVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gcHJldmlvdXNBY3RpdmF0b3JFdmVudC50YXJnZXQpIHtcbiAgICAgICAgLy8gTm8gbmVlZCB0byByZXN0b3JlIGZvY3VzXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZHJhZ2dhYmxlTm9kZSA9IGRyYWdnYWJsZU5vZGVzLmdldChwcmV2aW91c0FjdGl2ZUlkKTtcblxuICAgICAgaWYgKCFkcmFnZ2FibGVOb2RlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qge1xuICAgICAgICBhY3RpdmF0b3JOb2RlLFxuICAgICAgICBub2RlXG4gICAgICB9ID0gZHJhZ2dhYmxlTm9kZTtcblxuICAgICAgaWYgKCFhY3RpdmF0b3JOb2RlLmN1cnJlbnQgJiYgIW5vZGUuY3VycmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBbYWN0aXZhdG9yTm9kZS5jdXJyZW50LCBub2RlLmN1cnJlbnRdKSB7XG4gICAgICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBmb2N1c2FibGVOb2RlID0gZmluZEZpcnN0Rm9jdXNhYmxlTm9kZShlbGVtZW50KTtcblxuICAgICAgICAgIGlmIChmb2N1c2FibGVOb2RlKSB7XG4gICAgICAgICAgICBmb2N1c2FibGVOb2RlLmZvY3VzKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2FjdGl2YXRvckV2ZW50LCBkaXNhYmxlZCwgZHJhZ2dhYmxlTm9kZXMsIHByZXZpb3VzQWN0aXZlSWQsIHByZXZpb3VzQWN0aXZhdG9yRXZlbnRdKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGFwcGx5TW9kaWZpZXJzKG1vZGlmaWVycywgX3JlZikge1xuICBsZXQge1xuICAgIHRyYW5zZm9ybSxcbiAgICAuLi5hcmdzXG4gIH0gPSBfcmVmO1xuICByZXR1cm4gbW9kaWZpZXJzICE9IG51bGwgJiYgbW9kaWZpZXJzLmxlbmd0aCA/IG1vZGlmaWVycy5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBtb2RpZmllcikgPT4ge1xuICAgIHJldHVybiBtb2RpZmllcih7XG4gICAgICB0cmFuc2Zvcm06IGFjY3VtdWxhdG9yLFxuICAgICAgLi4uYXJnc1xuICAgIH0pO1xuICB9LCB0cmFuc2Zvcm0pIDogdHJhbnNmb3JtO1xufVxuXG5mdW5jdGlvbiB1c2VNZWFzdXJpbmdDb25maWd1cmF0aW9uKGNvbmZpZykge1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiAoe1xuICAgIGRyYWdnYWJsZTogeyAuLi5kZWZhdWx0TWVhc3VyaW5nQ29uZmlndXJhdGlvbi5kcmFnZ2FibGUsXG4gICAgICAuLi4oY29uZmlnID09IG51bGwgPyB2b2lkIDAgOiBjb25maWcuZHJhZ2dhYmxlKVxuICAgIH0sXG4gICAgZHJvcHBhYmxlOiB7IC4uLmRlZmF1bHRNZWFzdXJpbmdDb25maWd1cmF0aW9uLmRyb3BwYWJsZSxcbiAgICAgIC4uLihjb25maWcgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbmZpZy5kcm9wcGFibGUpXG4gICAgfSxcbiAgICBkcmFnT3ZlcmxheTogeyAuLi5kZWZhdWx0TWVhc3VyaW5nQ29uZmlndXJhdGlvbi5kcmFnT3ZlcmxheSxcbiAgICAgIC4uLihjb25maWcgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbmZpZy5kcmFnT3ZlcmxheSlcbiAgICB9XG4gIH0pLCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFtjb25maWcgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbmZpZy5kcmFnZ2FibGUsIGNvbmZpZyA9PSBudWxsID8gdm9pZCAwIDogY29uZmlnLmRyb3BwYWJsZSwgY29uZmlnID09IG51bGwgPyB2b2lkIDAgOiBjb25maWcuZHJhZ092ZXJsYXldKTtcbn1cblxuZnVuY3Rpb24gdXNlTGF5b3V0U2hpZnRTY3JvbGxDb21wZW5zYXRpb24oX3JlZikge1xuICBsZXQge1xuICAgIGFjdGl2ZU5vZGUsXG4gICAgbWVhc3VyZSxcbiAgICBpbml0aWFsUmVjdCxcbiAgICBjb25maWcgPSB0cnVlXG4gIH0gPSBfcmVmO1xuICBjb25zdCBpbml0aWFsaXplZCA9IHVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IHtcbiAgICB4LFxuICAgIHlcbiAgfSA9IHR5cGVvZiBjb25maWcgPT09ICdib29sZWFuJyA/IHtcbiAgICB4OiBjb25maWcsXG4gICAgeTogY29uZmlnXG4gIH0gOiBjb25maWc7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGRpc2FibGVkID0gIXggJiYgIXk7XG5cbiAgICBpZiAoZGlzYWJsZWQgfHwgIWFjdGl2ZU5vZGUpIHtcbiAgICAgIGluaXRpYWxpemVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaW5pdGlhbGl6ZWQuY3VycmVudCB8fCAhaW5pdGlhbFJlY3QpIHtcbiAgICAgIC8vIFJldHVybiBlYXJseSBpZiBsYXlvdXQgc2hpZnQgc2Nyb2xsIGNvbXBlbnNhdGlvbiB3YXMgYWxyZWFkeSBhdHRlbXB0ZWRcbiAgICAgIC8vIG9yIGlmIHRoZXJlIGlzIG5vIGluaXRpYWxSZWN0IHRvIGNvbXBhcmUgdG8uXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBHZXQgdGhlIG1vc3QgdXAgdG8gZGF0ZSBub2RlIHJlZiBmb3IgdGhlIGFjdGl2ZSBkcmFnZ2FibGVcblxuXG4gICAgY29uc3Qgbm9kZSA9IGFjdGl2ZU5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IGFjdGl2ZU5vZGUubm9kZS5jdXJyZW50O1xuXG4gICAgaWYgKCFub2RlIHx8IG5vZGUuaXNDb25uZWN0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAvLyBSZXR1cm4gZWFybHkgaWYgdGhlcmUgaXMgbm8gYXR0YWNoZWQgbm9kZSByZWYgb3IgaWYgdGhlIG5vZGUgaXNcbiAgICAgIC8vIGRpc2Nvbm5lY3RlZCBmcm9tIHRoZSBkb2N1bWVudC5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCByZWN0ID0gbWVhc3VyZShub2RlKTtcbiAgICBjb25zdCByZWN0RGVsdGEgPSBnZXRSZWN0RGVsdGEocmVjdCwgaW5pdGlhbFJlY3QpO1xuXG4gICAgaWYgKCF4KSB7XG4gICAgICByZWN0RGVsdGEueCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKCF5KSB7XG4gICAgICByZWN0RGVsdGEueSA9IDA7XG4gICAgfSAvLyBPbmx5IHBlcmZvcm0gbGF5b3V0IHNoaWZ0IHNjcm9sbCBjb21wZW5zYXRpb24gb25jZVxuXG5cbiAgICBpbml0aWFsaXplZC5jdXJyZW50ID0gdHJ1ZTtcblxuICAgIGlmIChNYXRoLmFicyhyZWN0RGVsdGEueCkgPiAwIHx8IE1hdGguYWJzKHJlY3REZWx0YS55KSA+IDApIHtcbiAgICAgIGNvbnN0IGZpcnN0U2Nyb2xsYWJsZUFuY2VzdG9yID0gZ2V0Rmlyc3RTY3JvbGxhYmxlQW5jZXN0b3Iobm9kZSk7XG5cbiAgICAgIGlmIChmaXJzdFNjcm9sbGFibGVBbmNlc3Rvcikge1xuICAgICAgICBmaXJzdFNjcm9sbGFibGVBbmNlc3Rvci5zY3JvbGxCeSh7XG4gICAgICAgICAgdG9wOiByZWN0RGVsdGEueSxcbiAgICAgICAgICBsZWZ0OiByZWN0RGVsdGEueFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFthY3RpdmVOb2RlLCB4LCB5LCBpbml0aWFsUmVjdCwgbWVhc3VyZV0pO1xufVxuXG5jb25zdCBBY3RpdmVEcmFnZ2FibGVDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQoeyAuLi5kZWZhdWx0Q29vcmRpbmF0ZXMsXG4gIHNjYWxlWDogMSxcbiAgc2NhbGVZOiAxXG59KTtcbnZhciBTdGF0dXM7XG5cbihmdW5jdGlvbiAoU3RhdHVzKSB7XG4gIFN0YXR1c1tTdGF0dXNbXCJVbmluaXRpYWxpemVkXCJdID0gMF0gPSBcIlVuaW5pdGlhbGl6ZWRcIjtcbiAgU3RhdHVzW1N0YXR1c1tcIkluaXRpYWxpemluZ1wiXSA9IDFdID0gXCJJbml0aWFsaXppbmdcIjtcbiAgU3RhdHVzW1N0YXR1c1tcIkluaXRpYWxpemVkXCJdID0gMl0gPSBcIkluaXRpYWxpemVkXCI7XG59KShTdGF0dXMgfHwgKFN0YXR1cyA9IHt9KSk7XG5cbmNvbnN0IERuZENvbnRleHQgPSAvKiNfX1BVUkVfXyovbWVtbyhmdW5jdGlvbiBEbmRDb250ZXh0KF9yZWYpIHtcbiAgdmFyIF9zZW5zb3JDb250ZXh0JGN1cnJlbiwgX2RyYWdPdmVybGF5JG5vZGVSZWYkLCBfZHJhZ092ZXJsYXkkcmVjdCwgX292ZXIkcmVjdDtcblxuICBsZXQge1xuICAgIGlkLFxuICAgIGFjY2Vzc2liaWxpdHksXG4gICAgYXV0b1Njcm9sbCA9IHRydWUsXG4gICAgY2hpbGRyZW4sXG4gICAgc2Vuc29ycyA9IGRlZmF1bHRTZW5zb3JzLFxuICAgIGNvbGxpc2lvbkRldGVjdGlvbiA9IHJlY3RJbnRlcnNlY3Rpb24sXG4gICAgbWVhc3VyaW5nLFxuICAgIG1vZGlmaWVycyxcbiAgICAuLi5wcm9wc1xuICB9ID0gX3JlZjtcbiAgY29uc3Qgc3RvcmUgPSB1c2VSZWR1Y2VyKHJlZHVjZXIsIHVuZGVmaW5lZCwgZ2V0SW5pdGlhbFN0YXRlKTtcbiAgY29uc3QgW3N0YXRlLCBkaXNwYXRjaF0gPSBzdG9yZTtcbiAgY29uc3QgW2Rpc3BhdGNoTW9uaXRvckV2ZW50LCByZWdpc3Rlck1vbml0b3JMaXN0ZW5lcl0gPSB1c2VEbmRNb25pdG9yUHJvdmlkZXIoKTtcbiAgY29uc3QgW3N0YXR1cywgc2V0U3RhdHVzXSA9IHVzZVN0YXRlKFN0YXR1cy5VbmluaXRpYWxpemVkKTtcbiAgY29uc3QgaXNJbml0aWFsaXplZCA9IHN0YXR1cyA9PT0gU3RhdHVzLkluaXRpYWxpemVkO1xuICBjb25zdCB7XG4gICAgZHJhZ2dhYmxlOiB7XG4gICAgICBhY3RpdmU6IGFjdGl2ZUlkLFxuICAgICAgbm9kZXM6IGRyYWdnYWJsZU5vZGVzLFxuICAgICAgdHJhbnNsYXRlXG4gICAgfSxcbiAgICBkcm9wcGFibGU6IHtcbiAgICAgIGNvbnRhaW5lcnM6IGRyb3BwYWJsZUNvbnRhaW5lcnNcbiAgICB9XG4gIH0gPSBzdGF0ZTtcbiAgY29uc3Qgbm9kZSA9IGFjdGl2ZUlkID8gZHJhZ2dhYmxlTm9kZXMuZ2V0KGFjdGl2ZUlkKSA6IG51bGw7XG4gIGNvbnN0IGFjdGl2ZVJlY3RzID0gdXNlUmVmKHtcbiAgICBpbml0aWFsOiBudWxsLFxuICAgIHRyYW5zbGF0ZWQ6IG51bGxcbiAgfSk7XG4gIGNvbnN0IGFjdGl2ZSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHZhciBfbm9kZSRkYXRhO1xuXG4gICAgcmV0dXJuIGFjdGl2ZUlkICE9IG51bGwgPyB7XG4gICAgICBpZDogYWN0aXZlSWQsXG4gICAgICAvLyBJdCdzIHBvc3NpYmxlIGZvciB0aGUgYWN0aXZlIG5vZGUgdG8gdW5tb3VudCB3aGlsZSBkcmFnZ2luZ1xuICAgICAgZGF0YTogKF9ub2RlJGRhdGEgPSBub2RlID09IG51bGwgPyB2b2lkIDAgOiBub2RlLmRhdGEpICE9IG51bGwgPyBfbm9kZSRkYXRhIDogZGVmYXVsdERhdGEsXG4gICAgICByZWN0OiBhY3RpdmVSZWN0c1xuICAgIH0gOiBudWxsO1xuICB9LCBbYWN0aXZlSWQsIG5vZGVdKTtcbiAgY29uc3QgYWN0aXZlUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBbYWN0aXZlU2Vuc29yLCBzZXRBY3RpdmVTZW5zb3JdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFthY3RpdmF0b3JFdmVudCwgc2V0QWN0aXZhdG9yRXZlbnRdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IGxhdGVzdFByb3BzID0gdXNlTGF0ZXN0VmFsdWUocHJvcHMsIE9iamVjdC52YWx1ZXMocHJvcHMpKTtcbiAgY29uc3QgZHJhZ2dhYmxlRGVzY3JpYmVkQnlJZCA9IHVzZVVuaXF1ZUlkKFwiRG5kRGVzY3JpYmVkQnlcIiwgaWQpO1xuICBjb25zdCBlbmFibGVkRHJvcHBhYmxlQ29udGFpbmVycyA9IHVzZU1lbW8oKCkgPT4gZHJvcHBhYmxlQ29udGFpbmVycy5nZXRFbmFibGVkKCksIFtkcm9wcGFibGVDb250YWluZXJzXSk7XG4gIGNvbnN0IG1lYXN1cmluZ0NvbmZpZ3VyYXRpb24gPSB1c2VNZWFzdXJpbmdDb25maWd1cmF0aW9uKG1lYXN1cmluZyk7XG4gIGNvbnN0IHtcbiAgICBkcm9wcGFibGVSZWN0cyxcbiAgICBtZWFzdXJlRHJvcHBhYmxlQ29udGFpbmVycyxcbiAgICBtZWFzdXJpbmdTY2hlZHVsZWRcbiAgfSA9IHVzZURyb3BwYWJsZU1lYXN1cmluZyhlbmFibGVkRHJvcHBhYmxlQ29udGFpbmVycywge1xuICAgIGRyYWdnaW5nOiBpc0luaXRpYWxpemVkLFxuICAgIGRlcGVuZGVuY2llczogW3RyYW5zbGF0ZS54LCB0cmFuc2xhdGUueV0sXG4gICAgY29uZmlnOiBtZWFzdXJpbmdDb25maWd1cmF0aW9uLmRyb3BwYWJsZVxuICB9KTtcbiAgY29uc3QgYWN0aXZlTm9kZSA9IHVzZUNhY2hlZE5vZGUoZHJhZ2dhYmxlTm9kZXMsIGFjdGl2ZUlkKTtcbiAgY29uc3QgYWN0aXZhdGlvbkNvb3JkaW5hdGVzID0gdXNlTWVtbygoKSA9PiBhY3RpdmF0b3JFdmVudCA/IGdldEV2ZW50Q29vcmRpbmF0ZXMoYWN0aXZhdG9yRXZlbnQpIDogbnVsbCwgW2FjdGl2YXRvckV2ZW50XSk7XG4gIGNvbnN0IGF1dG9TY3JvbGxPcHRpb25zID0gZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucygpO1xuICBjb25zdCBpbml0aWFsQWN0aXZlTm9kZVJlY3QgPSB1c2VJbml0aWFsUmVjdChhY3RpdmVOb2RlLCBtZWFzdXJpbmdDb25maWd1cmF0aW9uLmRyYWdnYWJsZS5tZWFzdXJlKTtcbiAgdXNlTGF5b3V0U2hpZnRTY3JvbGxDb21wZW5zYXRpb24oe1xuICAgIGFjdGl2ZU5vZGU6IGFjdGl2ZUlkID8gZHJhZ2dhYmxlTm9kZXMuZ2V0KGFjdGl2ZUlkKSA6IG51bGwsXG4gICAgY29uZmlnOiBhdXRvU2Nyb2xsT3B0aW9ucy5sYXlvdXRTaGlmdENvbXBlbnNhdGlvbixcbiAgICBpbml0aWFsUmVjdDogaW5pdGlhbEFjdGl2ZU5vZGVSZWN0LFxuICAgIG1lYXN1cmU6IG1lYXN1cmluZ0NvbmZpZ3VyYXRpb24uZHJhZ2dhYmxlLm1lYXN1cmVcbiAgfSk7XG4gIGNvbnN0IGFjdGl2ZU5vZGVSZWN0ID0gdXNlUmVjdChhY3RpdmVOb2RlLCBtZWFzdXJpbmdDb25maWd1cmF0aW9uLmRyYWdnYWJsZS5tZWFzdXJlLCBpbml0aWFsQWN0aXZlTm9kZVJlY3QpO1xuICBjb25zdCBjb250YWluZXJOb2RlUmVjdCA9IHVzZVJlY3QoYWN0aXZlTm9kZSA/IGFjdGl2ZU5vZGUucGFyZW50RWxlbWVudCA6IG51bGwpO1xuICBjb25zdCBzZW5zb3JDb250ZXh0ID0gdXNlUmVmKHtcbiAgICBhY3RpdmF0b3JFdmVudDogbnVsbCxcbiAgICBhY3RpdmU6IG51bGwsXG4gICAgYWN0aXZlTm9kZSxcbiAgICBjb2xsaXNpb25SZWN0OiBudWxsLFxuICAgIGNvbGxpc2lvbnM6IG51bGwsXG4gICAgZHJvcHBhYmxlUmVjdHMsXG4gICAgZHJhZ2dhYmxlTm9kZXMsXG4gICAgZHJhZ2dpbmdOb2RlOiBudWxsLFxuICAgIGRyYWdnaW5nTm9kZVJlY3Q6IG51bGwsXG4gICAgZHJvcHBhYmxlQ29udGFpbmVycyxcbiAgICBvdmVyOiBudWxsLFxuICAgIHNjcm9sbGFibGVBbmNlc3RvcnM6IFtdLFxuICAgIHNjcm9sbEFkanVzdGVkVHJhbnNsYXRlOiBudWxsXG4gIH0pO1xuICBjb25zdCBvdmVyTm9kZSA9IGRyb3BwYWJsZUNvbnRhaW5lcnMuZ2V0Tm9kZUZvcigoX3NlbnNvckNvbnRleHQkY3VycmVuID0gc2Vuc29yQ29udGV4dC5jdXJyZW50Lm92ZXIpID09IG51bGwgPyB2b2lkIDAgOiBfc2Vuc29yQ29udGV4dCRjdXJyZW4uaWQpO1xuICBjb25zdCBkcmFnT3ZlcmxheSA9IHVzZURyYWdPdmVybGF5TWVhc3VyaW5nKHtcbiAgICBtZWFzdXJlOiBtZWFzdXJpbmdDb25maWd1cmF0aW9uLmRyYWdPdmVybGF5Lm1lYXN1cmVcbiAgfSk7IC8vIFVzZSB0aGUgcmVjdCBvZiB0aGUgZHJhZyBvdmVybGF5IGlmIGl0IGlzIG1vdW50ZWRcblxuICBjb25zdCBkcmFnZ2luZ05vZGUgPSAoX2RyYWdPdmVybGF5JG5vZGVSZWYkID0gZHJhZ092ZXJsYXkubm9kZVJlZi5jdXJyZW50KSAhPSBudWxsID8gX2RyYWdPdmVybGF5JG5vZGVSZWYkIDogYWN0aXZlTm9kZTtcbiAgY29uc3QgZHJhZ2dpbmdOb2RlUmVjdCA9IGlzSW5pdGlhbGl6ZWQgPyAoX2RyYWdPdmVybGF5JHJlY3QgPSBkcmFnT3ZlcmxheS5yZWN0KSAhPSBudWxsID8gX2RyYWdPdmVybGF5JHJlY3QgOiBhY3RpdmVOb2RlUmVjdCA6IG51bGw7XG4gIGNvbnN0IHVzZXNEcmFnT3ZlcmxheSA9IEJvb2xlYW4oZHJhZ092ZXJsYXkubm9kZVJlZi5jdXJyZW50ICYmIGRyYWdPdmVybGF5LnJlY3QpOyAvLyBUaGUgZGVsdGEgYmV0d2VlbiB0aGUgcHJldmlvdXMgYW5kIG5ldyBwb3NpdGlvbiBvZiB0aGUgZHJhZ2dhYmxlIG5vZGVcbiAgLy8gaXMgb25seSByZWxldmFudCB3aGVuIHRoZXJlIGlzIG5vIGRyYWcgb3ZlcmxheVxuXG4gIGNvbnN0IG5vZGVSZWN0RGVsdGEgPSB1c2VSZWN0RGVsdGEodXNlc0RyYWdPdmVybGF5ID8gbnVsbCA6IGFjdGl2ZU5vZGVSZWN0KTsgLy8gR2V0IHRoZSB3aW5kb3cgcmVjdCBvZiB0aGUgZHJhZ2dpbmcgbm9kZVxuXG4gIGNvbnN0IHdpbmRvd1JlY3QgPSB1c2VXaW5kb3dSZWN0KGRyYWdnaW5nTm9kZSA/IGdldFdpbmRvdyhkcmFnZ2luZ05vZGUpIDogbnVsbCk7IC8vIEdldCBzY3JvbGxhYmxlIGFuY2VzdG9ycyBvZiB0aGUgZHJhZ2dpbmcgbm9kZVxuXG4gIGNvbnN0IHNjcm9sbGFibGVBbmNlc3RvcnMgPSB1c2VTY3JvbGxhYmxlQW5jZXN0b3JzKGlzSW5pdGlhbGl6ZWQgPyBvdmVyTm9kZSAhPSBudWxsID8gb3Zlck5vZGUgOiBhY3RpdmVOb2RlIDogbnVsbCk7XG4gIGNvbnN0IHNjcm9sbGFibGVBbmNlc3RvclJlY3RzID0gdXNlUmVjdHMoc2Nyb2xsYWJsZUFuY2VzdG9ycyk7IC8vIEFwcGx5IG1vZGlmaWVyc1xuXG4gIGNvbnN0IG1vZGlmaWVkVHJhbnNsYXRlID0gYXBwbHlNb2RpZmllcnMobW9kaWZpZXJzLCB7XG4gICAgdHJhbnNmb3JtOiB7XG4gICAgICB4OiB0cmFuc2xhdGUueCAtIG5vZGVSZWN0RGVsdGEueCxcbiAgICAgIHk6IHRyYW5zbGF0ZS55IC0gbm9kZVJlY3REZWx0YS55LFxuICAgICAgc2NhbGVYOiAxLFxuICAgICAgc2NhbGVZOiAxXG4gICAgfSxcbiAgICBhY3RpdmF0b3JFdmVudCxcbiAgICBhY3RpdmUsXG4gICAgYWN0aXZlTm9kZVJlY3QsXG4gICAgY29udGFpbmVyTm9kZVJlY3QsXG4gICAgZHJhZ2dpbmdOb2RlUmVjdCxcbiAgICBvdmVyOiBzZW5zb3JDb250ZXh0LmN1cnJlbnQub3ZlcixcbiAgICBvdmVybGF5Tm9kZVJlY3Q6IGRyYWdPdmVybGF5LnJlY3QsXG4gICAgc2Nyb2xsYWJsZUFuY2VzdG9ycyxcbiAgICBzY3JvbGxhYmxlQW5jZXN0b3JSZWN0cyxcbiAgICB3aW5kb3dSZWN0XG4gIH0pO1xuICBjb25zdCBwb2ludGVyQ29vcmRpbmF0ZXMgPSBhY3RpdmF0aW9uQ29vcmRpbmF0ZXMgPyBhZGQoYWN0aXZhdGlvbkNvb3JkaW5hdGVzLCB0cmFuc2xhdGUpIDogbnVsbDtcbiAgY29uc3Qgc2Nyb2xsT2Zmc2V0cyA9IHVzZVNjcm9sbE9mZnNldHMoc2Nyb2xsYWJsZUFuY2VzdG9ycyk7IC8vIFJlcHJlc2VudHMgdGhlIHNjcm9sbCBkZWx0YSBzaW5jZSBkcmFnZ2luZyB3YXMgaW5pdGlhdGVkXG5cbiAgY29uc3Qgc2Nyb2xsQWRqdXN0bWVudCA9IHVzZVNjcm9sbE9mZnNldHNEZWx0YShzY3JvbGxPZmZzZXRzKTsgLy8gUmVwcmVzZW50cyB0aGUgc2Nyb2xsIGRlbHRhIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGFjdGl2ZSBub2RlIHJlY3Qgd2FzIG1lYXN1cmVkXG5cbiAgY29uc3QgYWN0aXZlTm9kZVNjcm9sbERlbHRhID0gdXNlU2Nyb2xsT2Zmc2V0c0RlbHRhKHNjcm9sbE9mZnNldHMsIFthY3RpdmVOb2RlUmVjdF0pO1xuICBjb25zdCBzY3JvbGxBZGp1c3RlZFRyYW5zbGF0ZSA9IGFkZChtb2RpZmllZFRyYW5zbGF0ZSwgc2Nyb2xsQWRqdXN0bWVudCk7XG4gIGNvbnN0IGNvbGxpc2lvblJlY3QgPSBkcmFnZ2luZ05vZGVSZWN0ID8gZ2V0QWRqdXN0ZWRSZWN0KGRyYWdnaW5nTm9kZVJlY3QsIG1vZGlmaWVkVHJhbnNsYXRlKSA6IG51bGw7XG4gIGNvbnN0IGNvbGxpc2lvbnMgPSBhY3RpdmUgJiYgY29sbGlzaW9uUmVjdCA/IGNvbGxpc2lvbkRldGVjdGlvbih7XG4gICAgYWN0aXZlLFxuICAgIGNvbGxpc2lvblJlY3QsXG4gICAgZHJvcHBhYmxlUmVjdHMsXG4gICAgZHJvcHBhYmxlQ29udGFpbmVyczogZW5hYmxlZERyb3BwYWJsZUNvbnRhaW5lcnMsXG4gICAgcG9pbnRlckNvb3JkaW5hdGVzXG4gIH0pIDogbnVsbDtcbiAgY29uc3Qgb3ZlcklkID0gZ2V0Rmlyc3RDb2xsaXNpb24oY29sbGlzaW9ucywgJ2lkJyk7XG4gIGNvbnN0IFtvdmVyLCBzZXRPdmVyXSA9IHVzZVN0YXRlKG51bGwpOyAvLyBXaGVuIHRoZXJlIGlzIG5vIGRyYWcgb3ZlcmxheSB1c2VkLCB3ZSBuZWVkIHRvIGFjY291bnQgZm9yIHRoZVxuICAvLyB3aW5kb3cgc2Nyb2xsIGRlbHRhXG5cbiAgY29uc3QgYXBwbGllZFRyYW5zbGF0ZSA9IHVzZXNEcmFnT3ZlcmxheSA/IG1vZGlmaWVkVHJhbnNsYXRlIDogYWRkKG1vZGlmaWVkVHJhbnNsYXRlLCBhY3RpdmVOb2RlU2Nyb2xsRGVsdGEpO1xuICBjb25zdCB0cmFuc2Zvcm0gPSBhZGp1c3RTY2FsZShhcHBsaWVkVHJhbnNsYXRlLCAoX292ZXIkcmVjdCA9IG92ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IG92ZXIucmVjdCkgIT0gbnVsbCA/IF9vdmVyJHJlY3QgOiBudWxsLCBhY3RpdmVOb2RlUmVjdCk7XG4gIGNvbnN0IGluc3RhbnRpYXRlU2Vuc29yID0gdXNlQ2FsbGJhY2soKGV2ZW50LCBfcmVmMikgPT4ge1xuICAgIGxldCB7XG4gICAgICBzZW5zb3I6IFNlbnNvcixcbiAgICAgIG9wdGlvbnNcbiAgICB9ID0gX3JlZjI7XG5cbiAgICBpZiAoYWN0aXZlUmVmLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFjdGl2ZU5vZGUgPSBkcmFnZ2FibGVOb2Rlcy5nZXQoYWN0aXZlUmVmLmN1cnJlbnQpO1xuXG4gICAgaWYgKCFhY3RpdmVOb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYWN0aXZhdG9yRXZlbnQgPSBldmVudC5uYXRpdmVFdmVudDtcbiAgICBjb25zdCBzZW5zb3JJbnN0YW5jZSA9IG5ldyBTZW5zb3Ioe1xuICAgICAgYWN0aXZlOiBhY3RpdmVSZWYuY3VycmVudCxcbiAgICAgIGFjdGl2ZU5vZGUsXG4gICAgICBldmVudDogYWN0aXZhdG9yRXZlbnQsXG4gICAgICBvcHRpb25zLFxuICAgICAgLy8gU2Vuc29ycyBuZWVkIHRvIGJlIGluc3RhbnRpYXRlZCB3aXRoIHJlZnMgZm9yIGFyZ3VtZW50cyB0aGF0IGNoYW5nZSBvdmVyIHRpbWVcbiAgICAgIC8vIG90aGVyd2lzZSB0aGV5IGFyZSBmcm96ZW4gaW4gdGltZSB3aXRoIHRoZSBzdGFsZSBhcmd1bWVudHNcbiAgICAgIGNvbnRleHQ6IHNlbnNvckNvbnRleHQsXG5cbiAgICAgIG9uU3RhcnQoaW5pdGlhbENvb3JkaW5hdGVzKSB7XG4gICAgICAgIGNvbnN0IGlkID0gYWN0aXZlUmVmLmN1cnJlbnQ7XG5cbiAgICAgICAgaWYgKGlkID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkcmFnZ2FibGVOb2RlID0gZHJhZ2dhYmxlTm9kZXMuZ2V0KGlkKTtcblxuICAgICAgICBpZiAoIWRyYWdnYWJsZU5vZGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgb25EcmFnU3RhcnRcbiAgICAgICAgfSA9IGxhdGVzdFByb3BzLmN1cnJlbnQ7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgICAgIGFjdGl2ZToge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBkYXRhOiBkcmFnZ2FibGVOb2RlLmRhdGEsXG4gICAgICAgICAgICByZWN0OiBhY3RpdmVSZWN0c1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgICAgIG9uRHJhZ1N0YXJ0ID09IG51bGwgPyB2b2lkIDAgOiBvbkRyYWdTdGFydChldmVudCk7XG4gICAgICAgICAgc2V0U3RhdHVzKFN0YXR1cy5Jbml0aWFsaXppbmcpO1xuICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6IEFjdGlvbi5EcmFnU3RhcnQsXG4gICAgICAgICAgICBpbml0aWFsQ29vcmRpbmF0ZXMsXG4gICAgICAgICAgICBhY3RpdmU6IGlkXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGlzcGF0Y2hNb25pdG9yRXZlbnQoe1xuICAgICAgICAgICAgdHlwZTogJ29uRHJhZ1N0YXJ0JyxcbiAgICAgICAgICAgIGV2ZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcblxuICAgICAgb25Nb3ZlKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiBBY3Rpb24uRHJhZ01vdmUsXG4gICAgICAgICAgY29vcmRpbmF0ZXNcbiAgICAgICAgfSk7XG4gICAgICB9LFxuXG4gICAgICBvbkVuZDogY3JlYXRlSGFuZGxlcihBY3Rpb24uRHJhZ0VuZCksXG4gICAgICBvbkNhbmNlbDogY3JlYXRlSGFuZGxlcihBY3Rpb24uRHJhZ0NhbmNlbClcbiAgICB9KTtcbiAgICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcygoKSA9PiB7XG4gICAgICBzZXRBY3RpdmVTZW5zb3Ioc2Vuc29ySW5zdGFuY2UpO1xuICAgICAgc2V0QWN0aXZhdG9yRXZlbnQoZXZlbnQubmF0aXZlRXZlbnQpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlSGFuZGxlcih0eXBlKSB7XG4gICAgICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGFjdGl2ZSxcbiAgICAgICAgICBjb2xsaXNpb25zLFxuICAgICAgICAgIG92ZXIsXG4gICAgICAgICAgc2Nyb2xsQWRqdXN0ZWRUcmFuc2xhdGVcbiAgICAgICAgfSA9IHNlbnNvckNvbnRleHQuY3VycmVudDtcbiAgICAgICAgbGV0IGV2ZW50ID0gbnVsbDtcblxuICAgICAgICBpZiAoYWN0aXZlICYmIHNjcm9sbEFkanVzdGVkVHJhbnNsYXRlKSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgY2FuY2VsRHJvcFxuICAgICAgICAgIH0gPSBsYXRlc3RQcm9wcy5jdXJyZW50O1xuICAgICAgICAgIGV2ZW50ID0ge1xuICAgICAgICAgICAgYWN0aXZhdG9yRXZlbnQsXG4gICAgICAgICAgICBhY3RpdmU6IGFjdGl2ZSxcbiAgICAgICAgICAgIGNvbGxpc2lvbnMsXG4gICAgICAgICAgICBkZWx0YTogc2Nyb2xsQWRqdXN0ZWRUcmFuc2xhdGUsXG4gICAgICAgICAgICBvdmVyXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmICh0eXBlID09PSBBY3Rpb24uRHJhZ0VuZCAmJiB0eXBlb2YgY2FuY2VsRHJvcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkQ2FuY2VsID0gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKGNhbmNlbERyb3AoZXZlbnQpKTtcblxuICAgICAgICAgICAgaWYgKHNob3VsZENhbmNlbCkge1xuICAgICAgICAgICAgICB0eXBlID0gQWN0aW9uLkRyYWdDYW5jZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYWN0aXZlUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcygoKSA9PiB7XG4gICAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNldFN0YXR1cyhTdGF0dXMuVW5pbml0aWFsaXplZCk7XG4gICAgICAgICAgc2V0T3ZlcihudWxsKTtcbiAgICAgICAgICBzZXRBY3RpdmVTZW5zb3IobnVsbCk7XG4gICAgICAgICAgc2V0QWN0aXZhdG9yRXZlbnQobnVsbCk7XG4gICAgICAgICAgY29uc3QgZXZlbnROYW1lID0gdHlwZSA9PT0gQWN0aW9uLkRyYWdFbmQgPyAnb25EcmFnRW5kJyA6ICdvbkRyYWdDYW5jZWwnO1xuXG4gICAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gbGF0ZXN0UHJvcHMuY3VycmVudFtldmVudE5hbWVdO1xuICAgICAgICAgICAgaGFuZGxlciA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlcihldmVudCk7XG4gICAgICAgICAgICBkaXNwYXRjaE1vbml0b3JFdmVudCh7XG4gICAgICAgICAgICAgIHR5cGU6IGV2ZW50TmFtZSxcbiAgICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBbZHJhZ2dhYmxlTm9kZXNdKTtcbiAgY29uc3QgYmluZEFjdGl2YXRvclRvU2Vuc29ySW5zdGFudGlhdG9yID0gdXNlQ2FsbGJhY2soKGhhbmRsZXIsIHNlbnNvcikgPT4ge1xuICAgIHJldHVybiAoZXZlbnQsIGFjdGl2ZSkgPT4ge1xuICAgICAgY29uc3QgbmF0aXZlRXZlbnQgPSBldmVudC5uYXRpdmVFdmVudDtcbiAgICAgIGNvbnN0IGFjdGl2ZURyYWdnYWJsZU5vZGUgPSBkcmFnZ2FibGVOb2Rlcy5nZXQoYWN0aXZlKTtcblxuICAgICAgaWYgKCAvLyBBbm90aGVyIHNlbnNvciBpcyBhbHJlYWR5IGluc3RhbnRpYXRpbmdcbiAgICAgIGFjdGl2ZVJlZi5jdXJyZW50ICE9PSBudWxsIHx8IC8vIE5vIGFjdGl2ZSBkcmFnZ2FibGVcbiAgICAgICFhY3RpdmVEcmFnZ2FibGVOb2RlIHx8IC8vIEV2ZW50IGhhcyBhbHJlYWR5IGJlZW4gY2FwdHVyZWRcbiAgICAgIG5hdGl2ZUV2ZW50LmRuZEtpdCB8fCBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYWN0aXZhdGlvbkNvbnRleHQgPSB7XG4gICAgICAgIGFjdGl2ZTogYWN0aXZlRHJhZ2dhYmxlTm9kZVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNob3VsZEFjdGl2YXRlID0gaGFuZGxlcihldmVudCwgc2Vuc29yLm9wdGlvbnMsIGFjdGl2YXRpb25Db250ZXh0KTtcblxuICAgICAgaWYgKHNob3VsZEFjdGl2YXRlID09PSB0cnVlKSB7XG4gICAgICAgIG5hdGl2ZUV2ZW50LmRuZEtpdCA9IHtcbiAgICAgICAgICBjYXB0dXJlZEJ5OiBzZW5zb3Iuc2Vuc29yXG4gICAgICAgIH07XG4gICAgICAgIGFjdGl2ZVJlZi5jdXJyZW50ID0gYWN0aXZlO1xuICAgICAgICBpbnN0YW50aWF0ZVNlbnNvcihldmVudCwgc2Vuc29yKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbZHJhZ2dhYmxlTm9kZXMsIGluc3RhbnRpYXRlU2Vuc29yXSk7XG4gIGNvbnN0IGFjdGl2YXRvcnMgPSB1c2VDb21iaW5lQWN0aXZhdG9ycyhzZW5zb3JzLCBiaW5kQWN0aXZhdG9yVG9TZW5zb3JJbnN0YW50aWF0b3IpO1xuICB1c2VTZW5zb3JTZXR1cChzZW5zb3JzKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGFjdGl2ZU5vZGVSZWN0ICYmIHN0YXR1cyA9PT0gU3RhdHVzLkluaXRpYWxpemluZykge1xuICAgICAgc2V0U3RhdHVzKFN0YXR1cy5Jbml0aWFsaXplZCk7XG4gICAgfVxuICB9LCBbYWN0aXZlTm9kZVJlY3QsIHN0YXR1c10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIG9uRHJhZ01vdmVcbiAgICB9ID0gbGF0ZXN0UHJvcHMuY3VycmVudDtcbiAgICBjb25zdCB7XG4gICAgICBhY3RpdmUsXG4gICAgICBhY3RpdmF0b3JFdmVudCxcbiAgICAgIGNvbGxpc2lvbnMsXG4gICAgICBvdmVyXG4gICAgfSA9IHNlbnNvckNvbnRleHQuY3VycmVudDtcblxuICAgIGlmICghYWN0aXZlIHx8ICFhY3RpdmF0b3JFdmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgYWN0aXZlLFxuICAgICAgYWN0aXZhdG9yRXZlbnQsXG4gICAgICBjb2xsaXNpb25zLFxuICAgICAgZGVsdGE6IHtcbiAgICAgICAgeDogc2Nyb2xsQWRqdXN0ZWRUcmFuc2xhdGUueCxcbiAgICAgICAgeTogc2Nyb2xsQWRqdXN0ZWRUcmFuc2xhdGUueVxuICAgICAgfSxcbiAgICAgIG92ZXJcbiAgICB9O1xuICAgIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzKCgpID0+IHtcbiAgICAgIG9uRHJhZ01vdmUgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRHJhZ01vdmUoZXZlbnQpO1xuICAgICAgZGlzcGF0Y2hNb25pdG9yRXZlbnQoe1xuICAgICAgICB0eXBlOiAnb25EcmFnTW92ZScsXG4gICAgICAgIGV2ZW50XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBbc2Nyb2xsQWRqdXN0ZWRUcmFuc2xhdGUueCwgc2Nyb2xsQWRqdXN0ZWRUcmFuc2xhdGUueV0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGFjdGl2ZSxcbiAgICAgIGFjdGl2YXRvckV2ZW50LFxuICAgICAgY29sbGlzaW9ucyxcbiAgICAgIGRyb3BwYWJsZUNvbnRhaW5lcnMsXG4gICAgICBzY3JvbGxBZGp1c3RlZFRyYW5zbGF0ZVxuICAgIH0gPSBzZW5zb3JDb250ZXh0LmN1cnJlbnQ7XG5cbiAgICBpZiAoIWFjdGl2ZSB8fCBhY3RpdmVSZWYuY3VycmVudCA9PSBudWxsIHx8ICFhY3RpdmF0b3JFdmVudCB8fCAhc2Nyb2xsQWRqdXN0ZWRUcmFuc2xhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBvbkRyYWdPdmVyXG4gICAgfSA9IGxhdGVzdFByb3BzLmN1cnJlbnQ7XG4gICAgY29uc3Qgb3ZlckNvbnRhaW5lciA9IGRyb3BwYWJsZUNvbnRhaW5lcnMuZ2V0KG92ZXJJZCk7XG4gICAgY29uc3Qgb3ZlciA9IG92ZXJDb250YWluZXIgJiYgb3ZlckNvbnRhaW5lci5yZWN0LmN1cnJlbnQgPyB7XG4gICAgICBpZDogb3ZlckNvbnRhaW5lci5pZCxcbiAgICAgIHJlY3Q6IG92ZXJDb250YWluZXIucmVjdC5jdXJyZW50LFxuICAgICAgZGF0YTogb3ZlckNvbnRhaW5lci5kYXRhLFxuICAgICAgZGlzYWJsZWQ6IG92ZXJDb250YWluZXIuZGlzYWJsZWRcbiAgICB9IDogbnVsbDtcbiAgICBjb25zdCBldmVudCA9IHtcbiAgICAgIGFjdGl2ZSxcbiAgICAgIGFjdGl2YXRvckV2ZW50LFxuICAgICAgY29sbGlzaW9ucyxcbiAgICAgIGRlbHRhOiB7XG4gICAgICAgIHg6IHNjcm9sbEFkanVzdGVkVHJhbnNsYXRlLngsXG4gICAgICAgIHk6IHNjcm9sbEFkanVzdGVkVHJhbnNsYXRlLnlcbiAgICAgIH0sXG4gICAgICBvdmVyXG4gICAgfTtcbiAgICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcygoKSA9PiB7XG4gICAgICBzZXRPdmVyKG92ZXIpO1xuICAgICAgb25EcmFnT3ZlciA9PSBudWxsID8gdm9pZCAwIDogb25EcmFnT3ZlcihldmVudCk7XG4gICAgICBkaXNwYXRjaE1vbml0b3JFdmVudCh7XG4gICAgICAgIHR5cGU6ICdvbkRyYWdPdmVyJyxcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFtvdmVySWRdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgc2Vuc29yQ29udGV4dC5jdXJyZW50ID0ge1xuICAgICAgYWN0aXZhdG9yRXZlbnQsXG4gICAgICBhY3RpdmUsXG4gICAgICBhY3RpdmVOb2RlLFxuICAgICAgY29sbGlzaW9uUmVjdCxcbiAgICAgIGNvbGxpc2lvbnMsXG4gICAgICBkcm9wcGFibGVSZWN0cyxcbiAgICAgIGRyYWdnYWJsZU5vZGVzLFxuICAgICAgZHJhZ2dpbmdOb2RlLFxuICAgICAgZHJhZ2dpbmdOb2RlUmVjdCxcbiAgICAgIGRyb3BwYWJsZUNvbnRhaW5lcnMsXG4gICAgICBvdmVyLFxuICAgICAgc2Nyb2xsYWJsZUFuY2VzdG9ycyxcbiAgICAgIHNjcm9sbEFkanVzdGVkVHJhbnNsYXRlXG4gICAgfTtcbiAgICBhY3RpdmVSZWN0cy5jdXJyZW50ID0ge1xuICAgICAgaW5pdGlhbDogZHJhZ2dpbmdOb2RlUmVjdCxcbiAgICAgIHRyYW5zbGF0ZWQ6IGNvbGxpc2lvblJlY3RcbiAgICB9O1xuICB9LCBbYWN0aXZlLCBhY3RpdmVOb2RlLCBjb2xsaXNpb25zLCBjb2xsaXNpb25SZWN0LCBkcmFnZ2FibGVOb2RlcywgZHJhZ2dpbmdOb2RlLCBkcmFnZ2luZ05vZGVSZWN0LCBkcm9wcGFibGVSZWN0cywgZHJvcHBhYmxlQ29udGFpbmVycywgb3Zlciwgc2Nyb2xsYWJsZUFuY2VzdG9ycywgc2Nyb2xsQWRqdXN0ZWRUcmFuc2xhdGVdKTtcbiAgdXNlQXV0b1Njcm9sbGVyKHsgLi4uYXV0b1Njcm9sbE9wdGlvbnMsXG4gICAgZGVsdGE6IHRyYW5zbGF0ZSxcbiAgICBkcmFnZ2luZ1JlY3Q6IGNvbGxpc2lvblJlY3QsXG4gICAgcG9pbnRlckNvb3JkaW5hdGVzLFxuICAgIHNjcm9sbGFibGVBbmNlc3RvcnMsXG4gICAgc2Nyb2xsYWJsZUFuY2VzdG9yUmVjdHNcbiAgfSk7XG4gIGNvbnN0IHB1YmxpY0NvbnRleHQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgYWN0aXZlLFxuICAgICAgYWN0aXZlTm9kZSxcbiAgICAgIGFjdGl2ZU5vZGVSZWN0LFxuICAgICAgYWN0aXZhdG9yRXZlbnQsXG4gICAgICBjb2xsaXNpb25zLFxuICAgICAgY29udGFpbmVyTm9kZVJlY3QsXG4gICAgICBkcmFnT3ZlcmxheSxcbiAgICAgIGRyYWdnYWJsZU5vZGVzLFxuICAgICAgZHJvcHBhYmxlQ29udGFpbmVycyxcbiAgICAgIGRyb3BwYWJsZVJlY3RzLFxuICAgICAgb3ZlcixcbiAgICAgIG1lYXN1cmVEcm9wcGFibGVDb250YWluZXJzLFxuICAgICAgc2Nyb2xsYWJsZUFuY2VzdG9ycyxcbiAgICAgIHNjcm9sbGFibGVBbmNlc3RvclJlY3RzLFxuICAgICAgbWVhc3VyaW5nQ29uZmlndXJhdGlvbixcbiAgICAgIG1lYXN1cmluZ1NjaGVkdWxlZCxcbiAgICAgIHdpbmRvd1JlY3RcbiAgICB9O1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9LCBbYWN0aXZlLCBhY3RpdmVOb2RlLCBhY3RpdmVOb2RlUmVjdCwgYWN0aXZhdG9yRXZlbnQsIGNvbGxpc2lvbnMsIGNvbnRhaW5lck5vZGVSZWN0LCBkcmFnT3ZlcmxheSwgZHJhZ2dhYmxlTm9kZXMsIGRyb3BwYWJsZUNvbnRhaW5lcnMsIGRyb3BwYWJsZVJlY3RzLCBvdmVyLCBtZWFzdXJlRHJvcHBhYmxlQ29udGFpbmVycywgc2Nyb2xsYWJsZUFuY2VzdG9ycywgc2Nyb2xsYWJsZUFuY2VzdG9yUmVjdHMsIG1lYXN1cmluZ0NvbmZpZ3VyYXRpb24sIG1lYXN1cmluZ1NjaGVkdWxlZCwgd2luZG93UmVjdF0pO1xuICBjb25zdCBpbnRlcm5hbENvbnRleHQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgYWN0aXZhdG9yRXZlbnQsXG4gICAgICBhY3RpdmF0b3JzLFxuICAgICAgYWN0aXZlLFxuICAgICAgYWN0aXZlTm9kZVJlY3QsXG4gICAgICBhcmlhRGVzY3JpYmVkQnlJZDoge1xuICAgICAgICBkcmFnZ2FibGU6IGRyYWdnYWJsZURlc2NyaWJlZEJ5SWRcbiAgICAgIH0sXG4gICAgICBkaXNwYXRjaCxcbiAgICAgIGRyYWdnYWJsZU5vZGVzLFxuICAgICAgb3ZlcixcbiAgICAgIG1lYXN1cmVEcm9wcGFibGVDb250YWluZXJzXG4gICAgfTtcbiAgICByZXR1cm4gY29udGV4dDtcbiAgfSwgW2FjdGl2YXRvckV2ZW50LCBhY3RpdmF0b3JzLCBhY3RpdmUsIGFjdGl2ZU5vZGVSZWN0LCBkaXNwYXRjaCwgZHJhZ2dhYmxlRGVzY3JpYmVkQnlJZCwgZHJhZ2dhYmxlTm9kZXMsIG92ZXIsIG1lYXN1cmVEcm9wcGFibGVDb250YWluZXJzXSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KERuZE1vbml0b3JDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHJlZ2lzdGVyTW9uaXRvckxpc3RlbmVyXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW50ZXJuYWxDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGludGVybmFsQ29udGV4dFxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFB1YmxpY0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogcHVibGljQ29udGV4dFxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KEFjdGl2ZURyYWdnYWJsZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogdHJhbnNmb3JtXG4gIH0sIGNoaWxkcmVuKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVzdG9yZUZvY3VzLCB7XG4gICAgZGlzYWJsZWQ6IChhY2Nlc3NpYmlsaXR5ID09IG51bGwgPyB2b2lkIDAgOiBhY2Nlc3NpYmlsaXR5LnJlc3RvcmVGb2N1cykgPT09IGZhbHNlXG4gIH0pKSwgUmVhY3QuY3JlYXRlRWxlbWVudChBY2Nlc3NpYmlsaXR5LCB7IC4uLmFjY2Vzc2liaWxpdHksXG4gICAgaGlkZGVuVGV4dERlc2NyaWJlZEJ5SWQ6IGRyYWdnYWJsZURlc2NyaWJlZEJ5SWRcbiAgfSkpO1xuXG4gIGZ1bmN0aW9uIGdldEF1dG9TY3JvbGxlck9wdGlvbnMoKSB7XG4gICAgY29uc3QgYWN0aXZlU2Vuc29yRGlzYWJsZXNBdXRvc2Nyb2xsID0gKGFjdGl2ZVNlbnNvciA9PSBudWxsID8gdm9pZCAwIDogYWN0aXZlU2Vuc29yLmF1dG9TY3JvbGxFbmFibGVkKSA9PT0gZmFsc2U7XG4gICAgY29uc3QgYXV0b1Njcm9sbEdsb2JhbGx5RGlzYWJsZWQgPSB0eXBlb2YgYXV0b1Njcm9sbCA9PT0gJ29iamVjdCcgPyBhdXRvU2Nyb2xsLmVuYWJsZWQgPT09IGZhbHNlIDogYXV0b1Njcm9sbCA9PT0gZmFsc2U7XG4gICAgY29uc3QgZW5hYmxlZCA9IGlzSW5pdGlhbGl6ZWQgJiYgIWFjdGl2ZVNlbnNvckRpc2FibGVzQXV0b3Njcm9sbCAmJiAhYXV0b1Njcm9sbEdsb2JhbGx5RGlzYWJsZWQ7XG5cbiAgICBpZiAodHlwZW9mIGF1dG9TY3JvbGwgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4geyAuLi5hdXRvU2Nyb2xsLFxuICAgICAgICBlbmFibGVkXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBlbmFibGVkXG4gICAgfTtcbiAgfVxufSk7XG5cbmNvbnN0IE51bGxDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCBkZWZhdWx0Um9sZSA9ICdidXR0b24nO1xuY29uc3QgSURfUFJFRklYID0gJ0Ryb3BwYWJsZSc7XG5mdW5jdGlvbiB1c2VEcmFnZ2FibGUoX3JlZikge1xuICBsZXQge1xuICAgIGlkLFxuICAgIGRhdGEsXG4gICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICBhdHRyaWJ1dGVzXG4gIH0gPSBfcmVmO1xuICBjb25zdCBrZXkgPSB1c2VVbmlxdWVJZChJRF9QUkVGSVgpO1xuICBjb25zdCB7XG4gICAgYWN0aXZhdG9ycyxcbiAgICBhY3RpdmF0b3JFdmVudCxcbiAgICBhY3RpdmUsXG4gICAgYWN0aXZlTm9kZVJlY3QsXG4gICAgYXJpYURlc2NyaWJlZEJ5SWQsXG4gICAgZHJhZ2dhYmxlTm9kZXMsXG4gICAgb3ZlclxuICB9ID0gdXNlQ29udGV4dChJbnRlcm5hbENvbnRleHQpO1xuICBjb25zdCB7XG4gICAgcm9sZSA9IGRlZmF1bHRSb2xlLFxuICAgIHJvbGVEZXNjcmlwdGlvbiA9ICdkcmFnZ2FibGUnLFxuICAgIHRhYkluZGV4ID0gMFxuICB9ID0gYXR0cmlidXRlcyAhPSBudWxsID8gYXR0cmlidXRlcyA6IHt9O1xuICBjb25zdCBpc0RyYWdnaW5nID0gKGFjdGl2ZSA9PSBudWxsID8gdm9pZCAwIDogYWN0aXZlLmlkKSA9PT0gaWQ7XG4gIGNvbnN0IHRyYW5zZm9ybSA9IHVzZUNvbnRleHQoaXNEcmFnZ2luZyA/IEFjdGl2ZURyYWdnYWJsZUNvbnRleHQgOiBOdWxsQ29udGV4dCk7XG4gIGNvbnN0IFtub2RlLCBzZXROb2RlUmVmXSA9IHVzZU5vZGVSZWYoKTtcbiAgY29uc3QgW2FjdGl2YXRvck5vZGUsIHNldEFjdGl2YXRvck5vZGVSZWZdID0gdXNlTm9kZVJlZigpO1xuICBjb25zdCBsaXN0ZW5lcnMgPSB1c2VTeW50aGV0aWNMaXN0ZW5lcnMoYWN0aXZhdG9ycywgaWQpO1xuICBjb25zdCBkYXRhUmVmID0gdXNlTGF0ZXN0VmFsdWUoZGF0YSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGRyYWdnYWJsZU5vZGVzLnNldChpZCwge1xuICAgICAgaWQsXG4gICAgICBrZXksXG4gICAgICBub2RlLFxuICAgICAgYWN0aXZhdG9yTm9kZSxcbiAgICAgIGRhdGE6IGRhdGFSZWZcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3Qgbm9kZSA9IGRyYWdnYWJsZU5vZGVzLmdldChpZCk7XG5cbiAgICAgIGlmIChub2RlICYmIG5vZGUua2V5ID09PSBrZXkpIHtcbiAgICAgICAgZHJhZ2dhYmxlTm9kZXMuZGVsZXRlKGlkKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFtkcmFnZ2FibGVOb2RlcywgaWRdKTtcbiAgY29uc3QgbWVtb2l6ZWRBdHRyaWJ1dGVzID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIHJvbGUsXG4gICAgdGFiSW5kZXgsXG4gICAgJ2FyaWEtZGlzYWJsZWQnOiBkaXNhYmxlZCxcbiAgICAnYXJpYS1wcmVzc2VkJzogaXNEcmFnZ2luZyAmJiByb2xlID09PSBkZWZhdWx0Um9sZSA/IHRydWUgOiB1bmRlZmluZWQsXG4gICAgJ2FyaWEtcm9sZWRlc2NyaXB0aW9uJzogcm9sZURlc2NyaXB0aW9uLFxuICAgICdhcmlhLWRlc2NyaWJlZGJ5JzogYXJpYURlc2NyaWJlZEJ5SWQuZHJhZ2dhYmxlXG4gIH0pLCBbZGlzYWJsZWQsIHJvbGUsIHRhYkluZGV4LCBpc0RyYWdnaW5nLCByb2xlRGVzY3JpcHRpb24sIGFyaWFEZXNjcmliZWRCeUlkLmRyYWdnYWJsZV0pO1xuICByZXR1cm4ge1xuICAgIGFjdGl2ZSxcbiAgICBhY3RpdmF0b3JFdmVudCxcbiAgICBhY3RpdmVOb2RlUmVjdCxcbiAgICBhdHRyaWJ1dGVzOiBtZW1vaXplZEF0dHJpYnV0ZXMsXG4gICAgaXNEcmFnZ2luZyxcbiAgICBsaXN0ZW5lcnM6IGRpc2FibGVkID8gdW5kZWZpbmVkIDogbGlzdGVuZXJzLFxuICAgIG5vZGUsXG4gICAgb3ZlcixcbiAgICBzZXROb2RlUmVmLFxuICAgIHNldEFjdGl2YXRvck5vZGVSZWYsXG4gICAgdHJhbnNmb3JtXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZURuZENvbnRleHQoKSB7XG4gIHJldHVybiB1c2VDb250ZXh0KFB1YmxpY0NvbnRleHQpO1xufVxuXG5jb25zdCBJRF9QUkVGSVgkMSA9ICdEcm9wcGFibGUnO1xuY29uc3QgZGVmYXVsdFJlc2l6ZU9ic2VydmVyQ29uZmlnID0ge1xuICB0aW1lb3V0OiAyNVxufTtcbmZ1bmN0aW9uIHVzZURyb3BwYWJsZShfcmVmKSB7XG4gIGxldCB7XG4gICAgZGF0YSxcbiAgICBkaXNhYmxlZCA9IGZhbHNlLFxuICAgIGlkLFxuICAgIHJlc2l6ZU9ic2VydmVyQ29uZmlnXG4gIH0gPSBfcmVmO1xuICBjb25zdCBrZXkgPSB1c2VVbmlxdWVJZChJRF9QUkVGSVgkMSk7XG4gIGNvbnN0IHtcbiAgICBhY3RpdmUsXG4gICAgZGlzcGF0Y2gsXG4gICAgb3ZlcixcbiAgICBtZWFzdXJlRHJvcHBhYmxlQ29udGFpbmVyc1xuICB9ID0gdXNlQ29udGV4dChJbnRlcm5hbENvbnRleHQpO1xuICBjb25zdCBwcmV2aW91cyA9IHVzZVJlZih7XG4gICAgZGlzYWJsZWRcbiAgfSk7XG4gIGNvbnN0IHJlc2l6ZU9ic2VydmVyQ29ubmVjdGVkID0gdXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgcmVjdCA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgY2FsbGJhY2tJZCA9IHVzZVJlZihudWxsKTtcbiAgY29uc3Qge1xuICAgIGRpc2FibGVkOiByZXNpemVPYnNlcnZlckRpc2FibGVkLFxuICAgIHVwZGF0ZU1lYXN1cmVtZW50c0ZvcixcbiAgICB0aW1lb3V0OiByZXNpemVPYnNlcnZlclRpbWVvdXRcbiAgfSA9IHsgLi4uZGVmYXVsdFJlc2l6ZU9ic2VydmVyQ29uZmlnLFxuICAgIC4uLnJlc2l6ZU9ic2VydmVyQ29uZmlnXG4gIH07XG4gIGNvbnN0IGlkcyA9IHVzZUxhdGVzdFZhbHVlKHVwZGF0ZU1lYXN1cmVtZW50c0ZvciAhPSBudWxsID8gdXBkYXRlTWVhc3VyZW1lbnRzRm9yIDogaWQpO1xuICBjb25zdCBoYW5kbGVSZXNpemUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFyZXNpemVPYnNlcnZlckNvbm5lY3RlZC5jdXJyZW50KSB7XG4gICAgICAvLyBSZXNpemVPYnNlcnZlciBpbnZva2VzIHRoZSBgaGFuZGxlUmVzaXplYCBjYWxsYmFjayBhcyBzb29uIGFzIGBvYnNlcnZlYCBpcyBjYWxsZWQsXG4gICAgICAvLyBhc3N1bWluZyB0aGUgZWxlbWVudCBpcyByZW5kZXJlZCBhbmQgZGlzcGxheWVkLlxuICAgICAgcmVzaXplT2JzZXJ2ZXJDb25uZWN0ZWQuY3VycmVudCA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNhbGxiYWNrSWQuY3VycmVudCAhPSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQoY2FsbGJhY2tJZC5jdXJyZW50KTtcbiAgICB9XG5cbiAgICBjYWxsYmFja0lkLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIG1lYXN1cmVEcm9wcGFibGVDb250YWluZXJzKEFycmF5LmlzQXJyYXkoaWRzLmN1cnJlbnQpID8gaWRzLmN1cnJlbnQgOiBbaWRzLmN1cnJlbnRdKTtcbiAgICAgIGNhbGxiYWNrSWQuY3VycmVudCA9IG51bGw7XG4gICAgfSwgcmVzaXplT2JzZXJ2ZXJUaW1lb3V0KTtcbiAgfSwgLy9lc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFtyZXNpemVPYnNlcnZlclRpbWVvdXRdKTtcbiAgY29uc3QgcmVzaXplT2JzZXJ2ZXIgPSB1c2VSZXNpemVPYnNlcnZlcih7XG4gICAgY2FsbGJhY2s6IGhhbmRsZVJlc2l6ZSxcbiAgICBkaXNhYmxlZDogcmVzaXplT2JzZXJ2ZXJEaXNhYmxlZCB8fCAhYWN0aXZlXG4gIH0pO1xuICBjb25zdCBoYW5kbGVOb2RlQ2hhbmdlID0gdXNlQ2FsbGJhY2soKG5ld0VsZW1lbnQsIHByZXZpb3VzRWxlbWVudCkgPT4ge1xuICAgIGlmICghcmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJldmlvdXNFbGVtZW50KSB7XG4gICAgICByZXNpemVPYnNlcnZlci51bm9ic2VydmUocHJldmlvdXNFbGVtZW50KTtcbiAgICAgIHJlc2l6ZU9ic2VydmVyQ29ubmVjdGVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAobmV3RWxlbWVudCkge1xuICAgICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShuZXdFbGVtZW50KTtcbiAgICB9XG4gIH0sIFtyZXNpemVPYnNlcnZlcl0pO1xuICBjb25zdCBbbm9kZVJlZiwgc2V0Tm9kZVJlZl0gPSB1c2VOb2RlUmVmKGhhbmRsZU5vZGVDaGFuZ2UpO1xuICBjb25zdCBkYXRhUmVmID0gdXNlTGF0ZXN0VmFsdWUoZGF0YSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFyZXNpemVPYnNlcnZlciB8fCAhbm9kZVJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIHJlc2l6ZU9ic2VydmVyQ29ubmVjdGVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKG5vZGVSZWYuY3VycmVudCk7XG4gIH0sIFtub2RlUmVmLCByZXNpemVPYnNlcnZlcl0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBkaXNwYXRjaCh7XG4gICAgICB0eXBlOiBBY3Rpb24uUmVnaXN0ZXJEcm9wcGFibGUsXG4gICAgICBlbGVtZW50OiB7XG4gICAgICAgIGlkLFxuICAgICAgICBrZXksXG4gICAgICAgIGRpc2FibGVkLFxuICAgICAgICBub2RlOiBub2RlUmVmLFxuICAgICAgICByZWN0LFxuICAgICAgICBkYXRhOiBkYXRhUmVmXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IGRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IEFjdGlvbi5VbnJlZ2lzdGVyRHJvcHBhYmxlLFxuICAgICAga2V5LFxuICAgICAgaWRcbiAgICB9KTtcbiAgfSwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBbaWRdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgIT09IHByZXZpb3VzLmN1cnJlbnQuZGlzYWJsZWQpIHtcbiAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogQWN0aW9uLlNldERyb3BwYWJsZURpc2FibGVkLFxuICAgICAgICBpZCxcbiAgICAgICAga2V5LFxuICAgICAgICBkaXNhYmxlZFxuICAgICAgfSk7XG4gICAgICBwcmV2aW91cy5jdXJyZW50LmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgfVxuICB9LCBbaWQsIGtleSwgZGlzYWJsZWQsIGRpc3BhdGNoXSk7XG4gIHJldHVybiB7XG4gICAgYWN0aXZlLFxuICAgIHJlY3QsXG4gICAgaXNPdmVyOiAob3ZlciA9PSBudWxsID8gdm9pZCAwIDogb3Zlci5pZCkgPT09IGlkLFxuICAgIG5vZGU6IG5vZGVSZWYsXG4gICAgb3ZlcixcbiAgICBzZXROb2RlUmVmXG4gIH07XG59XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbk1hbmFnZXIoX3JlZikge1xuICBsZXQge1xuICAgIGFuaW1hdGlvbixcbiAgICBjaGlsZHJlblxuICB9ID0gX3JlZjtcbiAgY29uc3QgW2Nsb25lZENoaWxkcmVuLCBzZXRDbG9uZWRDaGlsZHJlbl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW2VsZW1lbnQsIHNldEVsZW1lbnRdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IHByZXZpb3VzQ2hpbGRyZW4gPSB1c2VQcmV2aW91cyhjaGlsZHJlbik7XG5cbiAgaWYgKCFjaGlsZHJlbiAmJiAhY2xvbmVkQ2hpbGRyZW4gJiYgcHJldmlvdXNDaGlsZHJlbikge1xuICAgIHNldENsb25lZENoaWxkcmVuKHByZXZpb3VzQ2hpbGRyZW4pO1xuICB9XG5cbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qga2V5ID0gY2xvbmVkQ2hpbGRyZW4gPT0gbnVsbCA/IHZvaWQgMCA6IGNsb25lZENoaWxkcmVuLmtleTtcbiAgICBjb25zdCBpZCA9IGNsb25lZENoaWxkcmVuID09IG51bGwgPyB2b2lkIDAgOiBjbG9uZWRDaGlsZHJlbi5wcm9wcy5pZDtcblxuICAgIGlmIChrZXkgPT0gbnVsbCB8fCBpZCA9PSBudWxsKSB7XG4gICAgICBzZXRDbG9uZWRDaGlsZHJlbihudWxsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBQcm9taXNlLnJlc29sdmUoYW5pbWF0aW9uKGlkLCBlbGVtZW50KSkudGhlbigoKSA9PiB7XG4gICAgICBzZXRDbG9uZWRDaGlsZHJlbihudWxsKTtcbiAgICB9KTtcbiAgfSwgW2FuaW1hdGlvbiwgY2xvbmVkQ2hpbGRyZW4sIGVsZW1lbnRdKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuLCBjbG9uZWRDaGlsZHJlbiA/IGNsb25lRWxlbWVudChjbG9uZWRDaGlsZHJlbiwge1xuICAgIHJlZjogc2V0RWxlbWVudFxuICB9KSA6IG51bGwpO1xufVxuXG5jb25zdCBkZWZhdWx0VHJhbnNmb3JtID0ge1xuICB4OiAwLFxuICB5OiAwLFxuICBzY2FsZVg6IDEsXG4gIHNjYWxlWTogMVxufTtcbmZ1bmN0aW9uIE51bGxpZmllZENvbnRleHRQcm92aWRlcihfcmVmKSB7XG4gIGxldCB7XG4gICAgY2hpbGRyZW5cbiAgfSA9IF9yZWY7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEludGVybmFsQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBkZWZhdWx0SW50ZXJuYWxDb250ZXh0XG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQWN0aXZlRHJhZ2dhYmxlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBkZWZhdWx0VHJhbnNmb3JtXG4gIH0sIGNoaWxkcmVuKSk7XG59XG5cbmNvbnN0IGJhc2VTdHlsZXMgPSB7XG4gIHBvc2l0aW9uOiAnZml4ZWQnLFxuICB0b3VjaEFjdGlvbjogJ25vbmUnXG59O1xuXG5jb25zdCBkZWZhdWx0VHJhbnNpdGlvbiA9IGFjdGl2YXRvckV2ZW50ID0+IHtcbiAgY29uc3QgaXNLZXlib2FyZEFjdGl2YXRvciA9IGlzS2V5Ym9hcmRFdmVudChhY3RpdmF0b3JFdmVudCk7XG4gIHJldHVybiBpc0tleWJvYXJkQWN0aXZhdG9yID8gJ3RyYW5zZm9ybSAyNTBtcyBlYXNlJyA6IHVuZGVmaW5lZDtcbn07XG5cbmNvbnN0IFBvc2l0aW9uZWRPdmVybGF5ID0gLyojX19QVVJFX18qL2ZvcndhcmRSZWYoKF9yZWYsIHJlZikgPT4ge1xuICBsZXQge1xuICAgIGFzLFxuICAgIGFjdGl2YXRvckV2ZW50LFxuICAgIGFkanVzdFNjYWxlLFxuICAgIGNoaWxkcmVuLFxuICAgIGNsYXNzTmFtZSxcbiAgICByZWN0LFxuICAgIHN0eWxlLFxuICAgIHRyYW5zZm9ybSxcbiAgICB0cmFuc2l0aW9uID0gZGVmYXVsdFRyYW5zaXRpb25cbiAgfSA9IF9yZWY7XG5cbiAgaWYgKCFyZWN0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBzY2FsZUFkanVzdGVkVHJhbnNmb3JtID0gYWRqdXN0U2NhbGUgPyB0cmFuc2Zvcm0gOiB7IC4uLnRyYW5zZm9ybSxcbiAgICBzY2FsZVg6IDEsXG4gICAgc2NhbGVZOiAxXG4gIH07XG4gIGNvbnN0IHN0eWxlcyA9IHsgLi4uYmFzZVN0eWxlcyxcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0LFxuICAgIHRvcDogcmVjdC50b3AsXG4gICAgbGVmdDogcmVjdC5sZWZ0LFxuICAgIHRyYW5zZm9ybTogQ1NTLlRyYW5zZm9ybS50b1N0cmluZyhzY2FsZUFkanVzdGVkVHJhbnNmb3JtKSxcbiAgICB0cmFuc2Zvcm1PcmlnaW46IGFkanVzdFNjYWxlICYmIGFjdGl2YXRvckV2ZW50ID8gZ2V0UmVsYXRpdmVUcmFuc2Zvcm1PcmlnaW4oYWN0aXZhdG9yRXZlbnQsIHJlY3QpIDogdW5kZWZpbmVkLFxuICAgIHRyYW5zaXRpb246IHR5cGVvZiB0cmFuc2l0aW9uID09PSAnZnVuY3Rpb24nID8gdHJhbnNpdGlvbihhY3RpdmF0b3JFdmVudCkgOiB0cmFuc2l0aW9uLFxuICAgIC4uLnN0eWxlXG4gIH07XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KGFzLCB7XG4gICAgY2xhc3NOYW1lLFxuICAgIHN0eWxlOiBzdHlsZXMsXG4gICAgcmVmXG4gIH0sIGNoaWxkcmVuKTtcbn0pO1xuXG5jb25zdCBkZWZhdWx0RHJvcEFuaW1hdGlvblNpZGVFZmZlY3RzID0gb3B0aW9ucyA9PiBfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBhY3RpdmUsXG4gICAgZHJhZ092ZXJsYXlcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IG9yaWdpbmFsU3R5bGVzID0ge307XG4gIGNvbnN0IHtcbiAgICBzdHlsZXMsXG4gICAgY2xhc3NOYW1lXG4gIH0gPSBvcHRpb25zO1xuXG4gIGlmIChzdHlsZXMgIT0gbnVsbCAmJiBzdHlsZXMuYWN0aXZlKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoc3R5bGVzLmFjdGl2ZSkpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBvcmlnaW5hbFN0eWxlc1trZXldID0gYWN0aXZlLm5vZGUuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShrZXkpO1xuICAgICAgYWN0aXZlLm5vZGUuc3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0eWxlcyAhPSBudWxsICYmIHN0eWxlcy5kcmFnT3ZlcmxheSkge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHN0eWxlcy5kcmFnT3ZlcmxheSkpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBkcmFnT3ZlcmxheS5ub2RlLnN0eWxlLnNldFByb3BlcnR5KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjbGFzc05hbWUgIT0gbnVsbCAmJiBjbGFzc05hbWUuYWN0aXZlKSB7XG4gICAgYWN0aXZlLm5vZGUuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUuYWN0aXZlKTtcbiAgfVxuXG4gIGlmIChjbGFzc05hbWUgIT0gbnVsbCAmJiBjbGFzc05hbWUuZHJhZ092ZXJsYXkpIHtcbiAgICBkcmFnT3ZlcmxheS5ub2RlLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lLmRyYWdPdmVybGF5KTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9yaWdpbmFsU3R5bGVzKSkge1xuICAgICAgYWN0aXZlLm5vZGUuc3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKGNsYXNzTmFtZSAhPSBudWxsICYmIGNsYXNzTmFtZS5hY3RpdmUpIHtcbiAgICAgIGFjdGl2ZS5ub2RlLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lLmFjdGl2ZSk7XG4gICAgfVxuICB9O1xufTtcblxuY29uc3QgZGVmYXVsdEtleWZyYW1lUmVzb2x2ZXIgPSBfcmVmMiA9PiB7XG4gIGxldCB7XG4gICAgdHJhbnNmb3JtOiB7XG4gICAgICBpbml0aWFsLFxuICAgICAgZmluYWxcbiAgICB9XG4gIH0gPSBfcmVmMjtcbiAgcmV0dXJuIFt7XG4gICAgdHJhbnNmb3JtOiBDU1MuVHJhbnNmb3JtLnRvU3RyaW5nKGluaXRpYWwpXG4gIH0sIHtcbiAgICB0cmFuc2Zvcm06IENTUy5UcmFuc2Zvcm0udG9TdHJpbmcoZmluYWwpXG4gIH1dO1xufTtcblxuY29uc3QgZGVmYXVsdERyb3BBbmltYXRpb25Db25maWd1cmF0aW9uID0ge1xuICBkdXJhdGlvbjogMjUwLFxuICBlYXNpbmc6ICdlYXNlJyxcbiAga2V5ZnJhbWVzOiBkZWZhdWx0S2V5ZnJhbWVSZXNvbHZlcixcbiAgc2lkZUVmZmVjdHM6IC8qI19fUFVSRV9fKi9kZWZhdWx0RHJvcEFuaW1hdGlvblNpZGVFZmZlY3RzKHtcbiAgICBzdHlsZXM6IHtcbiAgICAgIGFjdGl2ZToge1xuICAgICAgICBvcGFjaXR5OiAnMCdcbiAgICAgIH1cbiAgICB9XG4gIH0pXG59O1xuZnVuY3Rpb24gdXNlRHJvcEFuaW1hdGlvbihfcmVmMykge1xuICBsZXQge1xuICAgIGNvbmZpZyxcbiAgICBkcmFnZ2FibGVOb2RlcyxcbiAgICBkcm9wcGFibGVDb250YWluZXJzLFxuICAgIG1lYXN1cmluZ0NvbmZpZ3VyYXRpb25cbiAgfSA9IF9yZWYzO1xuICByZXR1cm4gdXNlRXZlbnQoKGlkLCBub2RlKSA9PiB7XG4gICAgaWYgKGNvbmZpZyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFjdGl2ZURyYWdnYWJsZSA9IGRyYWdnYWJsZU5vZGVzLmdldChpZCk7XG5cbiAgICBpZiAoIWFjdGl2ZURyYWdnYWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFjdGl2ZU5vZGUgPSBhY3RpdmVEcmFnZ2FibGUubm9kZS5jdXJyZW50O1xuXG4gICAgaWYgKCFhY3RpdmVOb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbWVhc3VyYWJsZU5vZGUgPSBnZXRNZWFzdXJhYmxlTm9kZShub2RlKTtcblxuICAgIGlmICghbWVhc3VyYWJsZU5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICB0cmFuc2Zvcm1cbiAgICB9ID0gZ2V0V2luZG93KG5vZGUpLmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgY29uc3QgcGFyc2VkVHJhbnNmb3JtID0gcGFyc2VUcmFuc2Zvcm0odHJhbnNmb3JtKTtcblxuICAgIGlmICghcGFyc2VkVHJhbnNmb3JtKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYW5pbWF0aW9uID0gdHlwZW9mIGNvbmZpZyA9PT0gJ2Z1bmN0aW9uJyA/IGNvbmZpZyA6IGNyZWF0ZURlZmF1bHREcm9wQW5pbWF0aW9uKGNvbmZpZyk7XG4gICAgc2Nyb2xsSW50b1ZpZXdJZk5lZWRlZChhY3RpdmVOb2RlLCBtZWFzdXJpbmdDb25maWd1cmF0aW9uLmRyYWdnYWJsZS5tZWFzdXJlKTtcbiAgICByZXR1cm4gYW5pbWF0aW9uKHtcbiAgICAgIGFjdGl2ZToge1xuICAgICAgICBpZCxcbiAgICAgICAgZGF0YTogYWN0aXZlRHJhZ2dhYmxlLmRhdGEsXG4gICAgICAgIG5vZGU6IGFjdGl2ZU5vZGUsXG4gICAgICAgIHJlY3Q6IG1lYXN1cmluZ0NvbmZpZ3VyYXRpb24uZHJhZ2dhYmxlLm1lYXN1cmUoYWN0aXZlTm9kZSlcbiAgICAgIH0sXG4gICAgICBkcmFnZ2FibGVOb2RlcyxcbiAgICAgIGRyYWdPdmVybGF5OiB7XG4gICAgICAgIG5vZGUsXG4gICAgICAgIHJlY3Q6IG1lYXN1cmluZ0NvbmZpZ3VyYXRpb24uZHJhZ092ZXJsYXkubWVhc3VyZShtZWFzdXJhYmxlTm9kZSlcbiAgICAgIH0sXG4gICAgICBkcm9wcGFibGVDb250YWluZXJzLFxuICAgICAgbWVhc3VyaW5nQ29uZmlndXJhdGlvbixcbiAgICAgIHRyYW5zZm9ybTogcGFyc2VkVHJhbnNmb3JtXG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEZWZhdWx0RHJvcEFuaW1hdGlvbihvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBkdXJhdGlvbixcbiAgICBlYXNpbmcsXG4gICAgc2lkZUVmZmVjdHMsXG4gICAga2V5ZnJhbWVzXG4gIH0gPSB7IC4uLmRlZmF1bHREcm9wQW5pbWF0aW9uQ29uZmlndXJhdGlvbixcbiAgICAuLi5vcHRpb25zXG4gIH07XG4gIHJldHVybiBfcmVmNCA9PiB7XG4gICAgbGV0IHtcbiAgICAgIGFjdGl2ZSxcbiAgICAgIGRyYWdPdmVybGF5LFxuICAgICAgdHJhbnNmb3JtLFxuICAgICAgLi4ucmVzdFxuICAgIH0gPSBfcmVmNDtcblxuICAgIGlmICghZHVyYXRpb24pIHtcbiAgICAgIC8vIERvIG5vdCBhbmltYXRlIGlmIGFuaW1hdGlvbiBkdXJhdGlvbiBpcyB6ZXJvLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGRlbHRhID0ge1xuICAgICAgeDogZHJhZ092ZXJsYXkucmVjdC5sZWZ0IC0gYWN0aXZlLnJlY3QubGVmdCxcbiAgICAgIHk6IGRyYWdPdmVybGF5LnJlY3QudG9wIC0gYWN0aXZlLnJlY3QudG9wXG4gICAgfTtcbiAgICBjb25zdCBzY2FsZSA9IHtcbiAgICAgIHNjYWxlWDogdHJhbnNmb3JtLnNjYWxlWCAhPT0gMSA/IGFjdGl2ZS5yZWN0LndpZHRoICogdHJhbnNmb3JtLnNjYWxlWCAvIGRyYWdPdmVybGF5LnJlY3Qud2lkdGggOiAxLFxuICAgICAgc2NhbGVZOiB0cmFuc2Zvcm0uc2NhbGVZICE9PSAxID8gYWN0aXZlLnJlY3QuaGVpZ2h0ICogdHJhbnNmb3JtLnNjYWxlWSAvIGRyYWdPdmVybGF5LnJlY3QuaGVpZ2h0IDogMVxuICAgIH07XG4gICAgY29uc3QgZmluYWxUcmFuc2Zvcm0gPSB7XG4gICAgICB4OiB0cmFuc2Zvcm0ueCAtIGRlbHRhLngsXG4gICAgICB5OiB0cmFuc2Zvcm0ueSAtIGRlbHRhLnksXG4gICAgICAuLi5zY2FsZVxuICAgIH07XG4gICAgY29uc3QgYW5pbWF0aW9uS2V5ZnJhbWVzID0ga2V5ZnJhbWVzKHsgLi4ucmVzdCxcbiAgICAgIGFjdGl2ZSxcbiAgICAgIGRyYWdPdmVybGF5LFxuICAgICAgdHJhbnNmb3JtOiB7XG4gICAgICAgIGluaXRpYWw6IHRyYW5zZm9ybSxcbiAgICAgICAgZmluYWw6IGZpbmFsVHJhbnNmb3JtXG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgW2ZpcnN0S2V5ZnJhbWVdID0gYW5pbWF0aW9uS2V5ZnJhbWVzO1xuICAgIGNvbnN0IGxhc3RLZXlmcmFtZSA9IGFuaW1hdGlvbktleWZyYW1lc1thbmltYXRpb25LZXlmcmFtZXMubGVuZ3RoIC0gMV07XG5cbiAgICBpZiAoSlNPTi5zdHJpbmdpZnkoZmlyc3RLZXlmcmFtZSkgPT09IEpTT04uc3RyaW5naWZ5KGxhc3RLZXlmcmFtZSkpIHtcbiAgICAgIC8vIFRoZSBzdGFydCBhbmQgZW5kIGtleWZyYW1lcyBhcmUgdGhlIHNhbWUsIGluZmVyIHRoYXQgdGhlcmUgaXMgbm8gYW5pbWF0aW9uIG5lZWRlZC5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjbGVhbnVwID0gc2lkZUVmZmVjdHMgPT0gbnVsbCA/IHZvaWQgMCA6IHNpZGVFZmZlY3RzKHtcbiAgICAgIGFjdGl2ZSxcbiAgICAgIGRyYWdPdmVybGF5LFxuICAgICAgLi4ucmVzdFxuICAgIH0pO1xuICAgIGNvbnN0IGFuaW1hdGlvbiA9IGRyYWdPdmVybGF5Lm5vZGUuYW5pbWF0ZShhbmltYXRpb25LZXlmcmFtZXMsIHtcbiAgICAgIGR1cmF0aW9uLFxuICAgICAgZWFzaW5nLFxuICAgICAgZmlsbDogJ2ZvcndhcmRzJ1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGFuaW1hdGlvbi5vbmZpbmlzaCA9ICgpID0+IHtcbiAgICAgICAgY2xlYW51cCA9PSBudWxsID8gdm9pZCAwIDogY2xlYW51cCgpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xufVxuXG5sZXQga2V5ID0gMDtcbmZ1bmN0aW9uIHVzZUtleShpZCkge1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKGlkID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBrZXkrKztcbiAgICByZXR1cm4ga2V5O1xuICB9LCBbaWRdKTtcbn1cblxuY29uc3QgRHJhZ092ZXJsYXkgPSAvKiNfX1BVUkVfXyovUmVhY3QubWVtbyhfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBhZGp1c3RTY2FsZSA9IGZhbHNlLFxuICAgIGNoaWxkcmVuLFxuICAgIGRyb3BBbmltYXRpb246IGRyb3BBbmltYXRpb25Db25maWcsXG4gICAgc3R5bGUsXG4gICAgdHJhbnNpdGlvbixcbiAgICBtb2RpZmllcnMsXG4gICAgd3JhcHBlckVsZW1lbnQgPSAnZGl2JyxcbiAgICBjbGFzc05hbWUsXG4gICAgekluZGV4ID0gOTk5XG4gIH0gPSBfcmVmO1xuICBjb25zdCB7XG4gICAgYWN0aXZhdG9yRXZlbnQsXG4gICAgYWN0aXZlLFxuICAgIGFjdGl2ZU5vZGVSZWN0LFxuICAgIGNvbnRhaW5lck5vZGVSZWN0LFxuICAgIGRyYWdnYWJsZU5vZGVzLFxuICAgIGRyb3BwYWJsZUNvbnRhaW5lcnMsXG4gICAgZHJhZ092ZXJsYXksXG4gICAgb3ZlcixcbiAgICBtZWFzdXJpbmdDb25maWd1cmF0aW9uLFxuICAgIHNjcm9sbGFibGVBbmNlc3RvcnMsXG4gICAgc2Nyb2xsYWJsZUFuY2VzdG9yUmVjdHMsXG4gICAgd2luZG93UmVjdFxuICB9ID0gdXNlRG5kQ29udGV4dCgpO1xuICBjb25zdCB0cmFuc2Zvcm0gPSB1c2VDb250ZXh0KEFjdGl2ZURyYWdnYWJsZUNvbnRleHQpO1xuICBjb25zdCBrZXkgPSB1c2VLZXkoYWN0aXZlID09IG51bGwgPyB2b2lkIDAgOiBhY3RpdmUuaWQpO1xuICBjb25zdCBtb2RpZmllZFRyYW5zZm9ybSA9IGFwcGx5TW9kaWZpZXJzKG1vZGlmaWVycywge1xuICAgIGFjdGl2YXRvckV2ZW50LFxuICAgIGFjdGl2ZSxcbiAgICBhY3RpdmVOb2RlUmVjdCxcbiAgICBjb250YWluZXJOb2RlUmVjdCxcbiAgICBkcmFnZ2luZ05vZGVSZWN0OiBkcmFnT3ZlcmxheS5yZWN0LFxuICAgIG92ZXIsXG4gICAgb3ZlcmxheU5vZGVSZWN0OiBkcmFnT3ZlcmxheS5yZWN0LFxuICAgIHNjcm9sbGFibGVBbmNlc3RvcnMsXG4gICAgc2Nyb2xsYWJsZUFuY2VzdG9yUmVjdHMsXG4gICAgdHJhbnNmb3JtLFxuICAgIHdpbmRvd1JlY3RcbiAgfSk7XG4gIGNvbnN0IGluaXRpYWxSZWN0ID0gdXNlSW5pdGlhbFZhbHVlKGFjdGl2ZU5vZGVSZWN0KTtcbiAgY29uc3QgZHJvcEFuaW1hdGlvbiA9IHVzZURyb3BBbmltYXRpb24oe1xuICAgIGNvbmZpZzogZHJvcEFuaW1hdGlvbkNvbmZpZyxcbiAgICBkcmFnZ2FibGVOb2RlcyxcbiAgICBkcm9wcGFibGVDb250YWluZXJzLFxuICAgIG1lYXN1cmluZ0NvbmZpZ3VyYXRpb25cbiAgfSk7IC8vIFdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIGFjdGl2ZSBub2RlIHRvIGJlIG1lYXN1cmVkIGJlZm9yZSBjb25uZWN0aW5nIHRoZSBkcmFnIG92ZXJsYXkgcmVmXG4gIC8vIG90aGVyd2lzZSBjb2xsaXNpb25zIGNhbiBiZSBjb21wdXRlZCBhZ2FpbnN0IGEgbWlzcG9zaXRpb25lZCBkcmFnIG92ZXJsYXlcblxuICBjb25zdCByZWYgPSBpbml0aWFsUmVjdCA/IGRyYWdPdmVybGF5LnNldFJlZiA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTnVsbGlmaWVkQ29udGV4dFByb3ZpZGVyLCBudWxsLCBSZWFjdC5jcmVhdGVFbGVtZW50KEFuaW1hdGlvbk1hbmFnZXIsIHtcbiAgICBhbmltYXRpb246IGRyb3BBbmltYXRpb25cbiAgfSwgYWN0aXZlICYmIGtleSA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoUG9zaXRpb25lZE92ZXJsYXksIHtcbiAgICBrZXk6IGtleSxcbiAgICBpZDogYWN0aXZlLmlkLFxuICAgIHJlZjogcmVmLFxuICAgIGFzOiB3cmFwcGVyRWxlbWVudCxcbiAgICBhY3RpdmF0b3JFdmVudDogYWN0aXZhdG9yRXZlbnQsXG4gICAgYWRqdXN0U2NhbGU6IGFkanVzdFNjYWxlLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgIHRyYW5zaXRpb246IHRyYW5zaXRpb24sXG4gICAgcmVjdDogaW5pdGlhbFJlY3QsXG4gICAgc3R5bGU6IHtcbiAgICAgIHpJbmRleCxcbiAgICAgIC4uLnN0eWxlXG4gICAgfSxcbiAgICB0cmFuc2Zvcm06IG1vZGlmaWVkVHJhbnNmb3JtXG4gIH0sIGNoaWxkcmVuKSA6IG51bGwpKTtcbn0pO1xuXG5leHBvcnQgeyBBdXRvU2Nyb2xsQWN0aXZhdG9yLCBEbmRDb250ZXh0LCBEcmFnT3ZlcmxheSwgS2V5Ym9hcmRDb2RlLCBLZXlib2FyZFNlbnNvciwgTWVhc3VyaW5nRnJlcXVlbmN5LCBNZWFzdXJpbmdTdHJhdGVneSwgTW91c2VTZW5zb3IsIFBvaW50ZXJTZW5zb3IsIFRvdWNoU2Vuc29yLCBUcmF2ZXJzYWxPcmRlciwgYXBwbHlNb2RpZmllcnMsIGNsb3Nlc3RDZW50ZXIsIGNsb3Nlc3RDb3JuZXJzLCBkZWZhdWx0QW5ub3VuY2VtZW50cywgZGVmYXVsdENvb3JkaW5hdGVzLCBkZWZhdWx0RHJvcEFuaW1hdGlvbkNvbmZpZ3VyYXRpb24gYXMgZGVmYXVsdERyb3BBbmltYXRpb24sIGRlZmF1bHREcm9wQW5pbWF0aW9uU2lkZUVmZmVjdHMsIGRlZmF1bHRTY3JlZW5SZWFkZXJJbnN0cnVjdGlvbnMsIGdldENsaWVudFJlY3QsIGdldEZpcnN0Q29sbGlzaW9uLCBnZXRTY3JvbGxhYmxlQW5jZXN0b3JzLCBwb2ludGVyV2l0aGluLCByZWN0SW50ZXJzZWN0aW9uLCB1c2VEbmRDb250ZXh0LCB1c2VEbmRNb25pdG9yLCB1c2VEcmFnZ2FibGUsIHVzZURyb3BwYWJsZSwgdXNlU2Vuc29yLCB1c2VTZW5zb3JzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3JlLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsInVzZU1lbW8iLCJ1c2VSZWYiLCJ1c2VSZWR1Y2VyIiwibWVtbyIsImNsb25lRWxlbWVudCIsImZvcndhcmRSZWYiLCJjcmVhdGVQb3J0YWwiLCJ1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyIsInVzZVVuaXF1ZUlkIiwiZ2V0RXZlbnRDb29yZGluYXRlcyIsImdldFdpbmRvdyIsImlzRG9jdW1lbnQiLCJpc0hUTUxFbGVtZW50IiwiaXNTVkdFbGVtZW50IiwiY2FuVXNlRE9NIiwiaXNXaW5kb3ciLCJpc05vZGUiLCJnZXRPd25lckRvY3VtZW50IiwiYWRkIiwiaXNLZXlib2FyZEV2ZW50Iiwic3VidHJhY3QiLCJ1c2VMYXp5TWVtbyIsInVzZUludGVydmFsIiwidXNlUHJldmlvdXMiLCJ1c2VMYXRlc3RWYWx1ZSIsInVzZUV2ZW50IiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsInVzZU5vZGVSZWYiLCJmaW5kRmlyc3RGb2N1c2FibGVOb2RlIiwiQ1NTIiwidXNlQW5ub3VuY2VtZW50IiwiSGlkZGVuVGV4dCIsIkxpdmVSZWdpb24iLCJEbmRNb25pdG9yQ29udGV4dCIsInVzZURuZE1vbml0b3IiLCJsaXN0ZW5lciIsInJlZ2lzdGVyTGlzdGVuZXIiLCJFcnJvciIsInVuc3Vic2NyaWJlIiwidXNlRG5kTW9uaXRvclByb3ZpZGVyIiwibGlzdGVuZXJzIiwiU2V0IiwiZGVsZXRlIiwiZGlzcGF0Y2giLCJfcmVmIiwidHlwZSIsImV2ZW50IiwiZm9yRWFjaCIsIl9saXN0ZW5lciR0eXBlIiwiY2FsbCIsImRlZmF1bHRTY3JlZW5SZWFkZXJJbnN0cnVjdGlvbnMiLCJkcmFnZ2FibGUiLCJkZWZhdWx0QW5ub3VuY2VtZW50cyIsIm9uRHJhZ1N0YXJ0IiwiYWN0aXZlIiwiaWQiLCJvbkRyYWdPdmVyIiwiX3JlZjIiLCJvdmVyIiwib25EcmFnRW5kIiwiX3JlZjMiLCJvbkRyYWdDYW5jZWwiLCJfcmVmNCIsIkFjY2Vzc2liaWxpdHkiLCJhbm5vdW5jZW1lbnRzIiwiY29udGFpbmVyIiwiaGlkZGVuVGV4dERlc2NyaWJlZEJ5SWQiLCJzY3JlZW5SZWFkZXJJbnN0cnVjdGlvbnMiLCJhbm5vdW5jZSIsImFubm91bmNlbWVudCIsImxpdmVSZWdpb25JZCIsIm1vdW50ZWQiLCJzZXRNb3VudGVkIiwib25EcmFnTW92ZSIsIl9yZWY1IiwiX3JlZjYiLCJtYXJrdXAiLCJjcmVhdGVFbGVtZW50IiwiRnJhZ21lbnQiLCJ2YWx1ZSIsIkFjdGlvbiIsIm5vb3AiLCJ1c2VTZW5zb3IiLCJzZW5zb3IiLCJvcHRpb25zIiwidXNlU2Vuc29ycyIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzZW5zb3JzIiwiQXJyYXkiLCJfa2V5IiwiZmlsdGVyIiwiZGVmYXVsdENvb3JkaW5hdGVzIiwiT2JqZWN0IiwiZnJlZXplIiwieCIsInkiLCJkaXN0YW5jZUJldHdlZW4iLCJwMSIsInAyIiwiTWF0aCIsInNxcnQiLCJwb3ciLCJnZXRSZWxhdGl2ZVRyYW5zZm9ybU9yaWdpbiIsInJlY3QiLCJldmVudENvb3JkaW5hdGVzIiwidHJhbnNmb3JtT3JpZ2luIiwibGVmdCIsIndpZHRoIiwidG9wIiwiaGVpZ2h0Iiwic29ydENvbGxpc2lvbnNBc2MiLCJkYXRhIiwiYSIsImIiLCJzb3J0Q29sbGlzaW9uc0Rlc2MiLCJjb3JuZXJzT2ZSZWN0YW5nbGUiLCJnZXRGaXJzdENvbGxpc2lvbiIsImNvbGxpc2lvbnMiLCJwcm9wZXJ0eSIsImZpcnN0Q29sbGlzaW9uIiwiY2VudGVyT2ZSZWN0YW5nbGUiLCJjbG9zZXN0Q2VudGVyIiwiY29sbGlzaW9uUmVjdCIsImRyb3BwYWJsZVJlY3RzIiwiZHJvcHBhYmxlQ29udGFpbmVycyIsImNlbnRlclJlY3QiLCJkcm9wcGFibGVDb250YWluZXIiLCJnZXQiLCJkaXN0QmV0d2VlbiIsInB1c2giLCJzb3J0IiwiY2xvc2VzdENvcm5lcnMiLCJjb3JuZXJzIiwicmVjdENvcm5lcnMiLCJkaXN0YW5jZXMiLCJyZWR1Y2UiLCJhY2N1bXVsYXRvciIsImNvcm5lciIsImluZGV4IiwiZWZmZWN0aXZlRGlzdGFuY2UiLCJOdW1iZXIiLCJ0b0ZpeGVkIiwiZ2V0SW50ZXJzZWN0aW9uUmF0aW8iLCJlbnRyeSIsInRhcmdldCIsIm1heCIsInJpZ2h0IiwibWluIiwiYm90dG9tIiwidGFyZ2V0QXJlYSIsImVudHJ5QXJlYSIsImludGVyc2VjdGlvbkFyZWEiLCJpbnRlcnNlY3Rpb25SYXRpbyIsInJlY3RJbnRlcnNlY3Rpb24iLCJpc1BvaW50V2l0aGluUmVjdCIsInBvaW50IiwicG9pbnRlcldpdGhpbiIsInBvaW50ZXJDb29yZGluYXRlcyIsImFkanVzdFNjYWxlIiwidHJhbnNmb3JtIiwicmVjdDEiLCJyZWN0MiIsInNjYWxlWCIsInNjYWxlWSIsImdldFJlY3REZWx0YSIsImNyZWF0ZVJlY3RBZGp1c3RtZW50Rm4iLCJtb2RpZmllciIsImFkanVzdENsaWVudFJlY3QiLCJhZGp1c3RtZW50cyIsImFjYyIsImFkanVzdG1lbnQiLCJnZXRBZGp1c3RlZFJlY3QiLCJwYXJzZVRyYW5zZm9ybSIsInN0YXJ0c1dpdGgiLCJ0cmFuc2Zvcm1BcnJheSIsInNsaWNlIiwic3BsaXQiLCJpbnZlcnNlVHJhbnNmb3JtIiwicGFyc2VkVHJhbnNmb3JtIiwidHJhbnNsYXRlWCIsInRyYW5zbGF0ZVkiLCJwYXJzZUZsb2F0IiwiaW5kZXhPZiIsInciLCJoIiwiZGVmYXVsdE9wdGlvbnMiLCJpZ25vcmVUcmFuc2Zvcm0iLCJnZXRDbGllbnRSZWN0IiwiZWxlbWVudCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRUcmFuc2Zvcm1BZ25vc3RpY0NsaWVudFJlY3QiLCJnZXRXaW5kb3dDbGllbnRSZWN0IiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0IiwiaXNGaXhlZCIsIm5vZGUiLCJjb21wdXRlZFN0eWxlIiwicG9zaXRpb24iLCJpc1Njcm9sbGFibGUiLCJvdmVyZmxvd1JlZ2V4IiwicHJvcGVydGllcyIsInNvbWUiLCJ0ZXN0IiwiZ2V0U2Nyb2xsYWJsZUFuY2VzdG9ycyIsImxpbWl0Iiwic2Nyb2xsUGFyZW50cyIsImZpbmRTY3JvbGxhYmxlQW5jZXN0b3JzIiwic2Nyb2xsaW5nRWxlbWVudCIsImluY2x1ZGVzIiwicGFyZW50Tm9kZSIsImdldEZpcnN0U2Nyb2xsYWJsZUFuY2VzdG9yIiwiZmlyc3RTY3JvbGxhYmxlQW5jZXN0b3IiLCJnZXRTY3JvbGxhYmxlRWxlbWVudCIsIndpbmRvdyIsImdldFNjcm9sbFhDb29yZGluYXRlIiwic2Nyb2xsWCIsInNjcm9sbExlZnQiLCJnZXRTY3JvbGxZQ29vcmRpbmF0ZSIsInNjcm9sbFkiLCJzY3JvbGxUb3AiLCJnZXRTY3JvbGxDb29yZGluYXRlcyIsIkRpcmVjdGlvbiIsImlzRG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50IiwiZG9jdW1lbnQiLCJnZXRTY3JvbGxQb3NpdGlvbiIsInNjcm9sbGluZ0NvbnRhaW5lciIsIm1pblNjcm9sbCIsImRpbWVuc2lvbnMiLCJjbGllbnRIZWlnaHQiLCJjbGllbnRXaWR0aCIsIm1heFNjcm9sbCIsInNjcm9sbFdpZHRoIiwic2Nyb2xsSGVpZ2h0IiwiaXNUb3AiLCJpc0xlZnQiLCJpc0JvdHRvbSIsImlzUmlnaHQiLCJkZWZhdWx0VGhyZXNob2xkIiwiZ2V0U2Nyb2xsRGlyZWN0aW9uQW5kU3BlZWQiLCJzY3JvbGxDb250YWluZXIiLCJzY3JvbGxDb250YWluZXJSZWN0IiwiYWNjZWxlcmF0aW9uIiwidGhyZXNob2xkUGVyY2VudGFnZSIsImRpcmVjdGlvbiIsInNwZWVkIiwidGhyZXNob2xkIiwiQmFja3dhcmQiLCJhYnMiLCJGb3J3YXJkIiwiZ2V0U2Nyb2xsRWxlbWVudFJlY3QiLCJnZXRTY3JvbGxPZmZzZXRzIiwic2Nyb2xsYWJsZUFuY2VzdG9ycyIsImdldFNjcm9sbFhPZmZzZXQiLCJnZXRTY3JvbGxZT2Zmc2V0Iiwic2Nyb2xsSW50b1ZpZXdJZk5lZWRlZCIsIm1lYXN1cmUiLCJzY3JvbGxJbnRvVmlldyIsImJsb2NrIiwiaW5saW5lIiwiUmVjdCIsImNvbnN0cnVjdG9yIiwic2Nyb2xsT2Zmc2V0cyIsImF4aXMiLCJrZXlzIiwiZ2V0U2Nyb2xsT2Zmc2V0Iiwia2V5IiwiZGVmaW5lUHJvcGVydHkiLCJjdXJyZW50T2Zmc2V0cyIsInNjcm9sbE9mZnNldHNEZWx0bGEiLCJlbnVtZXJhYmxlIiwiTGlzdGVuZXJzIiwicmVtb3ZlQWxsIiwiX3RoaXMkdGFyZ2V0IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImV2ZW50TmFtZSIsImhhbmRsZXIiLCJfdGhpcyR0YXJnZXQyIiwiYWRkRXZlbnRMaXN0ZW5lciIsImdldEV2ZW50TGlzdGVuZXJUYXJnZXQiLCJFdmVudFRhcmdldCIsImhhc0V4Y2VlZGVkRGlzdGFuY2UiLCJkZWx0YSIsIm1lYXN1cmVtZW50IiwiZHgiLCJkeSIsIkV2ZW50TmFtZSIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwiS2V5Ym9hcmRDb2RlIiwiZGVmYXVsdEtleWJvYXJkQ29kZXMiLCJzdGFydCIsIlNwYWNlIiwiRW50ZXIiLCJjYW5jZWwiLCJFc2MiLCJlbmQiLCJkZWZhdWx0S2V5Ym9hcmRDb29yZGluYXRlR2V0dGVyIiwiY3VycmVudENvb3JkaW5hdGVzIiwiY29kZSIsIlJpZ2h0IiwiTGVmdCIsIkRvd24iLCJVcCIsInVuZGVmaW5lZCIsIktleWJvYXJkU2Vuc29yIiwicHJvcHMiLCJhdXRvU2Nyb2xsRW5hYmxlZCIsInJlZmVyZW5jZUNvb3JkaW5hdGVzIiwid2luZG93TGlzdGVuZXJzIiwiaGFuZGxlS2V5RG93biIsImJpbmQiLCJoYW5kbGVDYW5jZWwiLCJhdHRhY2giLCJoYW5kbGVTdGFydCIsIlJlc2l6ZSIsIlZpc2liaWxpdHlDaGFuZ2UiLCJzZXRUaW1lb3V0IiwiS2V5ZG93biIsImFjdGl2ZU5vZGUiLCJvblN0YXJ0IiwiY3VycmVudCIsImNvbnRleHQiLCJrZXlib2FyZENvZGVzIiwiY29vcmRpbmF0ZUdldHRlciIsInNjcm9sbEJlaGF2aW9yIiwiaGFuZGxlRW5kIiwibmV3Q29vcmRpbmF0ZXMiLCJjb29yZGluYXRlc0RlbHRhIiwic2Nyb2xsRGVsdGEiLCJzY3JvbGxFbGVtZW50UmVjdCIsImNsYW1wZWRDb29yZGluYXRlcyIsImNhblNjcm9sbFgiLCJjYW5TY3JvbGxZIiwibmV3U2Nyb2xsQ29vcmRpbmF0ZXMiLCJjYW5TY3JvbGxUb05ld0Nvb3JkaW5hdGVzIiwic2Nyb2xsVG8iLCJiZWhhdmlvciIsInNjcm9sbEJ5IiwiaGFuZGxlTW92ZSIsImNvb3JkaW5hdGVzIiwib25Nb3ZlIiwib25FbmQiLCJkZXRhY2giLCJvbkNhbmNlbCIsImFjdGl2YXRvcnMiLCJvbkFjdGl2YXRpb24iLCJuYXRpdmVFdmVudCIsImFjdGl2YXRvciIsImFjdGl2YXRvck5vZGUiLCJpc0Rpc3RhbmNlQ29uc3RyYWludCIsImNvbnN0cmFpbnQiLCJCb29sZWFuIiwiaXNEZWxheUNvbnN0cmFpbnQiLCJBYnN0cmFjdFBvaW50ZXJTZW5zb3IiLCJldmVudHMiLCJsaXN0ZW5lclRhcmdldCIsIl9nZXRFdmVudENvb3JkaW5hdGVzIiwiYWN0aXZhdGVkIiwiaW5pdGlhbENvb3JkaW5hdGVzIiwidGltZW91dElkIiwiZG9jdW1lbnRMaXN0ZW5lcnMiLCJoYW5kbGVLZXlkb3duIiwicmVtb3ZlVGV4dFNlbGVjdGlvbiIsImFjdGl2YXRpb25Db25zdHJhaW50IiwiYnlwYXNzQWN0aXZhdGlvbkNvbnN0cmFpbnQiLCJtb3ZlIiwibmFtZSIsInBhc3NpdmUiLCJEcmFnU3RhcnQiLCJDb250ZXh0TWVudSIsImRlbGF5IiwiY2xlYXJUaW1lb3V0IiwiQ2xpY2siLCJjYXB0dXJlIiwiU2VsZWN0aW9uQ2hhbmdlIiwiX2dldEV2ZW50Q29vcmRpbmF0ZXMyIiwidG9sZXJhbmNlIiwiZGlzdGFuY2UiLCJjYW5jZWxhYmxlIiwiX3RoaXMkZG9jdW1lbnQkZ2V0U2VsIiwiZ2V0U2VsZWN0aW9uIiwicmVtb3ZlQWxsUmFuZ2VzIiwiUG9pbnRlclNlbnNvciIsImlzUHJpbWFyeSIsImJ1dHRvbiIsImV2ZW50cyQxIiwiTW91c2VCdXR0b24iLCJNb3VzZVNlbnNvciIsIlJpZ2h0Q2xpY2siLCJldmVudHMkMiIsIlRvdWNoU2Vuc29yIiwic2V0dXAiLCJ0ZWFyZG93biIsInRvdWNoZXMiLCJBdXRvU2Nyb2xsQWN0aXZhdG9yIiwiVHJhdmVyc2FsT3JkZXIiLCJ1c2VBdXRvU2Nyb2xsZXIiLCJQb2ludGVyIiwiY2FuU2Nyb2xsIiwiZHJhZ2dpbmdSZWN0IiwiZW5hYmxlZCIsImludGVydmFsIiwib3JkZXIiLCJUcmVlT3JkZXIiLCJzY3JvbGxhYmxlQW5jZXN0b3JSZWN0cyIsInNjcm9sbEludGVudCIsInVzZVNjcm9sbEludGVudCIsImRpc2FibGVkIiwic2V0QXV0b1Njcm9sbEludGVydmFsIiwiY2xlYXJBdXRvU2Nyb2xsSW50ZXJ2YWwiLCJzY3JvbGxTcGVlZCIsInNjcm9sbERpcmVjdGlvbiIsIkRyYWdnYWJsZVJlY3QiLCJzY3JvbGxDb250YWluZXJSZWYiLCJhdXRvU2Nyb2xsIiwic29ydGVkU2Nyb2xsYWJsZUFuY2VzdG9ycyIsInJldmVyc2UiLCJKU09OIiwic3RyaW5naWZ5IiwiZGVmYXVsdFNjcm9sbEludGVudCIsInByZXZpb3VzRGVsdGEiLCJwcmV2aW91c0ludGVudCIsInNpZ24iLCJ1c2VDYWNoZWROb2RlIiwiZHJhZ2dhYmxlTm9kZXMiLCJkcmFnZ2FibGVOb2RlIiwiY2FjaGVkTm9kZSIsInVzZUNvbWJpbmVBY3RpdmF0b3JzIiwiZ2V0U3ludGhldGljSGFuZGxlciIsIlNlbnNvciIsInNlbnNvckFjdGl2YXRvcnMiLCJtYXAiLCJNZWFzdXJpbmdTdHJhdGVneSIsIk1lYXN1cmluZ0ZyZXF1ZW5jeSIsImRlZmF1bHRWYWx1ZSIsIk1hcCIsInVzZURyb3BwYWJsZU1lYXN1cmluZyIsImNvbnRhaW5lcnMiLCJkcmFnZ2luZyIsImRlcGVuZGVuY2llcyIsImNvbmZpZyIsInF1ZXVlIiwic2V0UXVldWUiLCJmcmVxdWVuY3kiLCJzdHJhdGVneSIsImNvbnRhaW5lcnNSZWYiLCJpc0Rpc2FibGVkIiwiZGlzYWJsZWRSZWYiLCJtZWFzdXJlRHJvcHBhYmxlQ29udGFpbmVycyIsImlkcyIsImNvbmNhdCIsInByZXZpb3VzVmFsdWUiLCJzZXQiLCJtZWFzdXJpbmdTY2hlZHVsZWQiLCJBbHdheXMiLCJCZWZvcmVEcmFnZ2luZyIsInVzZUluaXRpYWxWYWx1ZSIsImNvbXB1dGVGbiIsInVzZUluaXRpYWxSZWN0IiwidXNlTXV0YXRpb25PYnNlcnZlciIsImNhbGxiYWNrIiwiaGFuZGxlTXV0YXRpb25zIiwibXV0YXRpb25PYnNlcnZlciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJkaXNjb25uZWN0IiwidXNlUmVzaXplT2JzZXJ2ZXIiLCJoYW5kbGVSZXNpemUiLCJyZXNpemVPYnNlcnZlciIsIlJlc2l6ZU9ic2VydmVyIiwiZGVmYXVsdE1lYXN1cmUiLCJ1c2VSZWN0IiwiZmFsbGJhY2tSZWN0IiwibWVhc3VyZVJlY3QiLCJyZWR1Y2VyIiwicmVjb3JkcyIsInJlY29yZCIsIkhUTUxFbGVtZW50IiwiY29udGFpbnMiLCJvYnNlcnZlIiwiYm9keSIsImNoaWxkTGlzdCIsInN1YnRyZWUiLCJjdXJyZW50UmVjdCIsImlzQ29ubmVjdGVkIiwibmV3UmVjdCIsInVzZVJlY3REZWx0YSIsImluaXRpYWxSZWN0IiwiZGVmYXVsdFZhbHVlJDEiLCJ1c2VTY3JvbGxhYmxlQW5jZXN0b3JzIiwicHJldmlvdXNOb2RlIiwiYW5jZXN0b3JzIiwidXNlU2Nyb2xsT2Zmc2V0cyIsImVsZW1lbnRzIiwic2Nyb2xsQ29vcmRpbmF0ZXMiLCJzZXRTY3JvbGxDb29yZGluYXRlcyIsInByZXZFbGVtZW50cyIsImhhbmRsZVNjcm9sbCIsInByZXZpb3VzRWxlbWVudHMiLCJjbGVhbnVwIiwiZW50cmllcyIsInNjcm9sbGFibGVFbGVtZW50IiwiZnJvbSIsInZhbHVlcyIsInVzZVNjcm9sbE9mZnNldHNEZWx0YSIsImluaXRpYWxTY3JvbGxPZmZzZXRzIiwiaGFzU2Nyb2xsT2Zmc2V0cyIsInVzZVNlbnNvclNldHVwIiwidGVhcmRvd25GbnMiLCJ1c2VTeW50aGV0aWNMaXN0ZW5lcnMiLCJ1c2VXaW5kb3dSZWN0IiwiZGVmYXVsdFZhbHVlJDIiLCJ1c2VSZWN0cyIsImZpcnN0RWxlbWVudCIsIndpbmRvd1JlY3QiLCJyZWN0cyIsIm1lYXN1cmVSZWN0cyIsImdldE1lYXN1cmFibGVOb2RlIiwiY2hpbGRyZW4iLCJmaXJzdENoaWxkIiwidXNlRHJhZ092ZXJsYXlNZWFzdXJpbmciLCJzZXRSZWN0IiwiaGFuZGxlTm9kZUNoYW5nZSIsIm5vZGVSZWYiLCJzZXRSZWYiLCJkZWZhdWx0U2Vuc29ycyIsImRlZmF1bHREYXRhIiwiZGVmYXVsdE1lYXN1cmluZ0NvbmZpZ3VyYXRpb24iLCJkcm9wcGFibGUiLCJXaGlsZURyYWdnaW5nIiwiT3B0aW1pemVkIiwiZHJhZ092ZXJsYXkiLCJEcm9wcGFibGVDb250YWluZXJzTWFwIiwiX3N1cGVyJGdldCIsInRvQXJyYXkiLCJnZXRFbmFibGVkIiwiZ2V0Tm9kZUZvciIsIl90aGlzJGdldCRub2RlJGN1cnJlbiIsIl90aGlzJGdldCIsImRlZmF1bHRQdWJsaWNDb250ZXh0IiwiYWN0aXZhdG9yRXZlbnQiLCJhY3RpdmVOb2RlUmVjdCIsImNvbnRhaW5lck5vZGVSZWN0IiwibWVhc3VyaW5nQ29uZmlndXJhdGlvbiIsImRlZmF1bHRJbnRlcm5hbENvbnRleHQiLCJhcmlhRGVzY3JpYmVkQnlJZCIsIkludGVybmFsQ29udGV4dCIsIlB1YmxpY0NvbnRleHQiLCJnZXRJbml0aWFsU3RhdGUiLCJub2RlcyIsInRyYW5zbGF0ZSIsInN0YXRlIiwiYWN0aW9uIiwiRHJhZ01vdmUiLCJEcmFnRW5kIiwiRHJhZ0NhbmNlbCIsIlJlZ2lzdGVyRHJvcHBhYmxlIiwiU2V0RHJvcHBhYmxlRGlzYWJsZWQiLCJVbnJlZ2lzdGVyRHJvcHBhYmxlIiwiUmVzdG9yZUZvY3VzIiwicHJldmlvdXNBY3RpdmF0b3JFdmVudCIsInByZXZpb3VzQWN0aXZlSWQiLCJhY3RpdmVFbGVtZW50IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZm9jdXNhYmxlTm9kZSIsImZvY3VzIiwiYXBwbHlNb2RpZmllcnMiLCJtb2RpZmllcnMiLCJhcmdzIiwidXNlTWVhc3VyaW5nQ29uZmlndXJhdGlvbiIsInVzZUxheW91dFNoaWZ0U2Nyb2xsQ29tcGVuc2F0aW9uIiwiaW5pdGlhbGl6ZWQiLCJyZWN0RGVsdGEiLCJBY3RpdmVEcmFnZ2FibGVDb250ZXh0IiwiU3RhdHVzIiwiRG5kQ29udGV4dCIsIl9zZW5zb3JDb250ZXh0JGN1cnJlbiIsIl9kcmFnT3ZlcmxheSRub2RlUmVmJCIsIl9kcmFnT3ZlcmxheSRyZWN0IiwiX292ZXIkcmVjdCIsImFjY2Vzc2liaWxpdHkiLCJjb2xsaXNpb25EZXRlY3Rpb24iLCJtZWFzdXJpbmciLCJzdG9yZSIsImRpc3BhdGNoTW9uaXRvckV2ZW50IiwicmVnaXN0ZXJNb25pdG9yTGlzdGVuZXIiLCJzdGF0dXMiLCJzZXRTdGF0dXMiLCJVbmluaXRpYWxpemVkIiwiaXNJbml0aWFsaXplZCIsIkluaXRpYWxpemVkIiwiYWN0aXZlSWQiLCJhY3RpdmVSZWN0cyIsImluaXRpYWwiLCJ0cmFuc2xhdGVkIiwiX25vZGUkZGF0YSIsImFjdGl2ZVJlZiIsImFjdGl2ZVNlbnNvciIsInNldEFjdGl2ZVNlbnNvciIsInNldEFjdGl2YXRvckV2ZW50IiwibGF0ZXN0UHJvcHMiLCJkcmFnZ2FibGVEZXNjcmliZWRCeUlkIiwiZW5hYmxlZERyb3BwYWJsZUNvbnRhaW5lcnMiLCJhY3RpdmF0aW9uQ29vcmRpbmF0ZXMiLCJhdXRvU2Nyb2xsT3B0aW9ucyIsImdldEF1dG9TY3JvbGxlck9wdGlvbnMiLCJpbml0aWFsQWN0aXZlTm9kZVJlY3QiLCJsYXlvdXRTaGlmdENvbXBlbnNhdGlvbiIsInBhcmVudEVsZW1lbnQiLCJzZW5zb3JDb250ZXh0IiwiZHJhZ2dpbmdOb2RlIiwiZHJhZ2dpbmdOb2RlUmVjdCIsInNjcm9sbEFkanVzdGVkVHJhbnNsYXRlIiwib3Zlck5vZGUiLCJ1c2VzRHJhZ092ZXJsYXkiLCJub2RlUmVjdERlbHRhIiwibW9kaWZpZWRUcmFuc2xhdGUiLCJvdmVybGF5Tm9kZVJlY3QiLCJzY3JvbGxBZGp1c3RtZW50IiwiYWN0aXZlTm9kZVNjcm9sbERlbHRhIiwib3ZlcklkIiwic2V0T3ZlciIsImFwcGxpZWRUcmFuc2xhdGUiLCJpbnN0YW50aWF0ZVNlbnNvciIsInNlbnNvckluc3RhbmNlIiwiSW5pdGlhbGl6aW5nIiwiY3JlYXRlSGFuZGxlciIsImNhbmNlbERyb3AiLCJzaG91bGRDYW5jZWwiLCJQcm9taXNlIiwicmVzb2x2ZSIsImJpbmRBY3RpdmF0b3JUb1NlbnNvckluc3RhbnRpYXRvciIsImFjdGl2ZURyYWdnYWJsZU5vZGUiLCJkbmRLaXQiLCJkZWZhdWx0UHJldmVudGVkIiwiYWN0aXZhdGlvbkNvbnRleHQiLCJzaG91bGRBY3RpdmF0ZSIsImNhcHR1cmVkQnkiLCJvdmVyQ29udGFpbmVyIiwicHVibGljQ29udGV4dCIsImludGVybmFsQ29udGV4dCIsIlByb3ZpZGVyIiwicmVzdG9yZUZvY3VzIiwiYWN0aXZlU2Vuc29yRGlzYWJsZXNBdXRvc2Nyb2xsIiwiYXV0b1Njcm9sbEdsb2JhbGx5RGlzYWJsZWQiLCJOdWxsQ29udGV4dCIsImRlZmF1bHRSb2xlIiwiSURfUFJFRklYIiwidXNlRHJhZ2dhYmxlIiwiYXR0cmlidXRlcyIsInJvbGUiLCJyb2xlRGVzY3JpcHRpb24iLCJ0YWJJbmRleCIsImlzRHJhZ2dpbmciLCJzZXROb2RlUmVmIiwic2V0QWN0aXZhdG9yTm9kZVJlZiIsImRhdGFSZWYiLCJtZW1vaXplZEF0dHJpYnV0ZXMiLCJ1c2VEbmRDb250ZXh0IiwiSURfUFJFRklYJDEiLCJkZWZhdWx0UmVzaXplT2JzZXJ2ZXJDb25maWciLCJ0aW1lb3V0IiwidXNlRHJvcHBhYmxlIiwicmVzaXplT2JzZXJ2ZXJDb25maWciLCJwcmV2aW91cyIsInJlc2l6ZU9ic2VydmVyQ29ubmVjdGVkIiwiY2FsbGJhY2tJZCIsInJlc2l6ZU9ic2VydmVyRGlzYWJsZWQiLCJ1cGRhdGVNZWFzdXJlbWVudHNGb3IiLCJyZXNpemVPYnNlcnZlclRpbWVvdXQiLCJpc0FycmF5IiwibmV3RWxlbWVudCIsInByZXZpb3VzRWxlbWVudCIsInVub2JzZXJ2ZSIsImlzT3ZlciIsIkFuaW1hdGlvbk1hbmFnZXIiLCJhbmltYXRpb24iLCJjbG9uZWRDaGlsZHJlbiIsInNldENsb25lZENoaWxkcmVuIiwic2V0RWxlbWVudCIsInByZXZpb3VzQ2hpbGRyZW4iLCJ0aGVuIiwicmVmIiwiZGVmYXVsdFRyYW5zZm9ybSIsIk51bGxpZmllZENvbnRleHRQcm92aWRlciIsImJhc2VTdHlsZXMiLCJ0b3VjaEFjdGlvbiIsImRlZmF1bHRUcmFuc2l0aW9uIiwiaXNLZXlib2FyZEFjdGl2YXRvciIsIlBvc2l0aW9uZWRPdmVybGF5IiwiYXMiLCJjbGFzc05hbWUiLCJzdHlsZSIsInRyYW5zaXRpb24iLCJzY2FsZUFkanVzdGVkVHJhbnNmb3JtIiwic3R5bGVzIiwiVHJhbnNmb3JtIiwidG9TdHJpbmciLCJkZWZhdWx0RHJvcEFuaW1hdGlvblNpZGVFZmZlY3RzIiwib3JpZ2luYWxTdHlsZXMiLCJnZXRQcm9wZXJ0eVZhbHVlIiwic2V0UHJvcGVydHkiLCJjbGFzc0xpc3QiLCJyZW1vdmUiLCJkZWZhdWx0S2V5ZnJhbWVSZXNvbHZlciIsImZpbmFsIiwiZGVmYXVsdERyb3BBbmltYXRpb25Db25maWd1cmF0aW9uIiwiZHVyYXRpb24iLCJlYXNpbmciLCJrZXlmcmFtZXMiLCJzaWRlRWZmZWN0cyIsIm9wYWNpdHkiLCJ1c2VEcm9wQW5pbWF0aW9uIiwiYWN0aXZlRHJhZ2dhYmxlIiwibWVhc3VyYWJsZU5vZGUiLCJjcmVhdGVEZWZhdWx0RHJvcEFuaW1hdGlvbiIsInJlc3QiLCJzY2FsZSIsImZpbmFsVHJhbnNmb3JtIiwiYW5pbWF0aW9uS2V5ZnJhbWVzIiwiZmlyc3RLZXlmcmFtZSIsImxhc3RLZXlmcmFtZSIsImFuaW1hdGUiLCJmaWxsIiwib25maW5pc2giLCJ1c2VLZXkiLCJEcmFnT3ZlcmxheSIsImRyb3BBbmltYXRpb24iLCJkcm9wQW5pbWF0aW9uQ29uZmlnIiwid3JhcHBlckVsZW1lbnQiLCJ6SW5kZXgiLCJtb2RpZmllZFRyYW5zZm9ybSIsImRlZmF1bHREcm9wQW5pbWF0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@dnd-kit/core/dist/core.esm.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@dnd-kit/sortable/dist/sortable.esm.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@dnd-kit/sortable/dist/sortable.esm.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SortableContext: () => (/* binding */ SortableContext),\n/* harmony export */   arrayMove: () => (/* binding */ arrayMove),\n/* harmony export */   arraySwap: () => (/* binding */ arraySwap),\n/* harmony export */   defaultAnimateLayoutChanges: () => (/* binding */ defaultAnimateLayoutChanges),\n/* harmony export */   defaultNewIndexGetter: () => (/* binding */ defaultNewIndexGetter),\n/* harmony export */   hasSortableData: () => (/* binding */ hasSortableData),\n/* harmony export */   horizontalListSortingStrategy: () => (/* binding */ horizontalListSortingStrategy),\n/* harmony export */   rectSortingStrategy: () => (/* binding */ rectSortingStrategy),\n/* harmony export */   rectSwappingStrategy: () => (/* binding */ rectSwappingStrategy),\n/* harmony export */   sortableKeyboardCoordinates: () => (/* binding */ sortableKeyboardCoordinates),\n/* harmony export */   useSortable: () => (/* binding */ useSortable),\n/* harmony export */   verticalListSortingStrategy: () => (/* binding */ verticalListSortingStrategy)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @dnd-kit/core */ \"(ssr)/../../node_modules/@dnd-kit/core/dist/core.esm.js\");\n/* harmony import */ var _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @dnd-kit/utilities */ \"(ssr)/../../node_modules/@dnd-kit/utilities/dist/utilities.esm.js\");\n\n\n\n/**\r\n * Move an array item to a different position. Returns a new array with the item moved to the new position.\r\n */ function arrayMove(array, from, to) {\n    const newArray = array.slice();\n    newArray.splice(to < 0 ? newArray.length + to : to, 0, newArray.splice(from, 1)[0]);\n    return newArray;\n}\n/**\r\n * Swap an array item to a different position. Returns a new array with the item swapped to the new position.\r\n */ function arraySwap(array, from, to) {\n    const newArray = array.slice();\n    newArray[from] = array[to];\n    newArray[to] = array[from];\n    return newArray;\n}\nfunction getSortedRects(items, rects) {\n    return items.reduce((accumulator, id, index)=>{\n        const rect = rects.get(id);\n        if (rect) {\n            accumulator[index] = rect;\n        }\n        return accumulator;\n    }, Array(items.length));\n}\nfunction isValidIndex(index) {\n    return index !== null && index >= 0;\n}\nfunction itemsEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (a.length !== b.length) {\n        return false;\n    }\n    for(let i = 0; i < a.length; i++){\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction normalizeDisabled(disabled) {\n    if (typeof disabled === \"boolean\") {\n        return {\n            draggable: disabled,\n            droppable: disabled\n        };\n    }\n    return disabled;\n}\n// To-do: We should be calculating scale transformation\nconst defaultScale = {\n    scaleX: 1,\n    scaleY: 1\n};\nconst horizontalListSortingStrategy = (_ref)=>{\n    var _rects$activeIndex;\n    let { rects, activeNodeRect: fallbackActiveRect, activeIndex, overIndex, index } = _ref;\n    const activeNodeRect = (_rects$activeIndex = rects[activeIndex]) != null ? _rects$activeIndex : fallbackActiveRect;\n    if (!activeNodeRect) {\n        return null;\n    }\n    const itemGap = getItemGap(rects, index, activeIndex);\n    if (index === activeIndex) {\n        const newIndexRect = rects[overIndex];\n        if (!newIndexRect) {\n            return null;\n        }\n        return {\n            x: activeIndex < overIndex ? newIndexRect.left + newIndexRect.width - (activeNodeRect.left + activeNodeRect.width) : newIndexRect.left - activeNodeRect.left,\n            y: 0,\n            ...defaultScale\n        };\n    }\n    if (index > activeIndex && index <= overIndex) {\n        return {\n            x: -activeNodeRect.width - itemGap,\n            y: 0,\n            ...defaultScale\n        };\n    }\n    if (index < activeIndex && index >= overIndex) {\n        return {\n            x: activeNodeRect.width + itemGap,\n            y: 0,\n            ...defaultScale\n        };\n    }\n    return {\n        x: 0,\n        y: 0,\n        ...defaultScale\n    };\n};\nfunction getItemGap(rects, index, activeIndex) {\n    const currentRect = rects[index];\n    const previousRect = rects[index - 1];\n    const nextRect = rects[index + 1];\n    if (!currentRect || !previousRect && !nextRect) {\n        return 0;\n    }\n    if (activeIndex < index) {\n        return previousRect ? currentRect.left - (previousRect.left + previousRect.width) : nextRect.left - (currentRect.left + currentRect.width);\n    }\n    return nextRect ? nextRect.left - (currentRect.left + currentRect.width) : currentRect.left - (previousRect.left + previousRect.width);\n}\nconst rectSortingStrategy = (_ref)=>{\n    let { rects, activeIndex, overIndex, index } = _ref;\n    const newRects = arrayMove(rects, overIndex, activeIndex);\n    const oldRect = rects[index];\n    const newRect = newRects[index];\n    if (!newRect || !oldRect) {\n        return null;\n    }\n    return {\n        x: newRect.left - oldRect.left,\n        y: newRect.top - oldRect.top,\n        scaleX: newRect.width / oldRect.width,\n        scaleY: newRect.height / oldRect.height\n    };\n};\nconst rectSwappingStrategy = (_ref)=>{\n    let { activeIndex, index, rects, overIndex } = _ref;\n    let oldRect;\n    let newRect;\n    if (index === activeIndex) {\n        oldRect = rects[index];\n        newRect = rects[overIndex];\n    }\n    if (index === overIndex) {\n        oldRect = rects[index];\n        newRect = rects[activeIndex];\n    }\n    if (!newRect || !oldRect) {\n        return null;\n    }\n    return {\n        x: newRect.left - oldRect.left,\n        y: newRect.top - oldRect.top,\n        scaleX: newRect.width / oldRect.width,\n        scaleY: newRect.height / oldRect.height\n    };\n};\n// To-do: We should be calculating scale transformation\nconst defaultScale$1 = {\n    scaleX: 1,\n    scaleY: 1\n};\nconst verticalListSortingStrategy = (_ref)=>{\n    var _rects$activeIndex;\n    let { activeIndex, activeNodeRect: fallbackActiveRect, index, rects, overIndex } = _ref;\n    const activeNodeRect = (_rects$activeIndex = rects[activeIndex]) != null ? _rects$activeIndex : fallbackActiveRect;\n    if (!activeNodeRect) {\n        return null;\n    }\n    if (index === activeIndex) {\n        const overIndexRect = rects[overIndex];\n        if (!overIndexRect) {\n            return null;\n        }\n        return {\n            x: 0,\n            y: activeIndex < overIndex ? overIndexRect.top + overIndexRect.height - (activeNodeRect.top + activeNodeRect.height) : overIndexRect.top - activeNodeRect.top,\n            ...defaultScale$1\n        };\n    }\n    const itemGap = getItemGap$1(rects, index, activeIndex);\n    if (index > activeIndex && index <= overIndex) {\n        return {\n            x: 0,\n            y: -activeNodeRect.height - itemGap,\n            ...defaultScale$1\n        };\n    }\n    if (index < activeIndex && index >= overIndex) {\n        return {\n            x: 0,\n            y: activeNodeRect.height + itemGap,\n            ...defaultScale$1\n        };\n    }\n    return {\n        x: 0,\n        y: 0,\n        ...defaultScale$1\n    };\n};\nfunction getItemGap$1(clientRects, index, activeIndex) {\n    const currentRect = clientRects[index];\n    const previousRect = clientRects[index - 1];\n    const nextRect = clientRects[index + 1];\n    if (!currentRect) {\n        return 0;\n    }\n    if (activeIndex < index) {\n        return previousRect ? currentRect.top - (previousRect.top + previousRect.height) : nextRect ? nextRect.top - (currentRect.top + currentRect.height) : 0;\n    }\n    return nextRect ? nextRect.top - (currentRect.top + currentRect.height) : previousRect ? currentRect.top - (previousRect.top + previousRect.height) : 0;\n}\nconst ID_PREFIX = \"Sortable\";\nconst Context = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext({\n    activeIndex: -1,\n    containerId: ID_PREFIX,\n    disableTransforms: false,\n    items: [],\n    overIndex: -1,\n    useDragOverlay: false,\n    sortedRects: [],\n    strategy: rectSortingStrategy,\n    disabled: {\n        draggable: false,\n        droppable: false\n    }\n});\nfunction SortableContext(_ref) {\n    let { children, id, items: userDefinedItems, strategy = rectSortingStrategy, disabled: disabledProp = false } = _ref;\n    const { active, dragOverlay, droppableRects, over, measureDroppableContainers } = (0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.useDndContext)();\n    const containerId = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useUniqueId)(ID_PREFIX, id);\n    const useDragOverlay = Boolean(dragOverlay.rect !== null);\n    const items = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>userDefinedItems.map((item)=>typeof item === \"object\" && \"id\" in item ? item.id : item), [\n        userDefinedItems\n    ]);\n    const isDragging = active != null;\n    const activeIndex = active ? items.indexOf(active.id) : -1;\n    const overIndex = over ? items.indexOf(over.id) : -1;\n    const previousItemsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(items);\n    const itemsHaveChanged = !itemsEqual(items, previousItemsRef.current);\n    const disableTransforms = overIndex !== -1 && activeIndex === -1 || itemsHaveChanged;\n    const disabled = normalizeDisabled(disabledProp);\n    (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        if (itemsHaveChanged && isDragging) {\n            measureDroppableContainers(items);\n        }\n    }, [\n        itemsHaveChanged,\n        items,\n        isDragging,\n        measureDroppableContainers\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        previousItemsRef.current = items;\n    }, [\n        items\n    ]);\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            activeIndex,\n            containerId,\n            disabled,\n            disableTransforms,\n            items,\n            overIndex,\n            useDragOverlay,\n            sortedRects: getSortedRects(items, droppableRects),\n            strategy\n        }), [\n        activeIndex,\n        containerId,\n        disabled.draggable,\n        disabled.droppable,\n        disableTransforms,\n        items,\n        overIndex,\n        droppableRects,\n        useDragOverlay,\n        strategy\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Context.Provider, {\n        value: contextValue\n    }, children);\n}\nconst defaultNewIndexGetter = (_ref)=>{\n    let { id, items, activeIndex, overIndex } = _ref;\n    return arrayMove(items, activeIndex, overIndex).indexOf(id);\n};\nconst defaultAnimateLayoutChanges = (_ref2)=>{\n    let { containerId, isSorting, wasDragging, index, items, newIndex, previousItems, previousContainerId, transition } = _ref2;\n    if (!transition || !wasDragging) {\n        return false;\n    }\n    if (previousItems !== items && index === newIndex) {\n        return false;\n    }\n    if (isSorting) {\n        return true;\n    }\n    return newIndex !== index && containerId === previousContainerId;\n};\nconst defaultTransition = {\n    duration: 200,\n    easing: \"ease\"\n};\nconst transitionProperty = \"transform\";\nconst disabledTransition = /*#__PURE__*/ _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.CSS.Transition.toString({\n    property: transitionProperty,\n    duration: 0,\n    easing: \"linear\"\n});\nconst defaultAttributes = {\n    roleDescription: \"sortable\"\n};\n/*\r\n * When the index of an item changes while sorting,\r\n * we need to temporarily disable the transforms\r\n */ function useDerivedTransform(_ref) {\n    let { disabled, index, node, rect } = _ref;\n    const [derivedTransform, setDerivedtransform] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const previousIndex = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(index);\n    (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        if (!disabled && index !== previousIndex.current && node.current) {\n            const initial = rect.current;\n            if (initial) {\n                const current = (0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.getClientRect)(node.current, {\n                    ignoreTransform: true\n                });\n                const delta = {\n                    x: initial.left - current.left,\n                    y: initial.top - current.top,\n                    scaleX: initial.width / current.width,\n                    scaleY: initial.height / current.height\n                };\n                if (delta.x || delta.y) {\n                    setDerivedtransform(delta);\n                }\n            }\n        }\n        if (index !== previousIndex.current) {\n            previousIndex.current = index;\n        }\n    }, [\n        disabled,\n        index,\n        node,\n        rect\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (derivedTransform) {\n            setDerivedtransform(null);\n        }\n    }, [\n        derivedTransform\n    ]);\n    return derivedTransform;\n}\nfunction useSortable(_ref) {\n    let { animateLayoutChanges = defaultAnimateLayoutChanges, attributes: userDefinedAttributes, disabled: localDisabled, data: customData, getNewIndex = defaultNewIndexGetter, id, strategy: localStrategy, resizeObserverConfig, transition = defaultTransition } = _ref;\n    const { items, containerId, activeIndex, disabled: globalDisabled, disableTransforms, sortedRects, overIndex, useDragOverlay, strategy: globalStrategy } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Context);\n    const disabled = normalizeLocalDisabled(localDisabled, globalDisabled);\n    const index = items.indexOf(id);\n    const data = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            sortable: {\n                containerId,\n                index,\n                items\n            },\n            ...customData\n        }), [\n        containerId,\n        customData,\n        index,\n        items\n    ]);\n    const itemsAfterCurrentSortable = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>items.slice(items.indexOf(id)), [\n        items,\n        id\n    ]);\n    const { rect, node, isOver, setNodeRef: setDroppableNodeRef } = (0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.useDroppable)({\n        id,\n        data,\n        disabled: disabled.droppable,\n        resizeObserverConfig: {\n            updateMeasurementsFor: itemsAfterCurrentSortable,\n            ...resizeObserverConfig\n        }\n    });\n    const { active, activatorEvent, activeNodeRect, attributes, setNodeRef: setDraggableNodeRef, listeners, isDragging, over, setActivatorNodeRef, transform } = (0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.useDraggable)({\n        id,\n        data,\n        attributes: {\n            ...defaultAttributes,\n            ...userDefinedAttributes\n        },\n        disabled: disabled.draggable\n    });\n    const setNodeRef = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useCombinedRefs)(setDroppableNodeRef, setDraggableNodeRef);\n    const isSorting = Boolean(active);\n    const displaceItem = isSorting && !disableTransforms && isValidIndex(activeIndex) && isValidIndex(overIndex);\n    const shouldDisplaceDragSource = !useDragOverlay && isDragging;\n    const dragSourceDisplacement = shouldDisplaceDragSource && displaceItem ? transform : null;\n    const strategy = localStrategy != null ? localStrategy : globalStrategy;\n    const finalTransform = displaceItem ? dragSourceDisplacement != null ? dragSourceDisplacement : strategy({\n        rects: sortedRects,\n        activeNodeRect,\n        activeIndex,\n        overIndex,\n        index\n    }) : null;\n    const newIndex = isValidIndex(activeIndex) && isValidIndex(overIndex) ? getNewIndex({\n        id,\n        items,\n        activeIndex,\n        overIndex\n    }) : index;\n    const activeId = active == null ? void 0 : active.id;\n    const previous = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        activeId,\n        items,\n        newIndex,\n        containerId\n    });\n    const itemsHaveChanged = items !== previous.current.items;\n    const shouldAnimateLayoutChanges = animateLayoutChanges({\n        active,\n        containerId,\n        isDragging,\n        isSorting,\n        id,\n        index,\n        items,\n        newIndex: previous.current.newIndex,\n        previousItems: previous.current.items,\n        previousContainerId: previous.current.containerId,\n        transition,\n        wasDragging: previous.current.activeId != null\n    });\n    const derivedTransform = useDerivedTransform({\n        disabled: !shouldAnimateLayoutChanges,\n        index,\n        node,\n        rect\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (isSorting && previous.current.newIndex !== newIndex) {\n            previous.current.newIndex = newIndex;\n        }\n        if (containerId !== previous.current.containerId) {\n            previous.current.containerId = containerId;\n        }\n        if (items !== previous.current.items) {\n            previous.current.items = items;\n        }\n    }, [\n        isSorting,\n        newIndex,\n        containerId,\n        items\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (activeId === previous.current.activeId) {\n            return;\n        }\n        if (activeId && !previous.current.activeId) {\n            previous.current.activeId = activeId;\n            return;\n        }\n        const timeoutId = setTimeout(()=>{\n            previous.current.activeId = activeId;\n        }, 50);\n        return ()=>clearTimeout(timeoutId);\n    }, [\n        activeId\n    ]);\n    return {\n        active,\n        activeIndex,\n        attributes,\n        data,\n        rect,\n        index,\n        newIndex,\n        items,\n        isOver,\n        isSorting,\n        isDragging,\n        listeners,\n        node,\n        overIndex,\n        over,\n        setNodeRef,\n        setActivatorNodeRef,\n        setDroppableNodeRef,\n        setDraggableNodeRef,\n        transform: derivedTransform != null ? derivedTransform : finalTransform,\n        transition: getTransition()\n    };\n    function getTransition() {\n        if (derivedTransform || // Or to prevent items jumping to back to their \"new\" position when items change\n        itemsHaveChanged && previous.current.newIndex === index) {\n            return disabledTransition;\n        }\n        if (shouldDisplaceDragSource && !(0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isKeyboardEvent)(activatorEvent) || !transition) {\n            return undefined;\n        }\n        if (isSorting || shouldAnimateLayoutChanges) {\n            return _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.CSS.Transition.toString({\n                ...transition,\n                property: transitionProperty\n            });\n        }\n        return undefined;\n    }\n}\nfunction normalizeLocalDisabled(localDisabled, globalDisabled) {\n    var _localDisabled$dragga, _localDisabled$droppa;\n    if (typeof localDisabled === \"boolean\") {\n        return {\n            draggable: localDisabled,\n            // Backwards compatibility\n            droppable: false\n        };\n    }\n    return {\n        draggable: (_localDisabled$dragga = localDisabled == null ? void 0 : localDisabled.draggable) != null ? _localDisabled$dragga : globalDisabled.draggable,\n        droppable: (_localDisabled$droppa = localDisabled == null ? void 0 : localDisabled.droppable) != null ? _localDisabled$droppa : globalDisabled.droppable\n    };\n}\nfunction hasSortableData(entry) {\n    if (!entry) {\n        return false;\n    }\n    const data = entry.data.current;\n    if (data && \"sortable\" in data && typeof data.sortable === \"object\" && \"containerId\" in data.sortable && \"items\" in data.sortable && \"index\" in data.sortable) {\n        return true;\n    }\n    return false;\n}\nconst directions = [\n    _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Down,\n    _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Right,\n    _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Up,\n    _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Left\n];\nconst sortableKeyboardCoordinates = (event, _ref)=>{\n    let { context: { active, collisionRect, droppableRects, droppableContainers, over, scrollableAncestors } } = _ref;\n    if (directions.includes(event.code)) {\n        event.preventDefault();\n        if (!active || !collisionRect) {\n            return;\n        }\n        const filteredContainers = [];\n        droppableContainers.getEnabled().forEach((entry)=>{\n            if (!entry || entry != null && entry.disabled) {\n                return;\n            }\n            const rect = droppableRects.get(entry.id);\n            if (!rect) {\n                return;\n            }\n            switch(event.code){\n                case _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Down:\n                    if (collisionRect.top < rect.top) {\n                        filteredContainers.push(entry);\n                    }\n                    break;\n                case _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Up:\n                    if (collisionRect.top > rect.top) {\n                        filteredContainers.push(entry);\n                    }\n                    break;\n                case _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Left:\n                    if (collisionRect.left > rect.left) {\n                        filteredContainers.push(entry);\n                    }\n                    break;\n                case _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Right:\n                    if (collisionRect.left < rect.left) {\n                        filteredContainers.push(entry);\n                    }\n                    break;\n            }\n        });\n        const collisions = (0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.closestCorners)({\n            active,\n            collisionRect: collisionRect,\n            droppableRects,\n            droppableContainers: filteredContainers,\n            pointerCoordinates: null\n        });\n        let closestId = (0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.getFirstCollision)(collisions, \"id\");\n        if (closestId === (over == null ? void 0 : over.id) && collisions.length > 1) {\n            closestId = collisions[1].id;\n        }\n        if (closestId != null) {\n            const activeDroppable = droppableContainers.get(active.id);\n            const newDroppable = droppableContainers.get(closestId);\n            const newRect = newDroppable ? droppableRects.get(newDroppable.id) : null;\n            const newNode = newDroppable == null ? void 0 : newDroppable.node.current;\n            if (newNode && newRect && activeDroppable && newDroppable) {\n                const newScrollAncestors = (0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.getScrollableAncestors)(newNode);\n                const hasDifferentScrollAncestors = newScrollAncestors.some((element, index)=>scrollableAncestors[index] !== element);\n                const hasSameContainer = isSameContainer(activeDroppable, newDroppable);\n                const isAfterActive = isAfter(activeDroppable, newDroppable);\n                const offset = hasDifferentScrollAncestors || !hasSameContainer ? {\n                    x: 0,\n                    y: 0\n                } : {\n                    x: isAfterActive ? collisionRect.width - newRect.width : 0,\n                    y: isAfterActive ? collisionRect.height - newRect.height : 0\n                };\n                const rectCoordinates = {\n                    x: newRect.left,\n                    y: newRect.top\n                };\n                const newCoordinates = offset.x && offset.y ? rectCoordinates : (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.subtract)(rectCoordinates, offset);\n                return newCoordinates;\n            }\n        }\n    }\n    return undefined;\n};\nfunction isSameContainer(a, b) {\n    if (!hasSortableData(a) || !hasSortableData(b)) {\n        return false;\n    }\n    return a.data.current.sortable.containerId === b.data.current.sortable.containerId;\n}\nfunction isAfter(a, b) {\n    if (!hasSortableData(a) || !hasSortableData(b)) {\n        return false;\n    }\n    if (!isSameContainer(a, b)) {\n        return false;\n    }\n    return a.data.current.sortable.index < b.data.current.sortable.index;\n}\n //# sourceMappingURL=sortable.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BkbmQta2l0L3NvcnRhYmxlL2Rpc3Qvc29ydGFibGUuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ0Y7QUFDa0Y7QUFDckM7QUFFN0g7O0NBRUMsR0FDRCxTQUFTb0IsVUFBVUMsS0FBSyxFQUFFQyxJQUFJLEVBQUVDLEVBQUU7SUFDaEMsTUFBTUMsV0FBV0gsTUFBTUksS0FBSztJQUM1QkQsU0FBU0UsTUFBTSxDQUFDSCxLQUFLLElBQUlDLFNBQVNHLE1BQU0sR0FBR0osS0FBS0EsSUFBSSxHQUFHQyxTQUFTRSxNQUFNLENBQUNKLE1BQU0sRUFBRSxDQUFDLEVBQUU7SUFDbEYsT0FBT0U7QUFDVDtBQUVBOztDQUVDLEdBQ0QsU0FBU0ksVUFBVVAsS0FBSyxFQUFFQyxJQUFJLEVBQUVDLEVBQUU7SUFDaEMsTUFBTUMsV0FBV0gsTUFBTUksS0FBSztJQUM1QkQsUUFBUSxDQUFDRixLQUFLLEdBQUdELEtBQUssQ0FBQ0UsR0FBRztJQUMxQkMsUUFBUSxDQUFDRCxHQUFHLEdBQUdGLEtBQUssQ0FBQ0MsS0FBSztJQUMxQixPQUFPRTtBQUNUO0FBRUEsU0FBU0ssZUFBZUMsS0FBSyxFQUFFQyxLQUFLO0lBQ2xDLE9BQU9ELE1BQU1FLE1BQU0sQ0FBQyxDQUFDQyxhQUFhQyxJQUFJQztRQUNwQyxNQUFNQyxPQUFPTCxNQUFNTSxHQUFHLENBQUNIO1FBRXZCLElBQUlFLE1BQU07WUFDUkgsV0FBVyxDQUFDRSxNQUFNLEdBQUdDO1FBQ3ZCO1FBRUEsT0FBT0g7SUFDVCxHQUFHSyxNQUFNUixNQUFNSCxNQUFNO0FBQ3ZCO0FBRUEsU0FBU1ksYUFBYUosS0FBSztJQUN6QixPQUFPQSxVQUFVLFFBQVFBLFNBQVM7QUFDcEM7QUFFQSxTQUFTSyxXQUFXQyxDQUFDLEVBQUVDLENBQUM7SUFDdEIsSUFBSUQsTUFBTUMsR0FBRztRQUNYLE9BQU87SUFDVDtJQUVBLElBQUlELEVBQUVkLE1BQU0sS0FBS2Us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TyxDQUFDNkMsUUFBUSxDQUFDbEUsV0FBVztBQUNwRjtBQUVBLFNBQVM0SCxRQUFRdEssQ0FBQyxFQUFFQyxDQUFDO0lBQ25CLElBQUksQ0FBQ29JLGdCQUFnQnJJLE1BQU0sQ0FBQ3FJLGdCQUFnQnBJLElBQUk7UUFDOUMsT0FBTztJQUNUO0lBRUEsSUFBSSxDQUFDbUssZ0JBQWdCcEssR0FBR0MsSUFBSTtRQUMxQixPQUFPO0lBQ1Q7SUFFQSxPQUFPRCxFQUFFb0csSUFBSSxDQUFDckMsT0FBTyxDQUFDNkMsUUFBUSxDQUFDbEgsS0FBSyxHQUFHTyxFQUFFbUcsSUFBSSxDQUFDckMsT0FBTyxDQUFDNkMsUUFBUSxDQUFDbEgsS0FBSztBQUN0RTtBQUV1USxDQUN2USx3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0BkbmQta2l0L3NvcnRhYmxlL2Rpc3Qvc29ydGFibGUuZXNtLmpzPzdhMjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZU1lbW8sIHVzZVJlZiwgdXNlRWZmZWN0LCB1c2VTdGF0ZSwgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZURuZENvbnRleHQsIGdldENsaWVudFJlY3QsIHVzZURyb3BwYWJsZSwgdXNlRHJhZ2dhYmxlLCBjbG9zZXN0Q29ybmVycywgZ2V0Rmlyc3RDb2xsaXNpb24sIGdldFNjcm9sbGFibGVBbmNlc3RvcnMsIEtleWJvYXJkQ29kZSB9IGZyb20gJ0BkbmQta2l0L2NvcmUnO1xuaW1wb3J0IHsgdXNlVW5pcXVlSWQsIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QsIENTUywgdXNlQ29tYmluZWRSZWZzLCBpc0tleWJvYXJkRXZlbnQsIHN1YnRyYWN0IH0gZnJvbSAnQGRuZC1raXQvdXRpbGl0aWVzJztcblxuLyoqXHJcbiAqIE1vdmUgYW4gYXJyYXkgaXRlbSB0byBhIGRpZmZlcmVudCBwb3NpdGlvbi4gUmV0dXJucyBhIG5ldyBhcnJheSB3aXRoIHRoZSBpdGVtIG1vdmVkIHRvIHRoZSBuZXcgcG9zaXRpb24uXHJcbiAqL1xuZnVuY3Rpb24gYXJyYXlNb3ZlKGFycmF5LCBmcm9tLCB0bykge1xuICBjb25zdCBuZXdBcnJheSA9IGFycmF5LnNsaWNlKCk7XG4gIG5ld0FycmF5LnNwbGljZSh0byA8IDAgPyBuZXdBcnJheS5sZW5ndGggKyB0byA6IHRvLCAwLCBuZXdBcnJheS5zcGxpY2UoZnJvbSwgMSlbMF0pO1xuICByZXR1cm4gbmV3QXJyYXk7XG59XG5cbi8qKlxyXG4gKiBTd2FwIGFuIGFycmF5IGl0ZW0gdG8gYSBkaWZmZXJlbnQgcG9zaXRpb24uIFJldHVybnMgYSBuZXcgYXJyYXkgd2l0aCB0aGUgaXRlbSBzd2FwcGVkIHRvIHRoZSBuZXcgcG9zaXRpb24uXHJcbiAqL1xuZnVuY3Rpb24gYXJyYXlTd2FwKGFycmF5LCBmcm9tLCB0bykge1xuICBjb25zdCBuZXdBcnJheSA9IGFycmF5LnNsaWNlKCk7XG4gIG5ld0FycmF5W2Zyb21dID0gYXJyYXlbdG9dO1xuICBuZXdBcnJheVt0b10gPSBhcnJheVtmcm9tXTtcbiAgcmV0dXJuIG5ld0FycmF5O1xufVxuXG5mdW5jdGlvbiBnZXRTb3J0ZWRSZWN0cyhpdGVtcywgcmVjdHMpIHtcbiAgcmV0dXJuIGl0ZW1zLnJlZHVjZSgoYWNjdW11bGF0b3IsIGlkLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHJlY3QgPSByZWN0cy5nZXQoaWQpO1xuXG4gICAgaWYgKHJlY3QpIHtcbiAgICAgIGFjY3VtdWxhdG9yW2luZGV4XSA9IHJlY3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9LCBBcnJheShpdGVtcy5sZW5ndGgpKTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZEluZGV4KGluZGV4KSB7XG4gIHJldHVybiBpbmRleCAhPT0gbnVsbCAmJiBpbmRleCA+PSAwO1xufVxuXG5mdW5jdGlvbiBpdGVtc0VxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVEaXNhYmxlZChkaXNhYmxlZCkge1xuICBpZiAodHlwZW9mIGRpc2FibGVkID09PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZHJhZ2dhYmxlOiBkaXNhYmxlZCxcbiAgICAgIGRyb3BwYWJsZTogZGlzYWJsZWRcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGRpc2FibGVkO1xufVxuXG4vLyBUby1kbzogV2Ugc2hvdWxkIGJlIGNhbGN1bGF0aW5nIHNjYWxlIHRyYW5zZm9ybWF0aW9uXG5jb25zdCBkZWZhdWx0U2NhbGUgPSB7XG4gIHNjYWxlWDogMSxcbiAgc2NhbGVZOiAxXG59O1xuY29uc3QgaG9yaXpvbnRhbExpc3RTb3J0aW5nU3RyYXRlZ3kgPSBfcmVmID0+IHtcbiAgdmFyIF9yZWN0cyRhY3RpdmVJbmRleDtcblxuICBsZXQge1xuICAgIHJlY3RzLFxuICAgIGFjdGl2ZU5vZGVSZWN0OiBmYWxsYmFja0FjdGl2ZVJlY3QsXG4gICAgYWN0aXZlSW5kZXgsXG4gICAgb3ZlckluZGV4LFxuICAgIGluZGV4XG4gIH0gPSBfcmVmO1xuICBjb25zdCBhY3RpdmVOb2RlUmVjdCA9IChfcmVjdHMkYWN0aXZlSW5kZXggPSByZWN0c1thY3RpdmVJbmRleF0pICE9IG51bGwgPyBfcmVjdHMkYWN0aXZlSW5kZXggOiBmYWxsYmFja0FjdGl2ZVJlY3Q7XG5cbiAgaWYgKCFhY3RpdmVOb2RlUmVjdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgaXRlbUdhcCA9IGdldEl0ZW1HYXAocmVjdHMsIGluZGV4LCBhY3RpdmVJbmRleCk7XG5cbiAgaWYgKGluZGV4ID09PSBhY3RpdmVJbmRleCkge1xuICAgIGNvbnN0IG5ld0luZGV4UmVjdCA9IHJlY3RzW292ZXJJbmRleF07XG5cbiAgICBpZiAoIW5ld0luZGV4UmVjdCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGFjdGl2ZUluZGV4IDwgb3ZlckluZGV4ID8gbmV3SW5kZXhSZWN0LmxlZnQgKyBuZXdJbmRleFJlY3Qud2lkdGggLSAoYWN0aXZlTm9kZVJlY3QubGVmdCArIGFjdGl2ZU5vZGVSZWN0LndpZHRoKSA6IG5ld0luZGV4UmVjdC5sZWZ0IC0gYWN0aXZlTm9kZVJlY3QubGVmdCxcbiAgICAgIHk6IDAsXG4gICAgICAuLi5kZWZhdWx0U2NhbGVcbiAgICB9O1xuICB9XG5cbiAgaWYgKGluZGV4ID4gYWN0aXZlSW5kZXggJiYgaW5kZXggPD0gb3ZlckluZGV4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IC1hY3RpdmVOb2RlUmVjdC53aWR0aCAtIGl0ZW1HYXAsXG4gICAgICB5OiAwLFxuICAgICAgLi4uZGVmYXVsdFNjYWxlXG4gICAgfTtcbiAgfVxuXG4gIGlmIChpbmRleCA8IGFjdGl2ZUluZGV4ICYmIGluZGV4ID49IG92ZXJJbmRleCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBhY3RpdmVOb2RlUmVjdC53aWR0aCArIGl0ZW1HYXAsXG4gICAgICB5OiAwLFxuICAgICAgLi4uZGVmYXVsdFNjYWxlXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIC4uLmRlZmF1bHRTY2FsZVxuICB9O1xufTtcblxuZnVuY3Rpb24gZ2V0SXRlbUdhcChyZWN0cywgaW5kZXgsIGFjdGl2ZUluZGV4KSB7XG4gIGNvbnN0IGN1cnJlbnRSZWN0ID0gcmVjdHNbaW5kZXhdO1xuICBjb25zdCBwcmV2aW91c1JlY3QgPSByZWN0c1tpbmRleCAtIDFdO1xuICBjb25zdCBuZXh0UmVjdCA9IHJlY3RzW2luZGV4ICsgMV07XG5cbiAgaWYgKCFjdXJyZW50UmVjdCB8fCAhcHJldmlvdXNSZWN0ICYmICFuZXh0UmVjdCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKGFjdGl2ZUluZGV4IDwgaW5kZXgpIHtcbiAgICByZXR1cm4gcHJldmlvdXNSZWN0ID8gY3VycmVudFJlY3QubGVmdCAtIChwcmV2aW91c1JlY3QubGVmdCArIHByZXZpb3VzUmVjdC53aWR0aCkgOiBuZXh0UmVjdC5sZWZ0IC0gKGN1cnJlbnRSZWN0LmxlZnQgKyBjdXJyZW50UmVjdC53aWR0aCk7XG4gIH1cblxuICByZXR1cm4gbmV4dFJlY3QgPyBuZXh0UmVjdC5sZWZ0IC0gKGN1cnJlbnRSZWN0LmxlZnQgKyBjdXJyZW50UmVjdC53aWR0aCkgOiBjdXJyZW50UmVjdC5sZWZ0IC0gKHByZXZpb3VzUmVjdC5sZWZ0ICsgcHJldmlvdXNSZWN0LndpZHRoKTtcbn1cblxuY29uc3QgcmVjdFNvcnRpbmdTdHJhdGVneSA9IF9yZWYgPT4ge1xuICBsZXQge1xuICAgIHJlY3RzLFxuICAgIGFjdGl2ZUluZGV4LFxuICAgIG92ZXJJbmRleCxcbiAgICBpbmRleFxuICB9ID0gX3JlZjtcbiAgY29uc3QgbmV3UmVjdHMgPSBhcnJheU1vdmUocmVjdHMsIG92ZXJJbmRleCwgYWN0aXZlSW5kZXgpO1xuICBjb25zdCBvbGRSZWN0ID0gcmVjdHNbaW5kZXhdO1xuICBjb25zdCBuZXdSZWN0ID0gbmV3UmVjdHNbaW5kZXhdO1xuXG4gIGlmICghbmV3UmVjdCB8fCAhb2xkUmVjdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBuZXdSZWN0LmxlZnQgLSBvbGRSZWN0LmxlZnQsXG4gICAgeTogbmV3UmVjdC50b3AgLSBvbGRSZWN0LnRvcCxcbiAgICBzY2FsZVg6IG5ld1JlY3Qud2lkdGggLyBvbGRSZWN0LndpZHRoLFxuICAgIHNjYWxlWTogbmV3UmVjdC5oZWlnaHQgLyBvbGRSZWN0LmhlaWdodFxuICB9O1xufTtcblxuY29uc3QgcmVjdFN3YXBwaW5nU3RyYXRlZ3kgPSBfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBhY3RpdmVJbmRleCxcbiAgICBpbmRleCxcbiAgICByZWN0cyxcbiAgICBvdmVySW5kZXhcbiAgfSA9IF9yZWY7XG4gIGxldCBvbGRSZWN0O1xuICBsZXQgbmV3UmVjdDtcblxuICBpZiAoaW5kZXggPT09IGFjdGl2ZUluZGV4KSB7XG4gICAgb2xkUmVjdCA9IHJlY3RzW2luZGV4XTtcbiAgICBuZXdSZWN0ID0gcmVjdHNbb3ZlckluZGV4XTtcbiAgfVxuXG4gIGlmIChpbmRleCA9PT0gb3ZlckluZGV4KSB7XG4gICAgb2xkUmVjdCA9IHJlY3RzW2luZGV4XTtcbiAgICBuZXdSZWN0ID0gcmVjdHNbYWN0aXZlSW5kZXhdO1xuICB9XG5cbiAgaWYgKCFuZXdSZWN0IHx8ICFvbGRSZWN0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IG5ld1JlY3QubGVmdCAtIG9sZFJlY3QubGVmdCxcbiAgICB5OiBuZXdSZWN0LnRvcCAtIG9sZFJlY3QudG9wLFxuICAgIHNjYWxlWDogbmV3UmVjdC53aWR0aCAvIG9sZFJlY3Qud2lkdGgsXG4gICAgc2NhbGVZOiBuZXdSZWN0LmhlaWdodCAvIG9sZFJlY3QuaGVpZ2h0XG4gIH07XG59O1xuXG4vLyBUby1kbzogV2Ugc2hvdWxkIGJlIGNhbGN1bGF0aW5nIHNjYWxlIHRyYW5zZm9ybWF0aW9uXG5jb25zdCBkZWZhdWx0U2NhbGUkMSA9IHtcbiAgc2NhbGVYOiAxLFxuICBzY2FsZVk6IDFcbn07XG5jb25zdCB2ZXJ0aWNhbExpc3RTb3J0aW5nU3RyYXRlZ3kgPSBfcmVmID0+IHtcbiAgdmFyIF9yZWN0cyRhY3RpdmVJbmRleDtcblxuICBsZXQge1xuICAgIGFjdGl2ZUluZGV4LFxuICAgIGFjdGl2ZU5vZGVSZWN0OiBmYWxsYmFja0FjdGl2ZVJlY3QsXG4gICAgaW5kZXgsXG4gICAgcmVjdHMsXG4gICAgb3ZlckluZGV4XG4gIH0gPSBfcmVmO1xuICBjb25zdCBhY3RpdmVOb2RlUmVjdCA9IChfcmVjdHMkYWN0aXZlSW5kZXggPSByZWN0c1thY3RpdmVJbmRleF0pICE9IG51bGwgPyBfcmVjdHMkYWN0aXZlSW5kZXggOiBmYWxsYmFja0FjdGl2ZVJlY3Q7XG5cbiAgaWYgKCFhY3RpdmVOb2RlUmVjdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGluZGV4ID09PSBhY3RpdmVJbmRleCkge1xuICAgIGNvbnN0IG92ZXJJbmRleFJlY3QgPSByZWN0c1tvdmVySW5kZXhdO1xuXG4gICAgaWYgKCFvdmVySW5kZXhSZWN0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IGFjdGl2ZUluZGV4IDwgb3ZlckluZGV4ID8gb3ZlckluZGV4UmVjdC50b3AgKyBvdmVySW5kZXhSZWN0LmhlaWdodCAtIChhY3RpdmVOb2RlUmVjdC50b3AgKyBhY3RpdmVOb2RlUmVjdC5oZWlnaHQpIDogb3ZlckluZGV4UmVjdC50b3AgLSBhY3RpdmVOb2RlUmVjdC50b3AsXG4gICAgICAuLi5kZWZhdWx0U2NhbGUkMVxuICAgIH07XG4gIH1cblxuICBjb25zdCBpdGVtR2FwID0gZ2V0SXRlbUdhcCQxKHJlY3RzLCBpbmRleCwgYWN0aXZlSW5kZXgpO1xuXG4gIGlmIChpbmRleCA+IGFjdGl2ZUluZGV4ICYmIGluZGV4IDw9IG92ZXJJbmRleCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogLWFjdGl2ZU5vZGVSZWN0LmhlaWdodCAtIGl0ZW1HYXAsXG4gICAgICAuLi5kZWZhdWx0U2NhbGUkMVxuICAgIH07XG4gIH1cblxuICBpZiAoaW5kZXggPCBhY3RpdmVJbmRleCAmJiBpbmRleCA+PSBvdmVySW5kZXgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IGFjdGl2ZU5vZGVSZWN0LmhlaWdodCArIGl0ZW1HYXAsXG4gICAgICAuLi5kZWZhdWx0U2NhbGUkMVxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICAuLi5kZWZhdWx0U2NhbGUkMVxuICB9O1xufTtcblxuZnVuY3Rpb24gZ2V0SXRlbUdhcCQxKGNsaWVudFJlY3RzLCBpbmRleCwgYWN0aXZlSW5kZXgpIHtcbiAgY29uc3QgY3VycmVudFJlY3QgPSBjbGllbnRSZWN0c1tpbmRleF07XG4gIGNvbnN0IHByZXZpb3VzUmVjdCA9IGNsaWVudFJlY3RzW2luZGV4IC0gMV07XG4gIGNvbnN0IG5leHRSZWN0ID0gY2xpZW50UmVjdHNbaW5kZXggKyAxXTtcblxuICBpZiAoIWN1cnJlbnRSZWN0KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAoYWN0aXZlSW5kZXggPCBpbmRleCkge1xuICAgIHJldHVybiBwcmV2aW91c1JlY3QgPyBjdXJyZW50UmVjdC50b3AgLSAocHJldmlvdXNSZWN0LnRvcCArIHByZXZpb3VzUmVjdC5oZWlnaHQpIDogbmV4dFJlY3QgPyBuZXh0UmVjdC50b3AgLSAoY3VycmVudFJlY3QudG9wICsgY3VycmVudFJlY3QuaGVpZ2h0KSA6IDA7XG4gIH1cblxuICByZXR1cm4gbmV4dFJlY3QgPyBuZXh0UmVjdC50b3AgLSAoY3VycmVudFJlY3QudG9wICsgY3VycmVudFJlY3QuaGVpZ2h0KSA6IHByZXZpb3VzUmVjdCA/IGN1cnJlbnRSZWN0LnRvcCAtIChwcmV2aW91c1JlY3QudG9wICsgcHJldmlvdXNSZWN0LmhlaWdodCkgOiAwO1xufVxuXG5jb25zdCBJRF9QUkVGSVggPSAnU29ydGFibGUnO1xuY29uc3QgQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgYWN0aXZlSW5kZXg6IC0xLFxuICBjb250YWluZXJJZDogSURfUFJFRklYLFxuICBkaXNhYmxlVHJhbnNmb3JtczogZmFsc2UsXG4gIGl0ZW1zOiBbXSxcbiAgb3ZlckluZGV4OiAtMSxcbiAgdXNlRHJhZ092ZXJsYXk6IGZhbHNlLFxuICBzb3J0ZWRSZWN0czogW10sXG4gIHN0cmF0ZWd5OiByZWN0U29ydGluZ1N0cmF0ZWd5LFxuICBkaXNhYmxlZDoge1xuICAgIGRyYWdnYWJsZTogZmFsc2UsXG4gICAgZHJvcHBhYmxlOiBmYWxzZVxuICB9XG59KTtcbmZ1bmN0aW9uIFNvcnRhYmxlQ29udGV4dChfcmVmKSB7XG4gIGxldCB7XG4gICAgY2hpbGRyZW4sXG4gICAgaWQsXG4gICAgaXRlbXM6IHVzZXJEZWZpbmVkSXRlbXMsXG4gICAgc3RyYXRlZ3kgPSByZWN0U29ydGluZ1N0cmF0ZWd5LFxuICAgIGRpc2FibGVkOiBkaXNhYmxlZFByb3AgPSBmYWxzZVxuICB9ID0gX3JlZjtcbiAgY29uc3Qge1xuICAgIGFjdGl2ZSxcbiAgICBkcmFnT3ZlcmxheSxcbiAgICBkcm9wcGFibGVSZWN0cyxcbiAgICBvdmVyLFxuICAgIG1lYXN1cmVEcm9wcGFibGVDb250YWluZXJzXG4gIH0gPSB1c2VEbmRDb250ZXh0KCk7XG4gIGNvbnN0IGNvbnRhaW5lcklkID0gdXNlVW5pcXVlSWQoSURfUFJFRklYLCBpZCk7XG4gIGNvbnN0IHVzZURyYWdPdmVybGF5ID0gQm9vbGVhbihkcmFnT3ZlcmxheS5yZWN0ICE9PSBudWxsKTtcbiAgY29uc3QgaXRlbXMgPSB1c2VNZW1vKCgpID0+IHVzZXJEZWZpbmVkSXRlbXMubWFwKGl0ZW0gPT4gdHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnICYmICdpZCcgaW4gaXRlbSA/IGl0ZW0uaWQgOiBpdGVtKSwgW3VzZXJEZWZpbmVkSXRlbXNdKTtcbiAgY29uc3QgaXNEcmFnZ2luZyA9IGFjdGl2ZSAhPSBudWxsO1xuICBjb25zdCBhY3RpdmVJbmRleCA9IGFjdGl2ZSA/IGl0ZW1zLmluZGV4T2YoYWN0aXZlLmlkKSA6IC0xO1xuICBjb25zdCBvdmVySW5kZXggPSBvdmVyID8gaXRlbXMuaW5kZXhPZihvdmVyLmlkKSA6IC0xO1xuICBjb25zdCBwcmV2aW91c0l0ZW1zUmVmID0gdXNlUmVmKGl0ZW1zKTtcbiAgY29uc3QgaXRlbXNIYXZlQ2hhbmdlZCA9ICFpdGVtc0VxdWFsKGl0ZW1zLCBwcmV2aW91c0l0ZW1zUmVmLmN1cnJlbnQpO1xuICBjb25zdCBkaXNhYmxlVHJhbnNmb3JtcyA9IG92ZXJJbmRleCAhPT0gLTEgJiYgYWN0aXZlSW5kZXggPT09IC0xIHx8IGl0ZW1zSGF2ZUNoYW5nZWQ7XG4gIGNvbnN0IGRpc2FibGVkID0gbm9ybWFsaXplRGlzYWJsZWQoZGlzYWJsZWRQcm9wKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGl0ZW1zSGF2ZUNoYW5nZWQgJiYgaXNEcmFnZ2luZykge1xuICAgICAgbWVhc3VyZURyb3BwYWJsZUNvbnRhaW5lcnMoaXRlbXMpO1xuICAgIH1cbiAgfSwgW2l0ZW1zSGF2ZUNoYW5nZWQsIGl0ZW1zLCBpc0RyYWdnaW5nLCBtZWFzdXJlRHJvcHBhYmxlQ29udGFpbmVyc10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHByZXZpb3VzSXRlbXNSZWYuY3VycmVudCA9IGl0ZW1zO1xuICB9LCBbaXRlbXNdKTtcbiAgY29uc3QgY29udGV4dFZhbHVlID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGFjdGl2ZUluZGV4LFxuICAgIGNvbnRhaW5lcklkLFxuICAgIGRpc2FibGVkLFxuICAgIGRpc2FibGVUcmFuc2Zvcm1zLFxuICAgIGl0ZW1zLFxuICAgIG92ZXJJbmRleCxcbiAgICB1c2VEcmFnT3ZlcmxheSxcbiAgICBzb3J0ZWRSZWN0czogZ2V0U29ydGVkUmVjdHMoaXRlbXMsIGRyb3BwYWJsZVJlY3RzKSxcbiAgICBzdHJhdGVneVxuICB9KSwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBbYWN0aXZlSW5kZXgsIGNvbnRhaW5lcklkLCBkaXNhYmxlZC5kcmFnZ2FibGUsIGRpc2FibGVkLmRyb3BwYWJsZSwgZGlzYWJsZVRyYW5zZm9ybXMsIGl0ZW1zLCBvdmVySW5kZXgsIGRyb3BwYWJsZVJlY3RzLCB1c2VEcmFnT3ZlcmxheSwgc3RyYXRlZ3ldKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0VmFsdWVcbiAgfSwgY2hpbGRyZW4pO1xufVxuXG5jb25zdCBkZWZhdWx0TmV3SW5kZXhHZXR0ZXIgPSBfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBpZCxcbiAgICBpdGVtcyxcbiAgICBhY3RpdmVJbmRleCxcbiAgICBvdmVySW5kZXhcbiAgfSA9IF9yZWY7XG4gIHJldHVybiBhcnJheU1vdmUoaXRlbXMsIGFjdGl2ZUluZGV4LCBvdmVySW5kZXgpLmluZGV4T2YoaWQpO1xufTtcbmNvbnN0IGRlZmF1bHRBbmltYXRlTGF5b3V0Q2hhbmdlcyA9IF9yZWYyID0+IHtcbiAgbGV0IHtcbiAgICBjb250YWluZXJJZCxcbiAgICBpc1NvcnRpbmcsXG4gICAgd2FzRHJhZ2dpbmcsXG4gICAgaW5kZXgsXG4gICAgaXRlbXMsXG4gICAgbmV3SW5kZXgsXG4gICAgcHJldmlvdXNJdGVtcyxcbiAgICBwcmV2aW91c0NvbnRhaW5lcklkLFxuICAgIHRyYW5zaXRpb25cbiAgfSA9IF9yZWYyO1xuXG4gIGlmICghdHJhbnNpdGlvbiB8fCAhd2FzRHJhZ2dpbmcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAocHJldmlvdXNJdGVtcyAhPT0gaXRlbXMgJiYgaW5kZXggPT09IG5ld0luZGV4KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGlzU29ydGluZykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIG5ld0luZGV4ICE9PSBpbmRleCAmJiBjb250YWluZXJJZCA9PT0gcHJldmlvdXNDb250YWluZXJJZDtcbn07XG5jb25zdCBkZWZhdWx0VHJhbnNpdGlvbiA9IHtcbiAgZHVyYXRpb246IDIwMCxcbiAgZWFzaW5nOiAnZWFzZSdcbn07XG5jb25zdCB0cmFuc2l0aW9uUHJvcGVydHkgPSAndHJhbnNmb3JtJztcbmNvbnN0IGRpc2FibGVkVHJhbnNpdGlvbiA9IC8qI19fUFVSRV9fKi9DU1MuVHJhbnNpdGlvbi50b1N0cmluZyh7XG4gIHByb3BlcnR5OiB0cmFuc2l0aW9uUHJvcGVydHksXG4gIGR1cmF0aW9uOiAwLFxuICBlYXNpbmc6ICdsaW5lYXInXG59KTtcbmNvbnN0IGRlZmF1bHRBdHRyaWJ1dGVzID0ge1xuICByb2xlRGVzY3JpcHRpb246ICdzb3J0YWJsZSdcbn07XG5cbi8qXHJcbiAqIFdoZW4gdGhlIGluZGV4IG9mIGFuIGl0ZW0gY2hhbmdlcyB3aGlsZSBzb3J0aW5nLFxyXG4gKiB3ZSBuZWVkIHRvIHRlbXBvcmFyaWx5IGRpc2FibGUgdGhlIHRyYW5zZm9ybXNcclxuICovXG5cbmZ1bmN0aW9uIHVzZURlcml2ZWRUcmFuc2Zvcm0oX3JlZikge1xuICBsZXQge1xuICAgIGRpc2FibGVkLFxuICAgIGluZGV4LFxuICAgIG5vZGUsXG4gICAgcmVjdFxuICB9ID0gX3JlZjtcbiAgY29uc3QgW2Rlcml2ZWRUcmFuc2Zvcm0sIHNldERlcml2ZWR0cmFuc2Zvcm1dID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IHByZXZpb3VzSW5kZXggPSB1c2VSZWYoaW5kZXgpO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWRpc2FibGVkICYmIGluZGV4ICE9PSBwcmV2aW91c0luZGV4LmN1cnJlbnQgJiYgbm9kZS5jdXJyZW50KSB7XG4gICAgICBjb25zdCBpbml0aWFsID0gcmVjdC5jdXJyZW50O1xuXG4gICAgICBpZiAoaW5pdGlhbCkge1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gZ2V0Q2xpZW50UmVjdChub2RlLmN1cnJlbnQsIHtcbiAgICAgICAgICBpZ25vcmVUcmFuc2Zvcm06IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGRlbHRhID0ge1xuICAgICAgICAgIHg6IGluaXRpYWwubGVmdCAtIGN1cnJlbnQubGVmdCxcbiAgICAgICAgICB5OiBpbml0aWFsLnRvcCAtIGN1cnJlbnQudG9wLFxuICAgICAgICAgIHNjYWxlWDogaW5pdGlhbC53aWR0aCAvIGN1cnJlbnQud2lkdGgsXG4gICAgICAgICAgc2NhbGVZOiBpbml0aWFsLmhlaWdodCAvIGN1cnJlbnQuaGVpZ2h0XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGRlbHRhLnggfHwgZGVsdGEueSkge1xuICAgICAgICAgIHNldERlcml2ZWR0cmFuc2Zvcm0oZGVsdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluZGV4ICE9PSBwcmV2aW91c0luZGV4LmN1cnJlbnQpIHtcbiAgICAgIHByZXZpb3VzSW5kZXguY3VycmVudCA9IGluZGV4O1xuICAgIH1cbiAgfSwgW2Rpc2FibGVkLCBpbmRleCwgbm9kZSwgcmVjdF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChkZXJpdmVkVHJhbnNmb3JtKSB7XG4gICAgICBzZXREZXJpdmVkdHJhbnNmb3JtKG51bGwpO1xuICAgIH1cbiAgfSwgW2Rlcml2ZWRUcmFuc2Zvcm1dKTtcbiAgcmV0dXJuIGRlcml2ZWRUcmFuc2Zvcm07XG59XG5cbmZ1bmN0aW9uIHVzZVNvcnRhYmxlKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBhbmltYXRlTGF5b3V0Q2hhbmdlcyA9IGRlZmF1bHRBbmltYXRlTGF5b3V0Q2hhbmdlcyxcbiAgICBhdHRyaWJ1dGVzOiB1c2VyRGVmaW5lZEF0dHJpYnV0ZXMsXG4gICAgZGlzYWJsZWQ6IGxvY2FsRGlzYWJsZWQsXG4gICAgZGF0YTogY3VzdG9tRGF0YSxcbiAgICBnZXROZXdJbmRleCA9IGRlZmF1bHROZXdJbmRleEdldHRlcixcbiAgICBpZCxcbiAgICBzdHJhdGVneTogbG9jYWxTdHJhdGVneSxcbiAgICByZXNpemVPYnNlcnZlckNvbmZpZyxcbiAgICB0cmFuc2l0aW9uID0gZGVmYXVsdFRyYW5zaXRpb25cbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHtcbiAgICBpdGVtcyxcbiAgICBjb250YWluZXJJZCxcbiAgICBhY3RpdmVJbmRleCxcbiAgICBkaXNhYmxlZDogZ2xvYmFsRGlzYWJsZWQsXG4gICAgZGlzYWJsZVRyYW5zZm9ybXMsXG4gICAgc29ydGVkUmVjdHMsXG4gICAgb3ZlckluZGV4LFxuICAgIHVzZURyYWdPdmVybGF5LFxuICAgIHN0cmF0ZWd5OiBnbG9iYWxTdHJhdGVneVxuICB9ID0gdXNlQ29udGV4dChDb250ZXh0KTtcbiAgY29uc3QgZGlzYWJsZWQgPSBub3JtYWxpemVMb2NhbERpc2FibGVkKGxvY2FsRGlzYWJsZWQsIGdsb2JhbERpc2FibGVkKTtcbiAgY29uc3QgaW5kZXggPSBpdGVtcy5pbmRleE9mKGlkKTtcbiAgY29uc3QgZGF0YSA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBzb3J0YWJsZToge1xuICAgICAgY29udGFpbmVySWQsXG4gICAgICBpbmRleCxcbiAgICAgIGl0ZW1zXG4gICAgfSxcbiAgICAuLi5jdXN0b21EYXRhXG4gIH0pLCBbY29udGFpbmVySWQsIGN1c3RvbURhdGEsIGluZGV4LCBpdGVtc10pO1xuICBjb25zdCBpdGVtc0FmdGVyQ3VycmVudFNvcnRhYmxlID0gdXNlTWVtbygoKSA9PiBpdGVtcy5zbGljZShpdGVtcy5pbmRleE9mKGlkKSksIFtpdGVtcywgaWRdKTtcbiAgY29uc3Qge1xuICAgIHJlY3QsXG4gICAgbm9kZSxcbiAgICBpc092ZXIsXG4gICAgc2V0Tm9kZVJlZjogc2V0RHJvcHBhYmxlTm9kZVJlZlxuICB9ID0gdXNlRHJvcHBhYmxlKHtcbiAgICBpZCxcbiAgICBkYXRhLFxuICAgIGRpc2FibGVkOiBkaXNhYmxlZC5kcm9wcGFibGUsXG4gICAgcmVzaXplT2JzZXJ2ZXJDb25maWc6IHtcbiAgICAgIHVwZGF0ZU1lYXN1cmVtZW50c0ZvcjogaXRlbXNBZnRlckN1cnJlbnRTb3J0YWJsZSxcbiAgICAgIC4uLnJlc2l6ZU9ic2VydmVyQ29uZmlnXG4gICAgfVxuICB9KTtcbiAgY29uc3Qge1xuICAgIGFjdGl2ZSxcbiAgICBhY3RpdmF0b3JFdmVudCxcbiAgICBhY3RpdmVOb2RlUmVjdCxcbiAgICBhdHRyaWJ1dGVzLFxuICAgIHNldE5vZGVSZWY6IHNldERyYWdnYWJsZU5vZGVSZWYsXG4gICAgbGlzdGVuZXJzLFxuICAgIGlzRHJhZ2dpbmcsXG4gICAgb3ZlcixcbiAgICBzZXRBY3RpdmF0b3JOb2RlUmVmLFxuICAgIHRyYW5zZm9ybVxuICB9ID0gdXNlRHJhZ2dhYmxlKHtcbiAgICBpZCxcbiAgICBkYXRhLFxuICAgIGF0dHJpYnV0ZXM6IHsgLi4uZGVmYXVsdEF0dHJpYnV0ZXMsXG4gICAgICAuLi51c2VyRGVmaW5lZEF0dHJpYnV0ZXNcbiAgICB9LFxuICAgIGRpc2FibGVkOiBkaXNhYmxlZC5kcmFnZ2FibGVcbiAgfSk7XG4gIGNvbnN0IHNldE5vZGVSZWYgPSB1c2VDb21iaW5lZFJlZnMoc2V0RHJvcHBhYmxlTm9kZVJlZiwgc2V0RHJhZ2dhYmxlTm9kZVJlZik7XG4gIGNvbnN0IGlzU29ydGluZyA9IEJvb2xlYW4oYWN0aXZlKTtcbiAgY29uc3QgZGlzcGxhY2VJdGVtID0gaXNTb3J0aW5nICYmICFkaXNhYmxlVHJhbnNmb3JtcyAmJiBpc1ZhbGlkSW5kZXgoYWN0aXZlSW5kZXgpICYmIGlzVmFsaWRJbmRleChvdmVySW5kZXgpO1xuICBjb25zdCBzaG91bGREaXNwbGFjZURyYWdTb3VyY2UgPSAhdXNlRHJhZ092ZXJsYXkgJiYgaXNEcmFnZ2luZztcbiAgY29uc3QgZHJhZ1NvdXJjZURpc3BsYWNlbWVudCA9IHNob3VsZERpc3BsYWNlRHJhZ1NvdXJjZSAmJiBkaXNwbGFjZUl0ZW0gPyB0cmFuc2Zvcm0gOiBudWxsO1xuICBjb25zdCBzdHJhdGVneSA9IGxvY2FsU3RyYXRlZ3kgIT0gbnVsbCA/IGxvY2FsU3RyYXRlZ3kgOiBnbG9iYWxTdHJhdGVneTtcbiAgY29uc3QgZmluYWxUcmFuc2Zvcm0gPSBkaXNwbGFjZUl0ZW0gPyBkcmFnU291cmNlRGlzcGxhY2VtZW50ICE9IG51bGwgPyBkcmFnU291cmNlRGlzcGxhY2VtZW50IDogc3RyYXRlZ3koe1xuICAgIHJlY3RzOiBzb3J0ZWRSZWN0cyxcbiAgICBhY3RpdmVOb2RlUmVjdCxcbiAgICBhY3RpdmVJbmRleCxcbiAgICBvdmVySW5kZXgsXG4gICAgaW5kZXhcbiAgfSkgOiBudWxsO1xuICBjb25zdCBuZXdJbmRleCA9IGlzVmFsaWRJbmRleChhY3RpdmVJbmRleCkgJiYgaXNWYWxpZEluZGV4KG92ZXJJbmRleCkgPyBnZXROZXdJbmRleCh7XG4gICAgaWQsXG4gICAgaXRlbXMsXG4gICAgYWN0aXZlSW5kZXgsXG4gICAgb3ZlckluZGV4XG4gIH0pIDogaW5kZXg7XG4gIGNvbnN0IGFjdGl2ZUlkID0gYWN0aXZlID09IG51bGwgPyB2b2lkIDAgOiBhY3RpdmUuaWQ7XG4gIGNvbnN0IHByZXZpb3VzID0gdXNlUmVmKHtcbiAgICBhY3RpdmVJZCxcbiAgICBpdGVtcyxcbiAgICBuZXdJbmRleCxcbiAgICBjb250YWluZXJJZFxuICB9KTtcbiAgY29uc3QgaXRlbXNIYXZlQ2hhbmdlZCA9IGl0ZW1zICE9PSBwcmV2aW91cy5jdXJyZW50Lml0ZW1zO1xuICBjb25zdCBzaG91bGRBbmltYXRlTGF5b3V0Q2hhbmdlcyA9IGFuaW1hdGVMYXlvdXRDaGFuZ2VzKHtcbiAgICBhY3RpdmUsXG4gICAgY29udGFpbmVySWQsXG4gICAgaXNEcmFnZ2luZyxcbiAgICBpc1NvcnRpbmcsXG4gICAgaWQsXG4gICAgaW5kZXgsXG4gICAgaXRlbXMsXG4gICAgbmV3SW5kZXg6IHByZXZpb3VzLmN1cnJlbnQubmV3SW5kZXgsXG4gICAgcHJldmlvdXNJdGVtczogcHJldmlvdXMuY3VycmVudC5pdGVtcyxcbiAgICBwcmV2aW91c0NvbnRhaW5lcklkOiBwcmV2aW91cy5jdXJyZW50LmNvbnRhaW5lcklkLFxuICAgIHRyYW5zaXRpb24sXG4gICAgd2FzRHJhZ2dpbmc6IHByZXZpb3VzLmN1cnJlbnQuYWN0aXZlSWQgIT0gbnVsbFxuICB9KTtcbiAgY29uc3QgZGVyaXZlZFRyYW5zZm9ybSA9IHVzZURlcml2ZWRUcmFuc2Zvcm0oe1xuICAgIGRpc2FibGVkOiAhc2hvdWxkQW5pbWF0ZUxheW91dENoYW5nZXMsXG4gICAgaW5kZXgsXG4gICAgbm9kZSxcbiAgICByZWN0XG4gIH0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpc1NvcnRpbmcgJiYgcHJldmlvdXMuY3VycmVudC5uZXdJbmRleCAhPT0gbmV3SW5kZXgpIHtcbiAgICAgIHByZXZpb3VzLmN1cnJlbnQubmV3SW5kZXggPSBuZXdJbmRleDtcbiAgICB9XG5cbiAgICBpZiAoY29udGFpbmVySWQgIT09IHByZXZpb3VzLmN1cnJlbnQuY29udGFpbmVySWQpIHtcbiAgICAgIHByZXZpb3VzLmN1cnJlbnQuY29udGFpbmVySWQgPSBjb250YWluZXJJZDtcbiAgICB9XG5cbiAgICBpZiAoaXRlbXMgIT09IHByZXZpb3VzLmN1cnJlbnQuaXRlbXMpIHtcbiAgICAgIHByZXZpb3VzLmN1cnJlbnQuaXRlbXMgPSBpdGVtcztcbiAgICB9XG4gIH0sIFtpc1NvcnRpbmcsIG5ld0luZGV4LCBjb250YWluZXJJZCwgaXRlbXNdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYWN0aXZlSWQgPT09IHByZXZpb3VzLmN1cnJlbnQuYWN0aXZlSWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYWN0aXZlSWQgJiYgIXByZXZpb3VzLmN1cnJlbnQuYWN0aXZlSWQpIHtcbiAgICAgIHByZXZpb3VzLmN1cnJlbnQuYWN0aXZlSWQgPSBhY3RpdmVJZDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHByZXZpb3VzLmN1cnJlbnQuYWN0aXZlSWQgPSBhY3RpdmVJZDtcbiAgICB9LCA1MCk7XG4gICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICB9LCBbYWN0aXZlSWRdKTtcbiAgcmV0dXJuIHtcbiAgICBhY3RpdmUsXG4gICAgYWN0aXZlSW5kZXgsXG4gICAgYXR0cmlidXRlcyxcbiAgICBkYXRhLFxuICAgIHJlY3QsXG4gICAgaW5kZXgsXG4gICAgbmV3SW5kZXgsXG4gICAgaXRlbXMsXG4gICAgaXNPdmVyLFxuICAgIGlzU29ydGluZyxcbiAgICBpc0RyYWdnaW5nLFxuICAgIGxpc3RlbmVycyxcbiAgICBub2RlLFxuICAgIG92ZXJJbmRleCxcbiAgICBvdmVyLFxuICAgIHNldE5vZGVSZWYsXG4gICAgc2V0QWN0aXZhdG9yTm9kZVJlZixcbiAgICBzZXREcm9wcGFibGVOb2RlUmVmLFxuICAgIHNldERyYWdnYWJsZU5vZGVSZWYsXG4gICAgdHJhbnNmb3JtOiBkZXJpdmVkVHJhbnNmb3JtICE9IG51bGwgPyBkZXJpdmVkVHJhbnNmb3JtIDogZmluYWxUcmFuc2Zvcm0sXG4gICAgdHJhbnNpdGlvbjogZ2V0VHJhbnNpdGlvbigpXG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbigpIHtcbiAgICBpZiAoIC8vIFRlbXBvcmFyaWx5IGRpc2FibGUgdHJhbnNpdGlvbnMgZm9yIGEgc2luZ2xlIGZyYW1lIHRvIHNldCB1cCBkZXJpdmVkIHRyYW5zZm9ybXNcbiAgICBkZXJpdmVkVHJhbnNmb3JtIHx8IC8vIE9yIHRvIHByZXZlbnQgaXRlbXMganVtcGluZyB0byBiYWNrIHRvIHRoZWlyIFwibmV3XCIgcG9zaXRpb24gd2hlbiBpdGVtcyBjaGFuZ2VcbiAgICBpdGVtc0hhdmVDaGFuZ2VkICYmIHByZXZpb3VzLmN1cnJlbnQubmV3SW5kZXggPT09IGluZGV4KSB7XG4gICAgICByZXR1cm4gZGlzYWJsZWRUcmFuc2l0aW9uO1xuICAgIH1cblxuICAgIGlmIChzaG91bGREaXNwbGFjZURyYWdTb3VyY2UgJiYgIWlzS2V5Ym9hcmRFdmVudChhY3RpdmF0b3JFdmVudCkgfHwgIXRyYW5zaXRpb24pIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKGlzU29ydGluZyB8fCBzaG91bGRBbmltYXRlTGF5b3V0Q2hhbmdlcykge1xuICAgICAgcmV0dXJuIENTUy5UcmFuc2l0aW9uLnRvU3RyaW5nKHsgLi4udHJhbnNpdGlvbixcbiAgICAgICAgcHJvcGVydHk6IHRyYW5zaXRpb25Qcm9wZXJ0eVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVMb2NhbERpc2FibGVkKGxvY2FsRGlzYWJsZWQsIGdsb2JhbERpc2FibGVkKSB7XG4gIHZhciBfbG9jYWxEaXNhYmxlZCRkcmFnZ2EsIF9sb2NhbERpc2FibGVkJGRyb3BwYTtcblxuICBpZiAodHlwZW9mIGxvY2FsRGlzYWJsZWQgPT09ICdib29sZWFuJykge1xuICAgIHJldHVybiB7XG4gICAgICBkcmFnZ2FibGU6IGxvY2FsRGlzYWJsZWQsXG4gICAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgZHJvcHBhYmxlOiBmYWxzZVxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGRyYWdnYWJsZTogKF9sb2NhbERpc2FibGVkJGRyYWdnYSA9IGxvY2FsRGlzYWJsZWQgPT0gbnVsbCA/IHZvaWQgMCA6IGxvY2FsRGlzYWJsZWQuZHJhZ2dhYmxlKSAhPSBudWxsID8gX2xvY2FsRGlzYWJsZWQkZHJhZ2dhIDogZ2xvYmFsRGlzYWJsZWQuZHJhZ2dhYmxlLFxuICAgIGRyb3BwYWJsZTogKF9sb2NhbERpc2FibGVkJGRyb3BwYSA9IGxvY2FsRGlzYWJsZWQgPT0gbnVsbCA/IHZvaWQgMCA6IGxvY2FsRGlzYWJsZWQuZHJvcHBhYmxlKSAhPSBudWxsID8gX2xvY2FsRGlzYWJsZWQkZHJvcHBhIDogZ2xvYmFsRGlzYWJsZWQuZHJvcHBhYmxlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGhhc1NvcnRhYmxlRGF0YShlbnRyeSkge1xuICBpZiAoIWVudHJ5KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgZGF0YSA9IGVudHJ5LmRhdGEuY3VycmVudDtcblxuICBpZiAoZGF0YSAmJiAnc29ydGFibGUnIGluIGRhdGEgJiYgdHlwZW9mIGRhdGEuc29ydGFibGUgPT09ICdvYmplY3QnICYmICdjb250YWluZXJJZCcgaW4gZGF0YS5zb3J0YWJsZSAmJiAnaXRlbXMnIGluIGRhdGEuc29ydGFibGUgJiYgJ2luZGV4JyBpbiBkYXRhLnNvcnRhYmxlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmNvbnN0IGRpcmVjdGlvbnMgPSBbS2V5Ym9hcmRDb2RlLkRvd24sIEtleWJvYXJkQ29kZS5SaWdodCwgS2V5Ym9hcmRDb2RlLlVwLCBLZXlib2FyZENvZGUuTGVmdF07XG5jb25zdCBzb3J0YWJsZUtleWJvYXJkQ29vcmRpbmF0ZXMgPSAoZXZlbnQsIF9yZWYpID0+IHtcbiAgbGV0IHtcbiAgICBjb250ZXh0OiB7XG4gICAgICBhY3RpdmUsXG4gICAgICBjb2xsaXNpb25SZWN0LFxuICAgICAgZHJvcHBhYmxlUmVjdHMsXG4gICAgICBkcm9wcGFibGVDb250YWluZXJzLFxuICAgICAgb3ZlcixcbiAgICAgIHNjcm9sbGFibGVBbmNlc3RvcnNcbiAgICB9XG4gIH0gPSBfcmVmO1xuXG4gIGlmIChkaXJlY3Rpb25zLmluY2x1ZGVzKGV2ZW50LmNvZGUpKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIGlmICghYWN0aXZlIHx8ICFjb2xsaXNpb25SZWN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZmlsdGVyZWRDb250YWluZXJzID0gW107XG4gICAgZHJvcHBhYmxlQ29udGFpbmVycy5nZXRFbmFibGVkKCkuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgICBpZiAoIWVudHJ5IHx8IGVudHJ5ICE9IG51bGwgJiYgZW50cnkuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZWN0ID0gZHJvcHBhYmxlUmVjdHMuZ2V0KGVudHJ5LmlkKTtcblxuICAgICAgaWYgKCFyZWN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChldmVudC5jb2RlKSB7XG4gICAgICAgIGNhc2UgS2V5Ym9hcmRDb2RlLkRvd246XG4gICAgICAgICAgaWYgKGNvbGxpc2lvblJlY3QudG9wIDwgcmVjdC50b3ApIHtcbiAgICAgICAgICAgIGZpbHRlcmVkQ29udGFpbmVycy5wdXNoKGVudHJ5KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEtleWJvYXJkQ29kZS5VcDpcbiAgICAgICAgICBpZiAoY29sbGlzaW9uUmVjdC50b3AgPiByZWN0LnRvcCkge1xuICAgICAgICAgICAgZmlsdGVyZWRDb250YWluZXJzLnB1c2goZW50cnkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgS2V5Ym9hcmRDb2RlLkxlZnQ6XG4gICAgICAgICAgaWYgKGNvbGxpc2lvblJlY3QubGVmdCA+IHJlY3QubGVmdCkge1xuICAgICAgICAgICAgZmlsdGVyZWRDb250YWluZXJzLnB1c2goZW50cnkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgS2V5Ym9hcmRDb2RlLlJpZ2h0OlxuICAgICAgICAgIGlmIChjb2xsaXNpb25SZWN0LmxlZnQgPCByZWN0LmxlZnQpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkQ29udGFpbmVycy5wdXNoKGVudHJ5KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBjb2xsaXNpb25zID0gY2xvc2VzdENvcm5lcnMoe1xuICAgICAgYWN0aXZlLFxuICAgICAgY29sbGlzaW9uUmVjdDogY29sbGlzaW9uUmVjdCxcbiAgICAgIGRyb3BwYWJsZVJlY3RzLFxuICAgICAgZHJvcHBhYmxlQ29udGFpbmVyczogZmlsdGVyZWRDb250YWluZXJzLFxuICAgICAgcG9pbnRlckNvb3JkaW5hdGVzOiBudWxsXG4gICAgfSk7XG4gICAgbGV0IGNsb3Nlc3RJZCA9IGdldEZpcnN0Q29sbGlzaW9uKGNvbGxpc2lvbnMsICdpZCcpO1xuXG4gICAgaWYgKGNsb3Nlc3RJZCA9PT0gKG92ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IG92ZXIuaWQpICYmIGNvbGxpc2lvbnMubGVuZ3RoID4gMSkge1xuICAgICAgY2xvc2VzdElkID0gY29sbGlzaW9uc1sxXS5pZDtcbiAgICB9XG5cbiAgICBpZiAoY2xvc2VzdElkICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGFjdGl2ZURyb3BwYWJsZSA9IGRyb3BwYWJsZUNvbnRhaW5lcnMuZ2V0KGFjdGl2ZS5pZCk7XG4gICAgICBjb25zdCBuZXdEcm9wcGFibGUgPSBkcm9wcGFibGVDb250YWluZXJzLmdldChjbG9zZXN0SWQpO1xuICAgICAgY29uc3QgbmV3UmVjdCA9IG5ld0Ryb3BwYWJsZSA/IGRyb3BwYWJsZVJlY3RzLmdldChuZXdEcm9wcGFibGUuaWQpIDogbnVsbDtcbiAgICAgIGNvbnN0IG5ld05vZGUgPSBuZXdEcm9wcGFibGUgPT0gbnVsbCA/IHZvaWQgMCA6IG5ld0Ryb3BwYWJsZS5ub2RlLmN1cnJlbnQ7XG5cbiAgICAgIGlmIChuZXdOb2RlICYmIG5ld1JlY3QgJiYgYWN0aXZlRHJvcHBhYmxlICYmIG5ld0Ryb3BwYWJsZSkge1xuICAgICAgICBjb25zdCBuZXdTY3JvbGxBbmNlc3RvcnMgPSBnZXRTY3JvbGxhYmxlQW5jZXN0b3JzKG5ld05vZGUpO1xuICAgICAgICBjb25zdCBoYXNEaWZmZXJlbnRTY3JvbGxBbmNlc3RvcnMgPSBuZXdTY3JvbGxBbmNlc3RvcnMuc29tZSgoZWxlbWVudCwgaW5kZXgpID0+IHNjcm9sbGFibGVBbmNlc3RvcnNbaW5kZXhdICE9PSBlbGVtZW50KTtcbiAgICAgICAgY29uc3QgaGFzU2FtZUNvbnRhaW5lciA9IGlzU2FtZUNvbnRhaW5lcihhY3RpdmVEcm9wcGFibGUsIG5ld0Ryb3BwYWJsZSk7XG4gICAgICAgIGNvbnN0IGlzQWZ0ZXJBY3RpdmUgPSBpc0FmdGVyKGFjdGl2ZURyb3BwYWJsZSwgbmV3RHJvcHBhYmxlKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaGFzRGlmZmVyZW50U2Nyb2xsQW5jZXN0b3JzIHx8ICFoYXNTYW1lQ29udGFpbmVyID8ge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9IDoge1xuICAgICAgICAgIHg6IGlzQWZ0ZXJBY3RpdmUgPyBjb2xsaXNpb25SZWN0LndpZHRoIC0gbmV3UmVjdC53aWR0aCA6IDAsXG4gICAgICAgICAgeTogaXNBZnRlckFjdGl2ZSA/IGNvbGxpc2lvblJlY3QuaGVpZ2h0IC0gbmV3UmVjdC5oZWlnaHQgOiAwXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlY3RDb29yZGluYXRlcyA9IHtcbiAgICAgICAgICB4OiBuZXdSZWN0LmxlZnQsXG4gICAgICAgICAgeTogbmV3UmVjdC50b3BcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbmV3Q29vcmRpbmF0ZXMgPSBvZmZzZXQueCAmJiBvZmZzZXQueSA/IHJlY3RDb29yZGluYXRlcyA6IHN1YnRyYWN0KHJlY3RDb29yZGluYXRlcywgb2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIG5ld0Nvb3JkaW5hdGVzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG5mdW5jdGlvbiBpc1NhbWVDb250YWluZXIoYSwgYikge1xuICBpZiAoIWhhc1NvcnRhYmxlRGF0YShhKSB8fCAhaGFzU29ydGFibGVEYXRhKGIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGEuZGF0YS5jdXJyZW50LnNvcnRhYmxlLmNvbnRhaW5lcklkID09PSBiLmRhdGEuY3VycmVudC5zb3J0YWJsZS5jb250YWluZXJJZDtcbn1cblxuZnVuY3Rpb24gaXNBZnRlcihhLCBiKSB7XG4gIGlmICghaGFzU29ydGFibGVEYXRhKGEpIHx8ICFoYXNTb3J0YWJsZURhdGEoYikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIWlzU2FtZUNvbnRhaW5lcihhLCBiKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBhLmRhdGEuY3VycmVudC5zb3J0YWJsZS5pbmRleCA8IGIuZGF0YS5jdXJyZW50LnNvcnRhYmxlLmluZGV4O1xufVxuXG5leHBvcnQgeyBTb3J0YWJsZUNvbnRleHQsIGFycmF5TW92ZSwgYXJyYXlTd2FwLCBkZWZhdWx0QW5pbWF0ZUxheW91dENoYW5nZXMsIGRlZmF1bHROZXdJbmRleEdldHRlciwgaGFzU29ydGFibGVEYXRhLCBob3Jpem9udGFsTGlzdFNvcnRpbmdTdHJhdGVneSwgcmVjdFNvcnRpbmdTdHJhdGVneSwgcmVjdFN3YXBwaW5nU3RyYXRlZ3ksIHNvcnRhYmxlS2V5Ym9hcmRDb29yZGluYXRlcywgdXNlU29ydGFibGUsIHZlcnRpY2FsTGlzdFNvcnRpbmdTdHJhdGVneSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c29ydGFibGUuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlTWVtbyIsInVzZVJlZiIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwidXNlQ29udGV4dCIsInVzZURuZENvbnRleHQiLCJnZXRDbGllbnRSZWN0IiwidXNlRHJvcHBhYmxlIiwidXNlRHJhZ2dhYmxlIiwiY2xvc2VzdENvcm5lcnMiLCJnZXRGaXJzdENvbGxpc2lvbiIsImdldFNjcm9sbGFibGVBbmNlc3RvcnMiLCJLZXlib2FyZENvZGUiLCJ1c2VVbmlxdWVJZCIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJDU1MiLCJ1c2VDb21iaW5lZFJlZnMiLCJpc0tleWJvYXJkRXZlbnQiLCJzdWJ0cmFjdCIsImFycmF5TW92ZSIsImFycmF5IiwiZnJvbSIsInRvIiwibmV3QXJyYXkiLCJzbGljZSIsInNwbGljZSIsImxlbmd0aCIsImFycmF5U3dhcCIsImdldFNvcnRlZFJlY3RzIiwiaXRlbXMiLCJyZWN0cyIsInJlZHVjZSIsImFjY3VtdWxhdG9yIiwiaWQiLCJpbmRleCIsInJlY3QiLCJnZXQiLCJBcnJheSIsImlzVmFsaWRJbmRleCIsIml0ZW1zRXF1YWwiLCJhIiwiYiIsImkiLCJub3JtYWxpemVEaXNhYmxlZCIsImRpc2FibGVkIiwiZHJhZ2dhYmxlIiwiZHJvcHBhYmxlIiwiZGVmYXVsdFNjYWxlIiwic2NhbGVYIiwic2NhbGVZIiwiaG9yaXpvbnRhbExpc3RTb3J0aW5nU3RyYXRlZ3kiLCJfcmVmIiwiX3JlY3RzJGFjdGl2ZUluZGV4IiwiYWN0aXZlTm9kZVJlY3QiLCJmYWxsYmFja0FjdGl2ZVJlY3QiLCJhY3RpdmVJbmRleCIsIm92ZXJJbmRleCIsIml0ZW1HYXAiLCJnZXRJdGVtR2FwIiwibmV3SW5kZXhSZWN0IiwieCIsImxlZnQiLCJ3aWR0aCIsInkiLCJjdXJyZW50UmVjdCIsInByZXZpb3VzUmVjdCIsIm5leHRSZWN0IiwicmVjdFNvcnRpbmdTdHJhdGVneSIsIm5ld1JlY3RzIiwib2xkUmVjdCIsIm5ld1JlY3QiLCJ0b3AiLCJoZWlnaHQiLCJyZWN0U3dhcHBpbmdTdHJhdGVneSIsImRlZmF1bHRTY2FsZSQxIiwidmVydGljYWxMaXN0U29ydGluZ1N0cmF0ZWd5Iiwib3ZlckluZGV4UmVjdCIsImdldEl0ZW1HYXAkMSIsImNsaWVudFJlY3RzIiwiSURfUFJFRklYIiwiQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJjb250YWluZXJJZCIsImRpc2FibGVUcmFuc2Zvcm1zIiwidXNlRHJhZ092ZXJsYXkiLCJzb3J0ZWRSZWN0cyIsInN0cmF0ZWd5IiwiU29ydGFibGVDb250ZXh0IiwiY2hpbGRyZW4iLCJ1c2VyRGVmaW5lZEl0ZW1zIiwiZGlzYWJsZWRQcm9wIiwiYWN0aXZlIiwiZHJhZ092ZXJsYXkiLCJkcm9wcGFibGVSZWN0cyIsIm92ZXIiLCJtZWFzdXJlRHJvcHBhYmxlQ29udGFpbmVycyIsIkJvb2xlYW4iLCJtYXAiLCJpdGVtIiwiaXNEcmFnZ2luZyIsImluZGV4T2YiLCJwcmV2aW91c0l0ZW1zUmVmIiwiaXRlbXNIYXZlQ2hhbmdlZCIsImN1cnJlbnQiLCJjb250ZXh0VmFsdWUiLCJjcmVhdGVFbGVtZW50IiwiUHJvdmlkZXIiLCJ2YWx1ZSIsImRlZmF1bHROZXdJbmRleEdldHRlciIsImRlZmF1bHRBbmltYXRlTGF5b3V0Q2hhbmdlcyIsIl9yZWYyIiwiaXNTb3J0aW5nIiwid2FzRHJhZ2dpbmciLCJuZXdJbmRleCIsInByZXZpb3VzSXRlbXMiLCJwcmV2aW91c0NvbnRhaW5lcklkIiwidHJhbnNpdGlvbiIsImRlZmF1bHRUcmFuc2l0aW9uIiwiZHVyYXRpb24iLCJlYXNpbmciLCJ0cmFuc2l0aW9uUHJvcGVydHkiLCJkaXNhYmxlZFRyYW5zaXRpb24iLCJUcmFuc2l0aW9uIiwidG9TdHJpbmciLCJwcm9wZXJ0eSIsImRlZmF1bHRBdHRyaWJ1dGVzIiwicm9sZURlc2NyaXB0aW9uIiwidXNlRGVyaXZlZFRyYW5zZm9ybSIsIm5vZGUiLCJkZXJpdmVkVHJhbnNmb3JtIiwic2V0RGVyaXZlZHRyYW5zZm9ybSIsInByZXZpb3VzSW5kZXgiLCJpbml0aWFsIiwiaWdub3JlVHJhbnNmb3JtIiwiZGVsdGEiLCJ1c2VTb3J0YWJsZSIsImFuaW1hdGVMYXlvdXRDaGFuZ2VzIiwiYXR0cmlidXRlcyIsInVzZXJEZWZpbmVkQXR0cmlidXRlcyIsImxvY2FsRGlzYWJsZWQiLCJkYXRhIiwiY3VzdG9tRGF0YSIsImdldE5ld0luZGV4IiwibG9jYWxTdHJhdGVneSIsInJlc2l6ZU9ic2VydmVyQ29uZmlnIiwiZ2xvYmFsRGlzYWJsZWQiLCJnbG9iYWxTdHJhdGVneSIsIm5vcm1hbGl6ZUxvY2FsRGlzYWJsZWQiLCJzb3J0YWJsZSIsIml0ZW1zQWZ0ZXJDdXJyZW50U29ydGFibGUiLCJpc092ZXIiLCJzZXROb2RlUmVmIiwic2V0RHJvcHBhYmxlTm9kZVJlZiIsInVwZGF0ZU1lYXN1cmVtZW50c0ZvciIsImFjdGl2YXRvckV2ZW50Iiwic2V0RHJhZ2dhYmxlTm9kZVJlZiIsImxpc3RlbmVycyIsInNldEFjdGl2YXRvck5vZGVSZWYiLCJ0cmFuc2Zvcm0iLCJkaXNwbGFjZUl0ZW0iLCJzaG91bGREaXNwbGFjZURyYWdTb3VyY2UiLCJkcmFnU291cmNlRGlzcGxhY2VtZW50IiwiZmluYWxUcmFuc2Zvcm0iLCJhY3RpdmVJZCIsInByZXZpb3VzIiwic2hvdWxkQW5pbWF0ZUxheW91dENoYW5nZXMiLCJ0aW1lb3V0SWQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiZ2V0VHJhbnNpdGlvbiIsInVuZGVmaW5lZCIsIl9sb2NhbERpc2FibGVkJGRyYWdnYSIsIl9sb2NhbERpc2FibGVkJGRyb3BwYSIsImhhc1NvcnRhYmxlRGF0YSIsImVudHJ5IiwiZGlyZWN0aW9ucyIsIkRvd24iLCJSaWdodCIsIlVwIiwiTGVmdCIsInNvcnRhYmxlS2V5Ym9hcmRDb29yZGluYXRlcyIsImV2ZW50IiwiY29udGV4dCIsImNvbGxpc2lvblJlY3QiLCJkcm9wcGFibGVDb250YWluZXJzIiwic2Nyb2xsYWJsZUFuY2VzdG9ycyIsImluY2x1ZGVzIiwiY29kZSIsInByZXZlbnREZWZhdWx0IiwiZmlsdGVyZWRDb250YWluZXJzIiwiZ2V0RW5hYmxlZCIsImZvckVhY2giLCJwdXNoIiwiY29sbGlzaW9ucyIsInBvaW50ZXJDb29yZGluYXRlcyIsImNsb3Nlc3RJZCIsImFjdGl2ZURyb3BwYWJsZSIsIm5ld0Ryb3BwYWJsZSIsIm5ld05vZGUiLCJuZXdTY3JvbGxBbmNlc3RvcnMiLCJoYXNEaWZmZXJlbnRTY3JvbGxBbmNlc3RvcnMiLCJzb21lIiwiZWxlbWVudCIsImhhc1NhbWVDb250YWluZXIiLCJpc1NhbWVDb250YWluZXIiLCJpc0FmdGVyQWN0aXZlIiwiaXNBZnRlciIsIm9mZnNldCIsInJlY3RDb29yZGluYXRlcyIsIm5ld0Nvb3JkaW5hdGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@dnd-kit/sortable/dist/sortable.esm.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@dnd-kit/utilities/dist/utilities.esm.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/@dnd-kit/utilities/dist/utilities.esm.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CSS: () => (/* binding */ CSS),\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   canUseDOM: () => (/* binding */ canUseDOM),\n/* harmony export */   findFirstFocusableNode: () => (/* binding */ findFirstFocusableNode),\n/* harmony export */   getEventCoordinates: () => (/* binding */ getEventCoordinates),\n/* harmony export */   getOwnerDocument: () => (/* binding */ getOwnerDocument),\n/* harmony export */   getWindow: () => (/* binding */ getWindow),\n/* harmony export */   hasViewportRelativeCoordinates: () => (/* binding */ hasViewportRelativeCoordinates),\n/* harmony export */   isDocument: () => (/* binding */ isDocument),\n/* harmony export */   isHTMLElement: () => (/* binding */ isHTMLElement),\n/* harmony export */   isKeyboardEvent: () => (/* binding */ isKeyboardEvent),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isSVGElement: () => (/* binding */ isSVGElement),\n/* harmony export */   isTouchEvent: () => (/* binding */ isTouchEvent),\n/* harmony export */   isWindow: () => (/* binding */ isWindow),\n/* harmony export */   subtract: () => (/* binding */ subtract),\n/* harmony export */   useCombinedRefs: () => (/* binding */ useCombinedRefs),\n/* harmony export */   useEvent: () => (/* binding */ useEvent),\n/* harmony export */   useInterval: () => (/* binding */ useInterval),\n/* harmony export */   useIsomorphicLayoutEffect: () => (/* binding */ useIsomorphicLayoutEffect),\n/* harmony export */   useLatestValue: () => (/* binding */ useLatestValue),\n/* harmony export */   useLazyMemo: () => (/* binding */ useLazyMemo),\n/* harmony export */   useNodeRef: () => (/* binding */ useNodeRef),\n/* harmony export */   usePrevious: () => (/* binding */ usePrevious),\n/* harmony export */   useUniqueId: () => (/* binding */ useUniqueId)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction useCombinedRefs() {\n    for(var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++){\n        refs[_key] = arguments[_key];\n    }\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>(node)=>{\n            refs.forEach((ref)=>ref(node));\n        }, refs);\n}\n// https://github.com/facebook/react/blob/master/packages/shared/ExecutionEnvironment.js\nconst canUseDOM =  false && 0;\nfunction isWindow(element) {\n    const elementString = Object.prototype.toString.call(element);\n    return elementString === \"[object Window]\" || // In Electron context the Window object serializes to [object global]\n    elementString === \"[object global]\";\n}\nfunction isNode(node) {\n    return \"nodeType\" in node;\n}\nfunction getWindow(target) {\n    var _target$ownerDocument, _target$ownerDocument2;\n    if (!target) {\n        return window;\n    }\n    if (isWindow(target)) {\n        return target;\n    }\n    if (!isNode(target)) {\n        return window;\n    }\n    return (_target$ownerDocument = (_target$ownerDocument2 = target.ownerDocument) == null ? void 0 : _target$ownerDocument2.defaultView) != null ? _target$ownerDocument : window;\n}\nfunction isDocument(node) {\n    const { Document } = getWindow(node);\n    return node instanceof Document;\n}\nfunction isHTMLElement(node) {\n    if (isWindow(node)) {\n        return false;\n    }\n    return node instanceof getWindow(node).HTMLElement;\n}\nfunction isSVGElement(node) {\n    return node instanceof getWindow(node).SVGElement;\n}\nfunction getOwnerDocument(target) {\n    if (!target) {\n        return document;\n    }\n    if (isWindow(target)) {\n        return target.document;\n    }\n    if (!isNode(target)) {\n        return document;\n    }\n    if (isDocument(target)) {\n        return target;\n    }\n    if (isHTMLElement(target) || isSVGElement(target)) {\n        return target.ownerDocument;\n    }\n    return document;\n}\n/**\r\n * A hook that resolves to useEffect on the server and useLayoutEffect on the client\r\n * @param callback {function} Callback function that is invoked when the dependencies of the hook change\r\n */ const useIsomorphicLayoutEffect = canUseDOM ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction useEvent(handler) {\n    const handlerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(handler);\n    useIsomorphicLayoutEffect(()=>{\n        handlerRef.current = handler;\n    });\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return handlerRef.current == null ? void 0 : handlerRef.current(...args);\n    }, []);\n}\nfunction useInterval() {\n    const intervalRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const set = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((listener, duration)=>{\n        intervalRef.current = setInterval(listener, duration);\n    }, []);\n    const clear = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (intervalRef.current !== null) {\n            clearInterval(intervalRef.current);\n            intervalRef.current = null;\n        }\n    }, []);\n    return [\n        set,\n        clear\n    ];\n}\nfunction useLatestValue(value, dependencies) {\n    if (dependencies === void 0) {\n        dependencies = [\n            value\n        ];\n    }\n    const valueRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);\n    useIsomorphicLayoutEffect(()=>{\n        if (valueRef.current !== value) {\n            valueRef.current = value;\n        }\n    }, dependencies);\n    return valueRef;\n}\nfunction useLazyMemo(callback, dependencies) {\n    const valueRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const newValue = callback(valueRef.current);\n        valueRef.current = newValue;\n        return newValue;\n    }, [\n        ...dependencies\n    ]);\n}\nfunction useNodeRef(onChange) {\n    const onChangeHandler = useEvent(onChange);\n    const node = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const setNodeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((element)=>{\n        if (element !== node.current) {\n            onChangeHandler == null ? void 0 : onChangeHandler(element, node.current);\n        }\n        node.current = element;\n    }, []);\n    return [\n        node,\n        setNodeRef\n    ];\n}\nfunction usePrevious(value) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        ref.current = value;\n    }, [\n        value\n    ]);\n    return ref.current;\n}\nlet ids = {};\nfunction useUniqueId(prefix, value) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (value) {\n            return value;\n        }\n        const id = ids[prefix] == null ? 0 : ids[prefix] + 1;\n        ids[prefix] = id;\n        return prefix + \"-\" + id;\n    }, [\n        prefix,\n        value\n    ]);\n}\nfunction createAdjustmentFn(modifier) {\n    return function(object) {\n        for(var _len = arguments.length, adjustments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            adjustments[_key - 1] = arguments[_key];\n        }\n        return adjustments.reduce((accumulator, adjustment)=>{\n            const entries = Object.entries(adjustment);\n            for (const [key, valueAdjustment] of entries){\n                const value = accumulator[key];\n                if (value != null) {\n                    accumulator[key] = value + modifier * valueAdjustment;\n                }\n            }\n            return accumulator;\n        }, {\n            ...object\n        });\n    };\n}\nconst add = /*#__PURE__*/ createAdjustmentFn(1);\nconst subtract = /*#__PURE__*/ createAdjustmentFn(-1);\nfunction hasViewportRelativeCoordinates(event) {\n    return \"clientX\" in event && \"clientY\" in event;\n}\nfunction isKeyboardEvent(event) {\n    if (!event) {\n        return false;\n    }\n    const { KeyboardEvent } = getWindow(event.target);\n    return KeyboardEvent && event instanceof KeyboardEvent;\n}\nfunction isTouchEvent(event) {\n    if (!event) {\n        return false;\n    }\n    const { TouchEvent } = getWindow(event.target);\n    return TouchEvent && event instanceof TouchEvent;\n}\n/**\r\n * Returns the normalized x and y coordinates for mouse and touch events.\r\n */ function getEventCoordinates(event) {\n    if (isTouchEvent(event)) {\n        if (event.touches && event.touches.length) {\n            const { clientX: x, clientY: y } = event.touches[0];\n            return {\n                x,\n                y\n            };\n        } else if (event.changedTouches && event.changedTouches.length) {\n            const { clientX: x, clientY: y } = event.changedTouches[0];\n            return {\n                x,\n                y\n            };\n        }\n    }\n    if (hasViewportRelativeCoordinates(event)) {\n        return {\n            x: event.clientX,\n            y: event.clientY\n        };\n    }\n    return null;\n}\nconst CSS = /*#__PURE__*/ Object.freeze({\n    Translate: {\n        toString (transform) {\n            if (!transform) {\n                return;\n            }\n            const { x, y } = transform;\n            return \"translate3d(\" + (x ? Math.round(x) : 0) + \"px, \" + (y ? Math.round(y) : 0) + \"px, 0)\";\n        }\n    },\n    Scale: {\n        toString (transform) {\n            if (!transform) {\n                return;\n            }\n            const { scaleX, scaleY } = transform;\n            return \"scaleX(\" + scaleX + \") scaleY(\" + scaleY + \")\";\n        }\n    },\n    Transform: {\n        toString (transform) {\n            if (!transform) {\n                return;\n            }\n            return [\n                CSS.Translate.toString(transform),\n                CSS.Scale.toString(transform)\n            ].join(\" \");\n        }\n    },\n    Transition: {\n        toString (_ref) {\n            let { property, duration, easing } = _ref;\n            return property + \" \" + duration + \"ms \" + easing;\n        }\n    }\n});\nconst SELECTOR = \"a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not(:disabled),*[tabindex]\";\nfunction findFirstFocusableNode(element) {\n    if (element.matches(SELECTOR)) {\n        return element;\n    }\n    return element.querySelector(SELECTOR);\n}\n //# sourceMappingURL=utilities.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BkbmQta2l0L3V0aWxpdGllcy9kaXN0L3V0aWxpdGllcy5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWlGO0FBRWpGLFNBQVNLO0lBQ1AsSUFBSyxJQUFJQyxPQUFPQyxVQUFVQyxNQUFNLEVBQUVDLE9BQU8sSUFBSUMsTUFBTUosT0FBT0ssT0FBTyxHQUFHQSxPQUFPTCxNQUFNSyxPQUFRO1FBQ3ZGRixJQUFJLENBQUNFLEtBQUssR0FBR0osU0FBUyxDQUFDSSxLQUFLO0lBQzlCO0lBRUEsT0FBT1gsOENBQU9BLENBQUMsSUFBTVksQ0FBQUE7WUFDbkJILEtBQUtJLE9BQU8sQ0FBQ0MsQ0FBQUEsTUFBT0EsSUFBSUY7UUFDMUIsR0FDQUg7QUFDRjtBQUVBLHdGQUF3RjtBQUN4RixNQUFNTSxZQUFZLE1BQTRELElBQWUsQ0FBeUM7QUFFdEksU0FBU0ksU0FBU0MsT0FBTztJQUN2QixNQUFNQyxnQkFBZ0JDLE9BQU9DLFNBQVMsQ0FBQ0MsUUFBUSxDQUFDQyxJQUFJLENBQUNMO0lBQ3JELE9BQU9DLGtCQUFrQixxQkFBcUIsc0VBQXNFO0lBQ3BIQSxrQkFBa0I7QUFDcEI7QUFFQSxTQUFTSyxPQUFPZCxJQUFJO0lBQ2xCLE9BQU8sY0FBY0E7QUFDdkI7QUFFQSxTQUFTZSxVQUFVQyxNQUFNO0lBQ3ZCLElBQUlDLHVCQUF1QkM7SUFFM0IsSUFBSSxDQUFDRixRQUFRO1FBQ1gsT0FBT1o7SUFDVDtJQUVBLElBQUlHLFNBQVNTLFNBQVM7UUFDcEIsT0FBT0E7SUFDVDtJQUVBLElBQUksQ0FBQ0YsT0FBT0UsU0FBUztRQUNuQixPQUFPWjtJQUNUO0lBRUEsT0FBTyxDQUFDYSx3QkFBd0IsQ0FBQ0MseUJBQXlCRixPQUFPRyxhQUFhLEtBQUssT0FBTyxLQUFLLElBQUlELHVCQUF1QkUsV0FBVyxLQUFLLE9BQU9ILHdCQUF3QmI7QUFDM0s7QUFFQSxTQUFTaUIsV0FBV3JCLElB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QUFXLFFBQVEyRDtRQUM3QztJQUVGO0FBQ0Y7QUFFQSxNQUFNQyxXQUFXO0FBQ2pCLFNBQVNDLHVCQUF1QjNGLE9BQU87SUFDckMsSUFBSUEsUUFBUTRGLE9BQU8sQ0FBQ0YsV0FBVztRQUM3QixPQUFPMUY7SUFDVDtJQUVBLE9BQU9BLFFBQVE2RixhQUFhLENBQUNIO0FBQy9CO0FBRW1YLENBQ25YLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQGRuZC1raXQvdXRpbGl0aWVzL2Rpc3QvdXRpbGl0aWVzLmVzbS5qcz80NGI1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZU1lbW8sIHVzZUxheW91dEVmZmVjdCwgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuXG5mdW5jdGlvbiB1c2VDb21iaW5lZFJlZnMoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCByZWZzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHJlZnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gdXNlTWVtbygoKSA9PiBub2RlID0+IHtcbiAgICByZWZzLmZvckVhY2gocmVmID0+IHJlZihub2RlKSk7XG4gIH0sIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgcmVmcyk7XG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL21hc3Rlci9wYWNrYWdlcy9zaGFyZWQvRXhlY3V0aW9uRW52aXJvbm1lbnQuanNcbmNvbnN0IGNhblVzZURPTSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbmZ1bmN0aW9uIGlzV2luZG93KGVsZW1lbnQpIHtcbiAgY29uc3QgZWxlbWVudFN0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlbGVtZW50KTtcbiAgcmV0dXJuIGVsZW1lbnRTdHJpbmcgPT09ICdbb2JqZWN0IFdpbmRvd10nIHx8IC8vIEluIEVsZWN0cm9uIGNvbnRleHQgdGhlIFdpbmRvdyBvYmplY3Qgc2VyaWFsaXplcyB0byBbb2JqZWN0IGdsb2JhbF1cbiAgZWxlbWVudFN0cmluZyA9PT0gJ1tvYmplY3QgZ2xvYmFsXSc7XG59XG5cbmZ1bmN0aW9uIGlzTm9kZShub2RlKSB7XG4gIHJldHVybiAnbm9kZVR5cGUnIGluIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvdyh0YXJnZXQpIHtcbiAgdmFyIF90YXJnZXQkb3duZXJEb2N1bWVudCwgX3RhcmdldCRvd25lckRvY3VtZW50MjtcblxuICBpZiAoIXRhcmdldCkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICBpZiAoaXNXaW5kb3codGFyZ2V0KSkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBpZiAoIWlzTm9kZSh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiAoX3RhcmdldCRvd25lckRvY3VtZW50ID0gKF90YXJnZXQkb3duZXJEb2N1bWVudDIgPSB0YXJnZXQub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YXJnZXQkb3duZXJEb2N1bWVudDIuZGVmYXVsdFZpZXcpICE9IG51bGwgPyBfdGFyZ2V0JG93bmVyRG9jdW1lbnQgOiB3aW5kb3c7XG59XG5cbmZ1bmN0aW9uIGlzRG9jdW1lbnQobm9kZSkge1xuICBjb25zdCB7XG4gICAgRG9jdW1lbnRcbiAgfSA9IGdldFdpbmRvdyhub2RlKTtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBEb2N1bWVudDtcbn1cblxuZnVuY3Rpb24gaXNIVE1MRWxlbWVudChub2RlKSB7XG4gIGlmIChpc1dpbmRvdyhub2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgZ2V0V2luZG93KG5vZGUpLkhUTUxFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBpc1NWR0VsZW1lbnQobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIGdldFdpbmRvdyhub2RlKS5TVkdFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBnZXRPd25lckRvY3VtZW50KHRhcmdldCkge1xuICBpZiAoIXRhcmdldCkge1xuICAgIHJldHVybiBkb2N1bWVudDtcbiAgfVxuXG4gIGlmIChpc1dpbmRvdyh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIHRhcmdldC5kb2N1bWVudDtcbiAgfVxuXG4gIGlmICghaXNOb2RlKHRhcmdldCkpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQ7XG4gIH1cblxuICBpZiAoaXNEb2N1bWVudCh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIGlmIChpc0hUTUxFbGVtZW50KHRhcmdldCkgfHwgaXNTVkdFbGVtZW50KHRhcmdldCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gIH1cblxuICByZXR1cm4gZG9jdW1lbnQ7XG59XG5cbi8qKlxyXG4gKiBBIGhvb2sgdGhhdCByZXNvbHZlcyB0byB1c2VFZmZlY3Qgb24gdGhlIHNlcnZlciBhbmQgdXNlTGF5b3V0RWZmZWN0IG9uIHRoZSBjbGllbnRcclxuICogQHBhcmFtIGNhbGxiYWNrIHtmdW5jdGlvbn0gQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBpbnZva2VkIHdoZW4gdGhlIGRlcGVuZGVuY2llcyBvZiB0aGUgaG9vayBjaGFuZ2VcclxuICovXG5cbmNvbnN0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSBjYW5Vc2VET00gPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5cbmZ1bmN0aW9uIHVzZUV2ZW50KGhhbmRsZXIpIHtcbiAgY29uc3QgaGFuZGxlclJlZiA9IHVzZVJlZihoYW5kbGVyKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaGFuZGxlclJlZi5jdXJyZW50ID0gaGFuZGxlcjtcbiAgfSk7XG4gIHJldHVybiB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBoYW5kbGVyUmVmLmN1cnJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZXJSZWYuY3VycmVudCguLi5hcmdzKTtcbiAgfSwgW10pO1xufVxuXG5mdW5jdGlvbiB1c2VJbnRlcnZhbCgpIHtcbiAgY29uc3QgaW50ZXJ2YWxSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IHNldCA9IHVzZUNhbGxiYWNrKChsaXN0ZW5lciwgZHVyYXRpb24pID0+IHtcbiAgICBpbnRlcnZhbFJlZi5jdXJyZW50ID0gc2V0SW50ZXJ2YWwobGlzdGVuZXIsIGR1cmF0aW9uKTtcbiAgfSwgW10pO1xuICBjb25zdCBjbGVhciA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoaW50ZXJ2YWxSZWYuY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbFJlZi5jdXJyZW50KTtcbiAgICAgIGludGVydmFsUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfSwgW10pO1xuICByZXR1cm4gW3NldCwgY2xlYXJdO1xufVxuXG5mdW5jdGlvbiB1c2VMYXRlc3RWYWx1ZSh2YWx1ZSwgZGVwZW5kZW5jaWVzKSB7XG4gIGlmIChkZXBlbmRlbmNpZXMgPT09IHZvaWQgMCkge1xuICAgIGRlcGVuZGVuY2llcyA9IFt2YWx1ZV07XG4gIH1cblxuICBjb25zdCB2YWx1ZVJlZiA9IHVzZVJlZih2YWx1ZSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh2YWx1ZVJlZi5jdXJyZW50ICE9PSB2YWx1ZSkge1xuICAgICAgdmFsdWVSZWYuY3VycmVudCA9IHZhbHVlO1xuICAgIH1cbiAgfSwgZGVwZW5kZW5jaWVzKTtcbiAgcmV0dXJuIHZhbHVlUmVmO1xufVxuXG5mdW5jdGlvbiB1c2VMYXp5TWVtbyhjYWxsYmFjaywgZGVwZW5kZW5jaWVzKSB7XG4gIGNvbnN0IHZhbHVlUmVmID0gdXNlUmVmKCk7XG4gIHJldHVybiB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBuZXdWYWx1ZSA9IGNhbGxiYWNrKHZhbHVlUmVmLmN1cnJlbnQpO1xuICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBuZXdWYWx1ZTtcbiAgICByZXR1cm4gbmV3VmFsdWU7XG4gIH0sIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgWy4uLmRlcGVuZGVuY2llc10pO1xufVxuXG5mdW5jdGlvbiB1c2VOb2RlUmVmKG9uQ2hhbmdlKSB7XG4gIGNvbnN0IG9uQ2hhbmdlSGFuZGxlciA9IHVzZUV2ZW50KG9uQ2hhbmdlKTtcbiAgY29uc3Qgbm9kZSA9IHVzZVJlZihudWxsKTtcbiAgY29uc3Qgc2V0Tm9kZVJlZiA9IHVzZUNhbGxiYWNrKGVsZW1lbnQgPT4ge1xuICAgIGlmIChlbGVtZW50ICE9PSBub2RlLmN1cnJlbnQpIHtcbiAgICAgIG9uQ2hhbmdlSGFuZGxlciA9PSBudWxsID8gdm9pZCAwIDogb25DaGFuZ2VIYW5kbGVyKGVsZW1lbnQsIG5vZGUuY3VycmVudCk7XG4gICAgfVxuXG4gICAgbm9kZS5jdXJyZW50ID0gZWxlbWVudDtcbiAgfSwgLy9lc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgW10pO1xuICByZXR1cm4gW25vZGUsIHNldE5vZGVSZWZdO1xufVxuXG5mdW5jdGlvbiB1c2VQcmV2aW91cyh2YWx1ZSkge1xuICBjb25zdCByZWYgPSB1c2VSZWYoKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICB9LCBbdmFsdWVdKTtcbiAgcmV0dXJuIHJlZi5jdXJyZW50O1xufVxuXG5sZXQgaWRzID0ge307XG5mdW5jdGlvbiB1c2VVbmlxdWVJZChwcmVmaXgsIHZhbHVlKSB7XG4gIHJldHVybiB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBpZCA9IGlkc1twcmVmaXhdID09IG51bGwgPyAwIDogaWRzW3ByZWZpeF0gKyAxO1xuICAgIGlkc1twcmVmaXhdID0gaWQ7XG4gICAgcmV0dXJuIHByZWZpeCArIFwiLVwiICsgaWQ7XG4gIH0sIFtwcmVmaXgsIHZhbHVlXSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFkanVzdG1lbnRGbihtb2RpZmllcikge1xuICByZXR1cm4gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhZGp1c3RtZW50cyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhZGp1c3RtZW50c1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkanVzdG1lbnRzLnJlZHVjZSgoYWNjdW11bGF0b3IsIGFkanVzdG1lbnQpID0+IHtcbiAgICAgIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhhZGp1c3RtZW50KTtcblxuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZUFkanVzdG1lbnRdIG9mIGVudHJpZXMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhY2N1bXVsYXRvcltrZXldO1xuXG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3Jba2V5XSA9IHZhbHVlICsgbW9kaWZpZXIgKiB2YWx1ZUFkanVzdG1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH0sIHsgLi4ub2JqZWN0XG4gICAgfSk7XG4gIH07XG59XG5cbmNvbnN0IGFkZCA9IC8qI19fUFVSRV9fKi9jcmVhdGVBZGp1c3RtZW50Rm4oMSk7XG5jb25zdCBzdWJ0cmFjdCA9IC8qI19fUFVSRV9fKi9jcmVhdGVBZGp1c3RtZW50Rm4oLTEpO1xuXG5mdW5jdGlvbiBoYXNWaWV3cG9ydFJlbGF0aXZlQ29vcmRpbmF0ZXMoZXZlbnQpIHtcbiAgcmV0dXJuICdjbGllbnRYJyBpbiBldmVudCAmJiAnY2xpZW50WScgaW4gZXZlbnQ7XG59XG5cbmZ1bmN0aW9uIGlzS2V5Ym9hcmRFdmVudChldmVudCkge1xuICBpZiAoIWV2ZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIEtleWJvYXJkRXZlbnRcbiAgfSA9IGdldFdpbmRvdyhldmVudC50YXJnZXQpO1xuICByZXR1cm4gS2V5Ym9hcmRFdmVudCAmJiBldmVudCBpbnN0YW5jZW9mIEtleWJvYXJkRXZlbnQ7XG59XG5cbmZ1bmN0aW9uIGlzVG91Y2hFdmVudChldmVudCkge1xuICBpZiAoIWV2ZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIFRvdWNoRXZlbnRcbiAgfSA9IGdldFdpbmRvdyhldmVudC50YXJnZXQpO1xuICByZXR1cm4gVG91Y2hFdmVudCAmJiBldmVudCBpbnN0YW5jZW9mIFRvdWNoRXZlbnQ7XG59XG5cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBub3JtYWxpemVkIHggYW5kIHkgY29vcmRpbmF0ZXMgZm9yIG1vdXNlIGFuZCB0b3VjaCBldmVudHMuXHJcbiAqL1xuXG5mdW5jdGlvbiBnZXRFdmVudENvb3JkaW5hdGVzKGV2ZW50KSB7XG4gIGlmIChpc1RvdWNoRXZlbnQoZXZlbnQpKSB7XG4gICAgaWYgKGV2ZW50LnRvdWNoZXMgJiYgZXZlbnQudG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2xpZW50WDogeCxcbiAgICAgICAgY2xpZW50WTogeVxuICAgICAgfSA9IGV2ZW50LnRvdWNoZXNbMF07XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZXZlbnQuY2hhbmdlZFRvdWNoZXMgJiYgZXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNsaWVudFg6IHgsXG4gICAgICAgIGNsaWVudFk6IHlcbiAgICAgIH0gPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgaWYgKGhhc1ZpZXdwb3J0UmVsYXRpdmVDb29yZGluYXRlcyhldmVudCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgIHk6IGV2ZW50LmNsaWVudFlcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmNvbnN0IENTUyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgVHJhbnNsYXRlOiB7XG4gICAgdG9TdHJpbmcodHJhbnNmb3JtKSB7XG4gICAgICBpZiAoIXRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9IHRyYW5zZm9ybTtcbiAgICAgIHJldHVybiBcInRyYW5zbGF0ZTNkKFwiICsgKHggPyBNYXRoLnJvdW5kKHgpIDogMCkgKyBcInB4LCBcIiArICh5ID8gTWF0aC5yb3VuZCh5KSA6IDApICsgXCJweCwgMClcIjtcbiAgICB9XG5cbiAgfSxcbiAgU2NhbGU6IHtcbiAgICB0b1N0cmluZyh0cmFuc2Zvcm0pIHtcbiAgICAgIGlmICghdHJhbnNmb3JtKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qge1xuICAgICAgICBzY2FsZVgsXG4gICAgICAgIHNjYWxlWVxuICAgICAgfSA9IHRyYW5zZm9ybTtcbiAgICAgIHJldHVybiBcInNjYWxlWChcIiArIHNjYWxlWCArIFwiKSBzY2FsZVkoXCIgKyBzY2FsZVkgKyBcIilcIjtcbiAgICB9XG5cbiAgfSxcbiAgVHJhbnNmb3JtOiB7XG4gICAgdG9TdHJpbmcodHJhbnNmb3JtKSB7XG4gICAgICBpZiAoIXRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbQ1NTLlRyYW5zbGF0ZS50b1N0cmluZyh0cmFuc2Zvcm0pLCBDU1MuU2NhbGUudG9TdHJpbmcodHJhbnNmb3JtKV0uam9pbignICcpO1xuICAgIH1cblxuICB9LFxuICBUcmFuc2l0aW9uOiB7XG4gICAgdG9TdHJpbmcoX3JlZikge1xuICAgICAgbGV0IHtcbiAgICAgICAgcHJvcGVydHksXG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBlYXNpbmdcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgcmV0dXJuIHByb3BlcnR5ICsgXCIgXCIgKyBkdXJhdGlvbiArIFwibXMgXCIgKyBlYXNpbmc7XG4gICAgfVxuXG4gIH1cbn0pO1xuXG5jb25zdCBTRUxFQ1RPUiA9ICdhLGZyYW1lLGlmcmFtZSxpbnB1dDpub3QoW3R5cGU9aGlkZGVuXSk6bm90KDpkaXNhYmxlZCksc2VsZWN0Om5vdCg6ZGlzYWJsZWQpLHRleHRhcmVhOm5vdCg6ZGlzYWJsZWQpLGJ1dHRvbjpub3QoOmRpc2FibGVkKSwqW3RhYmluZGV4XSc7XG5mdW5jdGlvbiBmaW5kRmlyc3RGb2N1c2FibGVOb2RlKGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQubWF0Y2hlcyhTRUxFQ1RPUikpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoU0VMRUNUT1IpO1xufVxuXG5leHBvcnQgeyBDU1MsIGFkZCwgY2FuVXNlRE9NLCBmaW5kRmlyc3RGb2N1c2FibGVOb2RlLCBnZXRFdmVudENvb3JkaW5hdGVzLCBnZXRPd25lckRvY3VtZW50LCBnZXRXaW5kb3csIGhhc1ZpZXdwb3J0UmVsYXRpdmVDb29yZGluYXRlcywgaXNEb2N1bWVudCwgaXNIVE1MRWxlbWVudCwgaXNLZXlib2FyZEV2ZW50LCBpc05vZGUsIGlzU1ZHRWxlbWVudCwgaXNUb3VjaEV2ZW50LCBpc1dpbmRvdywgc3VidHJhY3QsIHVzZUNvbWJpbmVkUmVmcywgdXNlRXZlbnQsIHVzZUludGVydmFsLCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0LCB1c2VMYXRlc3RWYWx1ZSwgdXNlTGF6eU1lbW8sIHVzZU5vZGVSZWYsIHVzZVByZXZpb3VzLCB1c2VVbmlxdWVJZCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbGl0aWVzLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJ1c2VNZW1vIiwidXNlTGF5b3V0RWZmZWN0IiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlQ2FsbGJhY2siLCJ1c2VDb21iaW5lZFJlZnMiLCJfbGVuIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwicmVmcyIsIkFycmF5IiwiX2tleSIsIm5vZGUiLCJmb3JFYWNoIiwicmVmIiwiY2FuVXNlRE9NIiwid2luZG93IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaXNXaW5kb3ciLCJlbGVtZW50IiwiZWxlbWVudFN0cmluZyIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsImlzTm9kZSIsImdldFdpbmRvdyIsInRhcmdldCIsIl90YXJnZXQkb3duZXJEb2N1bWVudCIsIl90YXJnZXQkb3duZXJEb2N1bWVudDIiLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJpc0RvY3VtZW50IiwiRG9jdW1lbnQiLCJpc0hUTUxFbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJpc1NWR0VsZW1lbnQiLCJTVkdFbGVtZW50IiwiZ2V0T3duZXJEb2N1bWVudCIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJ1c2VFdmVudCIsImhhbmRsZXIiLCJoYW5kbGVyUmVmIiwiY3VycmVudCIsImFyZ3MiLCJ1c2VJbnRlcnZhbCIsImludGVydmFsUmVmIiwic2V0IiwibGlzdGVuZXIiLCJkdXJhdGlvbiIsInNldEludGVydmFsIiwiY2xlYXIiLCJjbGVhckludGVydmFsIiwidXNlTGF0ZXN0VmFsdWUiLCJ2YWx1ZSIsImRlcGVuZGVuY2llcyIsInZhbHVlUmVmIiwidXNlTGF6eU1lbW8iLCJjYWxsYmFjayIsIm5ld1ZhbHVlIiwidXNlTm9kZVJlZiIsIm9uQ2hhbmdlIiwib25DaGFuZ2VIYW5kbGVyIiwic2V0Tm9kZVJlZiIsInVzZVByZXZpb3VzIiwiaWRzIiwidXNlVW5pcXVlSWQiLCJwcmVmaXgiLCJpZCIsImNyZWF0ZUFkanVzdG1lbnRGbiIsIm1vZGlmaWVyIiwib2JqZWN0IiwiYWRqdXN0bWVudHMiLCJyZWR1Y2UiLCJhY2N1bXVsYXRvciIsImFkanVzdG1lbnQiLCJlbnRyaWVzIiwia2V5IiwidmFsdWVBZGp1c3RtZW50IiwiYWRkIiwic3VidHJhY3QiLCJoYXNWaWV3cG9ydFJlbGF0aXZlQ29vcmRpbmF0ZXMiLCJldmVudCIsImlzS2V5Ym9hcmRFdmVudCIsIktleWJvYXJkRXZlbnQiLCJpc1RvdWNoRXZlbnQiLCJUb3VjaEV2ZW50IiwiZ2V0RXZlbnRDb29yZGluYXRlcyIsInRvdWNoZXMiLCJjbGllbnRYIiwieCIsImNsaWVudFkiLCJ5IiwiY2hhbmdlZFRvdWNoZXMiLCJDU1MiLCJmcmVlemUiLCJUcmFuc2xhdGUiLCJ0cmFuc2Zvcm0iLCJNYXRoIiwicm91bmQiLCJTY2FsZSIsInNjYWxlWCIsInNjYWxlWSIsIlRyYW5zZm9ybSIsImpvaW4iLCJUcmFuc2l0aW9uIiwiX3JlZiIsInByb3BlcnR5IiwiZWFzaW5nIiwiU0VMRUNUT1IiLCJmaW5kRmlyc3RGb2N1c2FibGVOb2RlIiwibWF0Y2hlcyIsInF1ZXJ5U2VsZWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@dnd-kit/utilities/dist/utilities.esm.js\n");

/***/ })

};
;